ガーベージコレクション勉強するのに、日本語の本は
"ガベージコレクションのアルゴリズムと実装" くらいしかまともなのが無い．
その作者が書いてて
http://wiki.livedoor.jp/author_nari/
というのがあるけど、本の内容をものすごく薄くしたやつだから、
役には立たないかもしれない．

以下、私が実装したGCのレポート

# mark sweep GC の実装

heap上のオブジェクトにヘッダをつける．
ヘッダは1 word もしくは、2 word.
1 word目は種類を表すのと、内、適当な上の1bitはmarkに使う．
種類とは、
    空であること    : 0
    配列かタプル    : 1
    クロージャ      : 2
従って初めに、ヒープは0で満たされる必要がある．
シミュレータでは、メモリは0で初期化されている．

種類が0であった場合、次のwordには次のオブジェクトの始まりがあるか
0があるかである．

1か2だった場合、次のwordには、オブジェクトの長さを入れておき、
更に次のwordから、その長さ分、実際にオブジェクトが入っているとする．

markのための1bitは、10進法で4096を加減算することにする．
本当は最高位1bitの方がいい．理由は後述．

+-------+
|   0   |
+-------+
|   0   |
+-------+  ^
|   1   |  |
+-------+  |
|   3   |  |
+-------+  |  array [x,y,z]
|   x   |  |   or
+-------+  |  tuple (x,y,z)
|   y   |  |
+-------+  |
|   z   |  |
+-------+  v
|   0   |
+-------+
|       |

配列の中身や、レジスタ、スタック上の値は種類が分からないけれど,
両方の可能性があるならば、ポインタだとする保守的なGCである．

copy GCのようにオブジェクトをヒープ上で動かさないので、GCし損なう
ものが蓄積する可能性はあるにしても、プログラムの期待する動きは保証できる．
しかしながら、ポインタでないものをポインタとした場合に、ヒープ上の
単なる値について、markをする可能性がある．今markを4096としたので、
値として使えるのは4095以下である．

実際にヘッダを付ける処理は virtual.ml と、Array.create はアセンブリ
実装なので、libmincaml.s の該当部を変更した．
(* virtual_gc.ml, libmincaml_gc.s という別ファイルにしてある．
   コマンドライン引数として,実際に使うものとして GCアリ か ナシか
   を, スイッチできるといいだろう． *)

ヒープにオブジェクトを作るには、アセンブリ上で 確保したいメモリサイズ
(ヘッダのサイズを含めて) を$r6レジスタに入れた状態でalloc を呼ぶと、
$r6に先頭アドレスが入って戻ってくるということにする．

allocのすることは、サイズを見てGCの必要があるかを判別．
GCの必要が無い時には、ただその時のヒープレジスタの値を返せばよい．
返す直前にヒープレジスタはサイズ分、増やしておく．

ヒープアドレス、プラス、サイズがヒープの限界、今は4096として(もちろん
上に書いた制限がある為である)を超えた場合、GCの必要があると判断し、
一般にmark-sweepと呼ばれるガーベージコレクションを行う．

ただ、sweepの結果、ヒープに空きを作り、allocの際にそれを再利用
しようとするが、ヒープレジスタの中身は変わらないので、次のalloc
でも必ずGCのの必要アリと判断され、毎度mark-sweepすることになっている．

(* 当然ながら時間がかかりすぎることになりますが、一応のGCとしては
   仕様通りということで、そのまま提出します．
   改善点としては、GCの必要の判断に、sweep済みと仮定して、
   そのサイズの空きを探して、見つからなかった場合にのみ、
   mark-sweepすることにする、という改良をすることでしょう. *)

libmincaml_gc.s のはじめの方に書いてあることそのままであるので
説明は省く．

次のようなコードが動くようになる．

    let rec f n =
        if n > 5 then 7 else
        let gomi = Array.create 1000 2 in
        f (n+1)
    in
    print_int (f 0)

最終的に 7 と出力して無事終わる．
fを5回繰り返すことで、大きさ1000の配列を5回作ることになる．
heap size を4096に制限すると、GCしないならば、4回でプログラムは
セグメンタルフォルトを起こす．

数字を6に変更することで、6回作り、GCは2回行われるはずで、
実際, 7 を出力してプログラムは終了した．正しい．

GCを切った場合を簡単に見るには、今のトコロ、libmincaml_gc.s の
15行目をコメントアウトすればよい．GCの必要性を常にfalseにすること
になる．またその場合、ヒープは本来の限界の1000,000まで使い,
(正確にはスタックと分け合う) 上のコードは無事動いてしまうので

    let rec f n =
        if n > 500 then 7 else
        let gomi = Array.create 2000 2 in
        f (n+1)
    in
    print_int (f 0)

と500回、大きさ2000の配列を確保させると、
test/garbage.out > test/garbage.out120.txt
Segmentation fault (core dumped)
make: *** [test/garbage] Error 139
このようなメッセージを吐いて終了する．
(* このメッセージは、アセンブリをC言語に変換し、gcc4.4.7によって
   コンパイル・実行したもの． *)
500*2000 = 1000,000 ということで、大体計算と合っている．

やはり対等にheap size を揃えて実験すべきなので、
libmincaml_gc.sを次のように変更した．先ほどのコメントアウトは
取りやめて、
23a24,26
>       mvlo $r6, 33
>       outputb $r6
>       j halt
つまり、ヒープが限界を超えると ! を出力して、haltする．
(私どもの班では、halt命令の代わりに "j halt"を使っています)

とすれば、ただ ! とだけ出力されて終わるプログラムを確認できた．

