<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>随伴が導くモナド</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">随伴が導くモナド</h1>
<p><p class=date style='text-align: right'>2019-02-08 (Fri.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#圏論>圏論</a> </div></p>
<p>\(\def\A{\mathcal A}
\def\B{\mathcal B}
\def\Hom{\mathrm Hom}
\def\Sets{\mathrm Sets}
\def\Gr{\mathrm Gr}\) \(\require{amscd}\)</p>
<h2>概要</h2>
<p>随伴 \(F \dashv U\) があるとき \(UF\) はモナドになる.</p>
<p>このことを確認する前に随伴とモナドについて復習する.</p>
<h2>復習</h2>
<h3>随伴</h3>
<p>2つの互いに逆方向の関手 \(F \colon \A \to \B\) と \(U \colon \B \to \A\) とがあって, 任意の \(X \in \A, Y \in \B\) について,</p>
\[\Hom_\B(FX, Y) \simeq \Hom_\A(X, UY)\]
<p>という <strong>自然な</strong> 同型関係ががあるとき,</p>
\[F \dashv U\]
<p>であると書いて, \(F, U\) が随伴であるという.</p>
<p>この同型の対応を</p>
\[\Phi \colon \Hom_\B(FX, Y) \rightleftharpoons \Hom_\A(X, UY) \colon \Psi\]
<p>と書くことにする.</p>
<p>ここでまず同型関係であるので, 左右の \(\Hom\) に一対一対応があること. つまり \(\Phi\) と \(\Psi\) は互いに逆の関数になっている (Hom は集合とする).</p>
<p>しかもその対応が自然であることを要請する. 自然であるということの意味はここでは次の通り.</p>
<p>任意の \(g \colon X&#x27; \to X, h \colon Y \to Y&#x27;\) について次が可換.</p>
\[\begin{CD}
\Hom_\B(FX, Y) @&gt;\Phi&gt;&gt; \Hom_\A(X, UY) \\
@Vh-FgVV @VUh-gVV \\
\Hom_\B(FX&#x27;, Y&#x27;) @&gt;\Phi&gt;&gt; \Hom_\A(X&#x27;, UY&#x27;) \\
\end{CD}\]
<p>ここで縦の射は</p>
<ul>
  <li>\((h-Fg) : f \mapsto h \circ f \circ Fg\)</li>
  <li>\((Uh-g) : f \mapsto Uh \circ f \circ g\)</li>
</ul>
<p>という関数のこと. 左上から \(f : FX \to Y\) という射を自由に取ってくれば, 次の等式が成り立つことが可換性である.</p>
<p><div class=thm> ( \(\Phi\) の自然性)</p>
\[\Phi(h~f~Fg) = Uh~\Phi f~g\]
<p></div></p>
<p>同様に \(\Psi\) も自然である必要がある. ( <a href="http://cympfh.cc/taglibro/2019/01/22.html">といっても, 一方が自然ならその逆も自然になる</a> .) 向きが逆なだけで全く同様に,</p>
\[\begin{CD}
\Hom_\B(FX, Y) @&lt;\Psi&lt;&lt; \Hom_\A(X, UY) \\
@Vh-FgVV @VUh-gVV \\
\Hom_\B(FX&#x27;, Y&#x27;) @&lt;\Psi&lt;&lt; \Hom_\A(X&#x27;, UY&#x27;) \\
\end{CD}\]
<p><div class=thm> ( \(\Psi\) の自然性)</p>
\[\Psi(Uh~f~g) = h~\Psi f~Fg\]
<p></div></p>
<p>2つの自然性の式はあとで使うので使いやすい形にだけしておいてメモしておく.</p>
<p><div class=thm> <strong>memo</strong></p>
\[\Phi(h) = Uh~\Phi 1\]
\[\Psi(Uh~f) = h~\Psi f\]
<p>それぞれ適切に \(1\) を代入すればこれが出てくる. </div></p>
<h3>モナド</h3>
<p>モナドと言ったが個人的には Kleisli Triple の形の方がわかりやすい (定義も書きやすい) のでこちらを使う. モナドとは同値な概念で変換も簡単なのでどっちでも良い.</p>
<p>ここでは次の \((T,\eta,-^\sharp)\) を圏 \(\A\) の Kleisli Triple と呼ぶ.</p>
<p><div class=thm></p>
<ul>
  <li>
    関手 \(T : \A \to \A\)
    <ul>
      <li>(実際には対象の対応付だけで十分)</li>
    </ul>
  </li>
  <li>
    ポリモーフィズム \(\eta : 1 \to T\)
    <ul>
      <li>ポリモーフィズムとは自然である必要はない自然変換</li>
      <li>ここでは各対象 \(X \in \A\) について \(\eta_X : X \to TX\) なる射を与えるもの</li>
    </ul>
  </li>
  <li>
    \(-^\sharp \colon \Hom(A,TB) \to \Hom(TA, TB)\)
    <ul>
      <li>\(f \mapsto f^\sharp\)</li>
    </ul>
  </li>
</ul>
<p>であって次の3つが成立するもの.</p>
<ol>
  <li>\(\eta_X^\sharp = 1_{TX}\)</li>
  <li>\(f = f^\sharp \eta_X\) ( \(f \colon X \to TY\) )</li>
  <li>\((g^\sharp f)^\sharp = g^\sharp f^\sharp\)</li>
</ol>
<p></div></p>
<p>以上が Kleisli Triple である.</p>
<blockquote>\(\eta\) は適当に自然変換になって, \(\mu_X = 1_{TX}^\sharp\) とすれば \((T,\eta,\mu)\) がいわゆるモナドそのものになる.</blockquote>
<h2>随伴の合成はモナド</h2>
<p>主張は以下の通りであった.</p>
<blockquote>随伴 \(F \dashv U\) について \(UF\) はモナド.</blockquote>
<p>\(F \colon \A \to \B\) , \(U \colon \B \to \A\) とすると</p>
\[UF \colon \A \to \A\]
<p>であり, 随伴の対応関係を前に書いたように \(\Phi, \Psi\) とすると,</p>
\[\eta_X = \Phi(1_{FX})\]
\[f^\sharp = U(\Psi f)\]
<p>としたときに \((UF, \eta, -^\sharp)\) が実は Kleisli Triple になっていることを示す.</p>
<h3>証明のコツ</h3>
<p>\(1_X\) は常に存在すること. 自然変換の添字や恒等射 \(1\) の添字は気にしない. 適用や合成はただの掛け算. 型だけ正しく揃える.</p>
<p>では Kleisli Triple に要請される3つの条件を満たすことを見ていく.</p>
<h3>1. \(\eta_X^\sharp = 1_{TX}\)</h3>
\[\begin{align*}
\eta_X^\sharp
&amp; = U(\Psi \eta_X) \\
&amp; = U(\Psi \Phi(1_{FX})) \\
&amp; = U1 \\
&amp; = 1_{UFX}
\end{align*}\]
<p>\(T=UF\) なので確かに型もあってる. ただしこれ以降は \(1\) の添字は省略してく.</p>
<h3>2. \(f = f^\sharp \eta_X\)</h3>
<p>右辺から始める.</p>
\[\begin{align*}
f^\sharp \eta_X &amp; = U(\Psi f) \Phi(1) \\
\end{align*}\]
<p>ここで <strong>memo</strong> を思い出すと,</p>
\[\begin{align*}
U(\Psi f) \Phi(1)
&amp; = \Phi(\Psi(f)) \\
&amp; = f
\end{align*}\]
<p>最後は \(\Phi\) は \(\Psi\) の逆関数であることを使った.</p>
<h3>3. \((g^\sharp f)^\sharp = g^\sharp f^\sharp\)</h3>
\[\begin{align*}
(g^\sharp f)^\sharp
&amp; = U(\Psi(g^\sharp ~ f)) \\
&amp; = U(\Psi((U \Psi g) ~ f)) \\
\end{align*}\]
<p>やはり <strong>memo</strong> を思い出すと, \(\Psi((U \Psi g) ~ f) = (\Psi g) (\Psi f)\) なので,</p>
\[\begin{align*}
(g^\sharp f)^\sharp
&amp; = U ( (\Psi g) (\Psi f) ) \\
&amp; = U(\Psi g) ~ U(\Psi f) \\
&amp; = g^\sharp f^\sharp
\end{align*}\]
<p>最後は \(U\) が関手なので分配できることを使った. 一方で \(\Phi\) や \(\Psi\) は関手ではないので分配できないことに註意.</p>
<p>以上から確かに \(UF\) は適切な操作によって Kleisli Triple になる. そして \(\mu_X = 1_{UFX}^\sharp = U(\Psi 1_{UFX})\) とすることでモナドである.</p>
<h2>例 - リストモナド</h2>
<p>定番の例として自由関手と忘却関手. ここでは集合の圏 Sets と群からなる圏 Gr を考える.</p>
\[F : \Sets \to \Gr\]
<p>は与えられた集合の要素からなる自由群を構成する. 例えば \(F\{a,b\} = \langle a,b \rangle = (\{ \epsilon, a, b, ab, ba, a^2b, aba, \ldots \}, \times)\) .</p>
\[U : \Gr \to \Sets\]
<p>は与えられた群の元の全てからなる集合を構成する (群の構造を忘れる). 例えば \(U \langle a,b \rangle = \{ \epsilon, a, b, ab, ba, a^2b, aba, \ldots \}\) .</p>
<p>従って, 集合 \(X = \{a,b\}\) について</p>
\[UFX = \{ \epsilon, a, b, ab, ba, a^2b, aba, \ldots \}\]
<p>これは, 要素が \(a,b\) からなる文字列のこと. あるいはリストのこと.</p>
<h2>例 - 状態モナド</h2>
<p><a href="https://wiki.haskell.org/State_Monad">状態モナド</a> もやはり随伴の組み合わせで定めることができて</p>
\[- \times A \dashv (-)^A\]
<p>を使う (参考: <a href="power-eval.html">冪が随伴であること</a> ). これによって \(T_A = (- \times A)^A\) がモナドであることがわかる.</p>
<p>随伴の対応を</p>
\[\Phi \colon \Hom(X \times A, Y) \to \Hom(X, Y^A)\]
<p>とする.</p>
<p>\(\eta\) (いわゆる return) は,</p>
\[\eta_X \colon X \to (X \times A)^A\]
\[\eta_X = \Phi(1_{X \times A})\]
\[\eta_X(x) = (a \mapsto (x, a))\]
<p>で与えられる.</p>
<p>以上.</p>
<blockquote>逆に任意のモナドは自明でない随伴に分解出来るのかな?</blockquote>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>