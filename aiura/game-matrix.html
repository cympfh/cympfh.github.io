<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>行列ゲーム</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">行列ゲーム</h1>
<p><p class=date style='text-align: right'>2017-06-17 (Sat.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#ゲーム理論>ゲーム理論</a> </div></p>
<h2>index</h2>
<p><div id=toc></div></p>
<h2>行列ゲームとは何か</h2>
<p>ここでは次のようなゲームを考える.</p>
<ol>
  <li>プレイヤーは2人</li>
  <li>
    プレイヤー \(1,2\) に対し、戦略の選択肢の集合 \(I, J\) がある
    <ul>
      <li>\(I, J\) は 有限集合 - \(I = \{ 1,2, \ldots, |I| \}\) , \(J = \{ 1,2, \ldots, |J| \}\) とする</li>
    </ul>
  </li>
  <li>
    プレイヤー \(k\) に対し <strong>利得関数</strong> \(f_k\) がある
    <ul>
      <li>\(f_1 : I \times J \to \mathbb{R}\)</li>
      <li>\(f_2 : I \times J \to \mathbb{R}\)</li>
      <li>これを評価関数や損失関数と呼んだりする</li>
    </ul>
  </li>
  <li>プレイヤー \(1\) は \(\max f_1(i, j)\) を目指して戦略 \(i (\in I)\) を選び、プレイヤー \(2\) は同様に \(\max f_2(i, j)\) を目指して戦略 \(j\) を選ぶ</li>
  <li>互いのプレイヤーは相手のプレイヤーの戦略を知ることはできない</li>
</ol>
<p>特に最後のルールが特別で、同時に (唯一つの) 手を見せ合ってポイントを分け合うようなゲームを考えている.</p>
<h2>ゼロ和ゲームとは何か</h2>
<p>互いの利得関数の和が常にゼロであるようなゲーム:</p>
\[\forall i, j .~ f_1(i, j) + f_2(i, j) = 0\]
<p>のことを <strong>ゼロ和ゲーム</strong> という. 後述するが (実は) ゼロでなく定数であっても本質は変わらない (戦略的同値) ので、そういう場合もゼロ和ゲームという.</p>
<p>とりあえずは利得の和がゼロになるようなゼロ和ゲームだけのことを考える.</p>
<p>\(a_{ij} = f_1(i, j) = - f_2(i, j)\) とすると、行列 \((a_{ij})\) が描けて、これを利得行列という. プレイヤー \(1, 2\) はそれぞれ、</p>
<ul>
  <li>プレイヤー \(1\) : \(\max_i a_{ij}\)</li>
  <li>プレイヤー \(2\) : \(\min_j a_{ij}\)</li>
</ul>
<p>を目指す.</p>
<p>単に行列ゲームという時、ゼロ和ゲームのことを指し、利得行列 \(A=(a_{ij})\) のことを言う.</p>
<h2>純粋戦略</h2>
<p>互いに相手の手は分からないが、お互い最善を尽くして戦略を考えることを仮定して戦略を考える. 適当な考えの下で、唯一つの戦略を選択することを <strong>純粋戦略</strong> と言う. (実際にプレイできる戦略はただ一つなのだから唯一つの戦略を選択するのは当たり前に思える.)</p>
<h3>純粋戦略のミニマックス原理</h3>
<p>ゼロ和ゲームの純粋戦略を考える. ゼロ和では相手の最善は自分の最悪であるので、相手は自分にとって常に悪い手を取ると考えたほうが良い. 具体的には、相手が自分にとって最悪の手を取ったとしても最もマシな利得が得られるような戦略を考える.</p>
<p>例えば次のような利得行列について</p>
\[A = \left(\begin{array}{ccc}
1 &amp; 1 &amp; -1 \\
2 &amp; -2 &amp; 0 \\
1 &amp; 1 &amp; -2 \\
\end{array}\right)\]
<p>プレイヤー \(1\) が 1 を選ぶとき、第 \(1\) 行ベクトル</p>
\[a_{1\cdot} = \left(\begin{array}{ccc}
1 &amp; 1 &amp; -1 \\
\end{array}\right)\]
<p>が選ばれる. プレイヤー \(1\) にとっての最悪の事態とはこの中の最小が選ばれることで、すなわち プレイヤーが \(3\) を選ぶことによって利得</p>
\[a_{13} = -1\]
<p>が得られることである.</p>
<p>同様に、 \(2\) を選んだ場合は</p>
\[a_{22}=-2\]
<p>が最悪. \(3\) を選んだ場合は</p>
\[a_{33}-2\]
<p>が最悪.</p>
<p>というわけで \(1\) を選んでいれば、最低でも \(-1\) の利得が得られることが分かるので、最もマシな純粋戦略は \(1\) だということが分かる.</p>
<p>以上のようにプレイヤー \(1\) の指針は</p>
\[\max_i \min_j a_{ij}\]
<p>によって \(i\) を選ぶこと.</p>
<p>逆も同様で、プレイヤー \(2\) の指針は</p>
\[\min_j \max_i a_{ij}\]
<p>によって \(j\) を選ぶこと.</p>
<h4>定義</h4>
<p>利得行列 \((a_{ij})\) について</p>
\[\max_i \min_j a_{ij} = \min_j \max_i a_{ij} ~(=v)\]
<p>が成立するとき、このゲームは厳密に決定されるといい、これが成立する \(i, j\) を \(i^*, j^*\) と書いて、 \((i^*, j^*)\) を <strong>均衡点</strong> という. 均衡点が存在するときに \(v\) を <strong>ゲームの値</strong> という.</p>
<h4>定理</h4>
<p>実行列 \((a_{ij})\) について</p>
\[\max_i \min_j a_{ij} \leq \min_j \max_i a_{ij}\]
<p>が常に成り立つ.</p>
<h4>証明</h4>
<p>\(v_1 = \max_i \min_j a_{ij}\) とおく. この値は行列 \((a_{ij})\) の各行ベクトルの最小値の最大値. すなわち、ある第 \(i\) 行目において、成分の値は全て \(v_1\) 以上. これがあるので、各列ベクトルにおける最大値は \(v_1\) 以上. 列ベクトルの最大値の最小値も \(v_1\) 以上. それはまさに \(v_2 = \min_j \max_i a_{ij}\) のことである. というわけで \(v_1 \leq v_2\) が成立する.</p>
<p>ゲームが厳密に定まらないような行列ゲームはいくらでもある. 厳密に定まるかどうかを判定するための定理がある.</p>
<h4>定理 (鞍点定理)</h4>
<p>利得行列に鞍点があることが厳密に定まることの必要十分条件.</p>
<p>ここで鞍点とはある \((i^*, j^*)\) のことで,</p>
\[\forall i, j .~ a_{i j^*} \leq a_{i^* j^*} \leq a_{i^* j}\]
<p>が成立する点のこと. 鞍点があるとき、明らかにその鞍点自体が均衡点となる.</p>
<p>証明は地道に確かめるだけなので略.</p>
<h4>定理</h4>
<p>鞍点として \((i_1, j_1)\) と \((i_2, j_2)\) とがあるとき、 \((i_1, j_2)\) と \((i_2, j_1)\) もまた鞍点である.</p>
<p>さてゲームが厳密に定まらない、すなわち鞍点が存在しない例としてじゃんけんがある.</p>
\[A = \left(\begin{array}{ccc}
0 &amp; 1 &amp; -1 \\
-1 &amp; 0 &amp; 1 \\
1 &amp; -1 &amp; 0
\end{array}\right)\]
<p>マックスミニ値 \((v_1 = \max_i \min_j a_{ij})\) は \(-1\) でミニマックス値 \((v_2 = \min_j \max_i a_{ij})\) は \(1\) である. もちろん鞍点も存在しない.</p>
<p>これが純粋戦略の限界.</p>
<h2>混合戦略</h2>
<p>純粋戦略がまずかったのは確定的に唯一つの戦略を選ぼうとしたことだった. 次は複数の戦略を混ぜることを考える. すなわち、戦略集合の上の確率分布を戦略だと考えこれを <strong>混合戦略</strong> と呼ぶ.</p>
<p>戦略集合 \(I\) に対して</p>
<ul>
  <li>\(p = ( p_i : i \in I, p_i &gt; 0 )\)</li>
  <li>\(\sum_i p_i = 1\)</li>
</ul>
<p>このような行ベクトル \(p\) が混合戦略.</p>
<p>実際に戦略を選択する場合に、 \(p\) に従って \(i \in I\) を選択してプレイする. 何度も繰り返しプレイする場合は明らかにこの混合戦略の考え方が有効そうだが、ただ一回きりのプレイにおいても (あなたが期待値というものを信用するのなら) 有効な考え方である. また純粋戦略は混合戦略の特別な場合 (ある \(i\) についてのみ \(p_i=1\) なる混合戦略) だと言える.</p>
<p>利得行列 \((a_{ij})\) の代わりにその期待値、 <strong>期待利得</strong> \(E\) というものを考えるべきである. プレイヤー \(1, 2\) が混合戦略 \(p, q\) を取る場合の期待利得は</p>
\[E(p, q) = \sum_i \sum_j p_i q_i a_{ij}\]
<p>と計算できる.</p>
<p>ところで \(p, q\) を行ベクトルとして定義してるのでこれは</p>
\[E(p, q) = p A q^T\]
<p>とも書ける ( \(A = (a_{ij})\) ).</p>
<p>略記法として、 \(E\) の引数に \(I, J\) を渡すことを許して</p>
\[E : I \times \mathcal{Q} \to \mathbb{R}\]
\[E(i, q) = \sum_j q_j a_{ij}\]
\[E : \mathcal{P} \times J \to \mathbb{R}\]
\[E(p, j) = \sum_i p_i a_{ij}\]
<p>も定義する. \(E(p, q) = \sum_i p_i E(i, q) = \sum_j q_j E(p, j)\) である.</p>
<h3>混合戦略のミニマックス原理</h3>
<p>純粋戦略の時と同様にミニマックス原理を混合戦略に当てはめる. すなわち、 プレイヤー \(1\) は</p>
\[v_1 = \max_p \min_q E(p, q)\]
<p>を指標にし、プレイヤー \(2\) は</p>
\[v_2 = \min_q \max_p E(p, q)\]
<p>を指標にする. また同様に</p>
\[\max_p \min_q E(p, q) = \min_q \max_p E(p, q) ~~(=v)\]
<p>のとき、 \(v\) をゲームの値といい、そのときの \((p, q)\) を \((p^*, q^*)\) と書いて最適戦略と呼ぶ. これら \(((p^*, q^*), v)\) をまとめてゲームの解などという.</p>
<p>純粋戦略のときに成立する性質がほぼほぼ成り立つことを見ていく.</p>
<h4>補題</h4>
<p>\(E(p,q) = pAq^T\) について</p>
\[\max_p \min_q E(p, q) \leq \min_q \max_p E(p, q)\]
<p>純粋戦略のときと全く同様.</p>
<h4>定理 (混合戦略の鞍点定理)</h4>
<p>最適戦略が \((p^*, q^*)\) であることは次と同値.</p>
\[\forall p, q .~ E(p, q^*) \leq E(p^*, q^*) \leq E(p^*, q)\]
<h4>証明</h4>
<p>純粋戦略のときは鞍点の存在として紹介した.</p>
<p>\((\Rightarrow)\) \((p^*, q^*)\) が最適戦略だとする. <br /> 仮に \(E(p, q^*) &gt; E(p^*, q^*)\) とすると \(E(p^*, q^*) = \max_p \min_q E(p, q)\) に矛盾し、 \(p^*\) の代わりに \(p\) を使ったほうがより最適になる. 従って、 \(E(p, q^*) \leq E(p^*, q^*)\) . \(q\) についても同様.</p>
<p>\((\Leftarrow)\) \(E(p, q^*) \leq E(p^*, q^*)\) とは</p>
\[\max_p E(p, q^*) = E(p^*, q^*)\]
<p>ということ. そして一般に</p>
\[\min_q \max_p E(p, q) \leq \max_p E(p, q^*)\]
<p>は成立するので、 \(q\) についても同様に考えると</p>
\[\min_q \max_p E(p, q) \leq (E(p^*, q^*) \leq) \max_p \min_q E(p, q)\]
<p>が得られる.</p>
<p>先の補題と組み合わせると</p>
\[\min_q \max_p E(p, q) = (E(p^*, q^*) =) \max_p \min_q E(p, q)\]
<p>を得る.</p>
<h4>定理</h4>
<p>最適戦略として \((p_1, q_1)\) と \((p_2, q_2)\) とがあるとき、 \((p_1, q_2)\) と \((p_2, q_1)\) もまた最適戦略である.</p>
<p>混合戦略の場合、確率分布どうしの鞍点みたいなものを探す必要がありそうだが、次の定理によって、もう少し探索範囲が小さくできる.</p>
<h4>定理</h4>
<p>ゲームの解が \(((p^*, q^*), v)\) であることは次と同値.</p>
\[\forall i, j .~ E(i, q^*) \leq v \leq E(p^*, j)\]
<p>すなわち、混合戦略 vs 純粋戦略での利得だけを考慮すればよい.</p>
<h4>証明</h4>
<p>先ほどの定理から</p>
\[\forall p, q .~ E(p, q^*) \leq v \leq E(p^*, q)\]
<p>と同値であることは言える.</p>
<p>\(\max_i E(i, q^*)\) を考えた時、そのような \(i\) が \(i_0\) とすると、 \(\max_p E(p, q^*) = E(i_0, q^*)\) である (すなわち \(p_{i_0} = 1\) ).</p>
<p>なぜなら \(p_{i_0} &lt; 1\) とする \(p&#x27;\) を用いると、</p>
\[\begin{align*}
E(i_0, q^*) - E(p&#x27;, q^*)
&amp; = E(i_0, q^*) - \sum_i p&#x27;_i E(i, q^*) \\
&amp; \geq E(i_0, q^*) - \sum_i p&#x27;_i E(i_0, q^*) \\
&amp; = E(i_0, q^*) - E(i_0, q^*) \\
&amp; = 0
\end{align*}\]
<p>だから \(E(i_0, q^*) \geq E(p&#x27;, q^*)\) を得る. 当たり前.</p>
<p>つまり \(\max_p E(p, q^*) = \max_i E(i, q^*)\) である.</p>
<p>というわけで、 \(\forall p. E(p, q^*) \leq v\) は \(\forall i. E(i, q^*) \leq v\) と言い換えても構わない.</p>
<p>どういうに \(q\) も \(j\) で言い換えられる.</p>
<h4>定理</h4>
<p>ゲームの解が \(((p^*, q^*), v)\) であるとき、</p>
\[\max_i E(i, q^*) = v = \min_j E(p^*, j)\]
<p>で、重要な次の定理がある.</p>
<h4>ミニマックス定理</h4>
<p>任意の行列ゲームに対して必ず解が存在する.</p>
<p>つまり実行列 \(A\) に対して</p>
\[\max_p \min_q pAq^T = \min_q \max_p pAq^T\]
<p>が常に成立する.</p>
<h4>証明</h4>
<p>後でより一般的な場合 (双行列ゲーム) で示す.</p>
<h3>対称行列</h3>
<p>利得行列が歪対称行列になっている、すなわち</p>
\[A = -A^T\]
<p>となるような行列ゲームを <strong>対称行列</strong> という. 歪対称行列の特性として正方行列であること. 従って2人のプレイヤーの取れる戦略は同じ集合だと見なせる. また対角成分はゼロである. 例えばじゃんけんが対称ゲームの例である.</p>
<h4>定理</h4>
<p>対称ゲームのゲームの値はゼロである.</p>
<h4>証明</h4>
<p>ミニマックス定理からゲームの解 \(((p^*, q^*), v)\) の存在は保証されている.</p>
<p>これが解であることと同値な条件は前述した鞍点定理から、任意の \(p, q\) について</p>
\[pAq^{*T} \leq p^*Aq^{*T} \leq p^*Aq^T\]
<p>が成立することであった.</p>
<p>これの各項の転置を取って</p>
\[q^*A^Tp^{*T} \leq q^* A^T p^{*T} \leq q A^T p^{*T}\]
<p>\(A^T=-A\) を代入して</p>
\[q^*Ap^{*T} \geq q^* A p^{*T} \geq q A p^{*T}\]
<p>鞍点定理より、 \((q^*, p^*)\) もまた最適戦略であることが示された. 即ち、プレイヤー \(1\) にとっての最適戦略はプレイヤー \(2\) にとってもそのまま最適戦略となっており、逆も然りであることが分かる. 各プレイヤーの最適戦略の集合というものを考えた時、対称ゲームにおいてそれらは一致する.</p>
<p>というわけで、ゲームの値は</p>
\[v = p^* A q ^{*T} = q^* A p^{*T}\]
<p>となる. 最後のを転置すると</p>
\[v (= v^T) = (q^* A p^{*T})^T = p^* A^T q^{*T} = - p^* A q^{*T} = - v\]
<p>従って</p>
\[v=0\]
<p>を得る.</p>
<h2>双行列ゲーム (非ゼロ和ゲーム)</h2>
<p>プレイヤー2人の利得の和がゼロ (或いは、定数) とは限らないゲームを考える. 2種類の利得を管理する必要があるので行列は2つ必要である. 従って双行列で管理する.</p>
<ul>
  <li>プレイヤー \(1\) の利得: \(f_1(i, j)\)</li>
  <li>プレイヤー \(2\) の利得: \(f_2(i, j)\)</li>
</ul>
<p>に対して、</p>
<ul>
  <li>\(n \times m\) 行列 \(A = (a_{ij} = f_1(i, j))\)</li>
  <li>\(n \times m\) 行列 \(B = (b_{ij} = f_2(i, j))\)</li>
</ul>
<p>ゼロ和ゲームでは \(B = -A\) という関係があったので単に \(A\) だけを持っていれば良かったが今は2つを持っておく. 2つの行列のタプル、または成分を2つの成分のタプルにした行列を双行列という.</p>
\[(A, B) = \left( (a_{ij}, b_{ij}) \right)\]
<p>これによって表現される2人非ゼロ和ゲームを <strong>双行列ゲーム (bimatrix game)</strong> という. 初めに説明した行列ゲームの1つだとして、同様に</p>
<ol>
  <li>プレイヤー \(1\) は \(\max f_1(i, j)\) を目指して戦略 \(i\) を選び、プレイヤー \(2\) は同様に \(\max f_2(i, j)\) を目指して戦略 \(j\) を選ぶ</li>
  <li>互いのプレイヤーは相手のプレイヤーの戦略を知ることはできない</li>
</ol>
<p>これらを仮定する. またプレイ (各々が戦略を選ぶ行為) は一回きりのものとする.</p>
<h3>例. 囚人のジレンマ</h3>
<p>囚人のジレンマ [^1] は双行列ゲームの典型例. 参考文献の Wikipedia では懲役年数が行列になっているが今は最大化を目標にしたいので、これのマイナスを利得だと思えば良い.</p>
\[(A, B) = \left[\begin{array}{cc}
(-2, -2) &amp; (-10, 0) \\
(0, -10) &amp; (-5, -5)
\end{array}\right]\]
<p>ジレンマの囚人のストーリーではこの一列一行目のことを「協力」、二列二行目のことを「裏切り」などとして説明されている.</p>
<p>ところで囚人のジレンマは \((2,2)\) 成分 (二人共裏切り) に落ち着くしか無い. なぜなら、相手がどちらの戦略を選択するにしても、自分は裏切りを選択したほうが利得が上がるからである ( \(-2 \mapsto 0; -10 \mapsto -5\) ).</p>
<h2>ナッシュ均衡 (非協力均衡点)</h2>
<p>基本的には今まで言ってた均衡点と同じ概念.</p>
<p>\(f_1, f_2\) の引数に混合戦略を渡すことを許して期待利得を表現する.</p>
<p>2人の混合戦略の集合 \(\mathcal{P}, \mathcal{Q}\) のある点 \((p^*, q^*)\) が <strong>ナッシュ均衡</strong> であるとは</p>
<ul>
  <li>\(f_1(p^*, q^*) = \max_p f_1(p, q^*)\)</li>
  <li>\(f_2(p^*, q^*) = \max_q f_2(p^*, q)\)</li>
</ul>
<p>を満たすこと. また \(v = (f_1(p^*, q^*), f_2(p^*, q^*))\) を <strong>均衡利得</strong> という.</p>
<h3>最適反応</h3>
<p>今考えるゲームは相手の手を知らずに自分の手を決めているが、仮に、相手の戦略を知ってから自分の最適な戦略を考えるとする.</p>
<p>プレイヤー \(1\) の <strong>最適反応</strong> とはプレイヤー \(2\) が用いる混合戦略 \(q\) に対する最適戦略の集合のことで \(R_1(q)\) と書く. 同様にプレイヤー \(2\) の最適反応はプレイヤー \(1\) の混合戦略 \(p\) に対して \(R_2(p)\) と書く.</p>
<p>具体的な定義は大体分かるでしょうけど</p>
<ul>
  <li>\(R_1(q) = \{ p : f_1(p, q) = \max_p f_1(p, q) \}\)</li>
  <li>\(R_2(p) = \{ q : f_2(p, q) = \max_q f_2(p, q) \}\)</li>
</ul>
<p>明らかにナッシュ均衡 \((p^*, q^*)\) について</p>
<ul>
  <li>\(p^* \in R_1(q^*)\)</li>
  <li>\(q^* \in R_2(p^*)\)</li>
</ul>
<p>ということ.</p>
<h4>定理</h4>
<p>\((p^*, q^*)\) がナッシュ均衡であることと、 写像 \(T(p, q) = (R_1(q), R_2(p))\) の不動点であることは同値.</p>
<p>最適反応の定義から明らか.</p>
<p>また次のように言い換えることも出来る.</p>
<h4>定理</h4>
<p>ナッシュ均衡の集合 \(D=\{(p^*, q^*)\}\) 及び最適反応の集合</p>
<ul>
  <li>\(D_1 = \{(p, q) : p \in R_1(q), q \in \mathcal{Q}\}\)</li>
  <li>\(D_2 = \{(p, q) : q \in R_2(p), p \in \mathcal{P}\}\)</li>
</ul>
<p>を用いて</p>
\[D = D_1 \cap D_2\]
<p>が言える.</p>
<p>ここらへんの定理を用いて、頑張ってナッシュ均衡が求められる.</p>
<p>行列ゲームのときと同様の言い方も出来る.</p>
<h4>補題 (双行列ゲームの鞍点定理)</h4>
<p>双行列ゲームについて \((p^*, q^*)\) がナッシュ均衡であることは次の同値.</p>
<p>任意の \(p, q\) に対して</p>
\[f_1(p^*, q^*) \geq f_1(p, q^*)\]
\[f_2(p^*, q^*) \geq f_2(p^*, q)\]
<p>\(B=-A\) を代入して以前の鞍点定理が出てくる.</p>
<h4>定理</h4>
<p>前回も混合戦略と純粋戦略を比較すればよかったように、今回もそれが成り立つ.</p>
<p>双行列ゲーム \((A, B)\) について \((p^*, q^*)\) がナッシュ均衡であることは次の同値.</p>
<p>任意の \(p, q\) に対して</p>
\[\forall i .~ f_1(p^*, q^*) \geq f_1(i, q^*)\]
\[\forall j .~ f_2(p^*, q^*) \geq f_2(p^*, j)\]
<h4>定理</h4>
<p>双行列ゲームは均衡点を1つ以上持つ.</p>
<p>もちろんゼロ和ゲームは双行列ゲームの特別な場合だから、これが成り立つなら先ほどのミニマックス定理が示されたことに成る.</p>
<h4>証明</h4>
<p>証明は2つ前の不動点で均衡点を表現する定理を使う. なんか Brower の不動点定理ってのと組み合わせると出来るらしいけどわからん.</p>
<h2>参考文献リスト</h2>
<p>[^1] : <a href="https://ja.wikipedia.org/wiki/%E5%9B%9A%E4%BA%BA%E3%81%AE%E3%82%B8%E3%83%AC%E3%83%B3%E3%83%9E">囚人のジレンマ - Wikipedia</a></p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>