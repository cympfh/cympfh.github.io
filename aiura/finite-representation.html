<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>有限群の表現</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">有限群の表現</h1>
<p><p class=date style='text-align: right'>2016-12-27 (Tue.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#線形代数>線形代数</a> </div> % 表現論です</p>
<h2>INDEX</h2>
<p><div id=toc></div></p>
<h2>群</h2>
<p>集合 \(G\) が群であるとは積 \(G \times G \to G\) が定められたもの. 積には次の3つのルールの成立を仮定する.</p>
<ol>
  <li>
    結合則
    <ul>
      <li>\((gh)i = g(hi) = ghi\)</li>
    </ul>
  </li>
  <li>
    単位元 \(e\) の存在
    <ul>
      <li>\(eg = ge = g\)</li>
    </ul>
  </li>
  <li>
    逆元の存在
    <ul>
      <li>\(\forall g. \exists g^{-1}. g g^{-1} = g^{-1} g = e\)</li>
    </ul>
  </li>
</ol>
<h3>命題.</h3>
<p>\(G\) が群であることと、</p>
\[\forall g, h \in G. ~ g h^{-1} \in G\]
<p>とは同値.</p>
<h3>対称群</h3>
<p>集合 \(I_n = \{1,2,\ldots,n\}\) について、 \(I_n \to I_n\) の全単射は ( \(n\) 次の) 置換と呼ばれる. 置換全体を \(n\) 次の <strong>対称群</strong> \(S_n\) と呼ぶ. その名の通り、これは群を成す. 積は関数合成. 単位元は恒等関数.</p>
<p>置換 \(\sigma\) を</p>
\[\left(\begin{array}\\
1 &amp; 2 &amp; \cdots &amp; n\\
\sigma(1) &amp; \sigma(2) &amp; \cdots &amp; \sigma(n)
\end{array}\right)\]
<p>と書く.</p>
<h3>巡回置換 (cycle)</h3>
<p>\(n\) 次の置換 \(\sigma\) について、 \(\sigma\) は</p>
\[J(k, \sigma) = \{k, \sigma(k), \sigma^2(k), \ldots, \sigma^{n-1}(k) \}\]
<p>を巡回するように置換し、他の値を置換しないとき、</p>
<p>つまり、</p>
<ul>
  <li>\(\sigma^0(k) = k\)</li>
  <li>\(\sigma^m(k) \ne k\) \((1 \leq m \leq n - 1)\)</li>
  <li>\(\sigma^n(k) = k\)</li>
</ul>
<p>で、</p>
<ul>
  <li>\(\sigma(j) = j\) when \(j \in I_n \setminus J(k, \sigma)\)</li>
</ul>
<p>というとき、 置換 \(\sigma\) を</p>
\[\left(\begin{array}\\
k &amp; \sigma(k) &amp; \sigma^2(k) &amp; \cdots &amp; \sigma^{n-1}(k)
\end{array}\right)\]
<p>と書いて、 <strong>巡回置換</strong> と呼ぶ. \(n\) を \(\sigma\) と長さと言う.</p>
<h3>生成される群</h3>
<p>ある条件 \(\text{cond}\) の下で ( \(e\) とも) 相異なるいくつかの元 \(a,b,\ldots\) に対して</p>
\[\{
e, a, b, \ldots,
a^2, ab, ba, b^2, \ldots,
a^3, a^2b, aba, ab^2, ba^2, bab, b^2a, b^3, \ldots
\}\]
<p>を、 \(a,b,\ldots\) が <strong>生成</strong> する群だといい、略記して</p>
\[\langle a,b,\ldots | \text{cond} \rangle\]
<p>と書く.</p>
<h4>例. 巡回群 \(C_n\)</h4>
<p>ある元 \(g\) について、ある自然数 \(n\) があって</p>
<ul>
  <li>\(g^0 = e\)</li>
  <li>\(g^m \ne e\) \((1 \leq m \leq n-1)\)</li>
  <li>\(g^n = e\)</li>
</ul>
<p>のとき、</p>
\[\langle g \rangle = \{e, g, g^2, \ldots, g^{n-1}\}\]
<p>であるが、これを <strong>巡回群</strong> という. 位数 (集合のサイズ) は \(n\) であり、 \(C_n\) と書く.</p>
<h3>Abel群</h3>
<p>積の交換則</p>
\[ab = ba\]
<p>が成立する群をAbel群という.</p>
<h4>例. <a href="https://ja.wikipedia.org/wiki/クラインの四元群">Klein の四元群</a></h4>
<p>とは、次の群のこと.</p>
\[V_4 = \langle a,b | a^2=e, b^2=e, ab=ba, a\ne b \rangle\]
<p>明らかにこれはAbel群である.</p>
<h2>群の作用</h2>
<p>特に置換に見られるように、群の成分には一つの操作を対応させることがしばしばある. 群の要素を手続きとみなした場合の関数適用を、「群の (左) 作用」という.</p>
<p>群 \(G\) を集合 \(S\) へ作用させる手続きを</p>
\[\rho: G \times S \to S\]
<p>と書く. 関数適用を</p>
\[\rho(g, s) = g \circ s = g(s)\]
<p>などと書く.</p>
<p>ただし群の作用には次の2つのルールを仮定する.</p>
<ol>
  <li>
    単位元の作用は恒等写像
    <ul>
      <li>\(\rho(e, s) = s\)</li>
    </ul>
  </li>
  <li>
    積の作用は関数合成
    <ul>
      <li>\(\rho(g, \rho(h, s)) = \rho(g \circ h, s)\)</li>
    </ul>
  </li>
</ol>
<h2>準同型写像</h2>
<p>群 \(G\) から別な群 \(G&#x27;\) への写像 \(f: G \to G&#x27;\) であって、</p>
\[f(gh) = f(g) f(h)\]
<p>を満たすものをそう呼ぶ.</p>
<h2>群の表現</h2>
<p>体 \(V\) の上の正則正方行列全体を \(GL(V)\) と書く. 多くの場合、 \(GL(V)\) とは、サイズが \(n \times n\) で、成分が複素数な正則正方行列全体 \(GL(n:\mathbb{C})\) のことだと思って構わない. 群 \(G\) に対して、</p>
\[\rho: G \to GL(V)\]
<p>なる写像を、群 \(G\) の <strong>表現</strong> という. 場合に依っては単に行き先 \(GL(V)\) のその \(V\) を \(G\) の表現と言ったりもする. 行き先の行列のサイズ \(n\) を、この表現の次元という.</p>
<h3>例. \(C_2\) の表現</h3>
<p>位数 2 の巡回群とは \(C_2=\{e,g\} (g^2=0)\) であるが、これの表現を具体的に与えてみる.</p>
<p>まず一次元表現の場合. 表現という写像の値域は \(GL(1:\mathbb{C})\) . これはゼロ以外の複素数のこと. すなわち \(\mathbb{C}^\times = \mathbb{C} \setminus \{0\}\) . 定義域は \(C_2\) であるので、 \(\rho(e)\) および \(\rho(g)\) を実際に与えれば表現を与えたことになる. 満たすべき性質はそれが準同型写像であることだけなので、</p>
<ul>
  <li>\((\rho(e))^m = \rho(e)\) ( \(m\) は任意の自然数)</li>
  <li>\((\rho(g))^2 = \rho(e)\) ( \(g^2 = e\) より)</li>
</ul>
<p>これらから</p>
<ul>
  <li>\(\rho(e)=1\)</li>
  <li>\(\rho(g) = \pm 1\) .</li>
</ul>
<p>従って二通りの表現が得られることが分かった.</p>
<p>一般に、任意の元を全て \(\rho(e)\) (それは 1 ライクな値) に写すものは表現の一つになっていて、これを自明な表現 \(\mathbb{1}\) と書くことにする. 対して \(+1\) と \(-1\) が交互に並ぶ感じのを \(\mathbb{sgn}\) と書く.</p>
<p>今の場合、 \(C_2\) の一次元表現として \(\mathbb{1}\) と \(\mathbb{sgn}\) との2つが得られた.</p>
<p>次に二次元表現の場合. 値域は、普通に、行列式がゼロではない、複素 \(2 \times 2\) 行列. 先と同様の考察から、</p>
<ul>
  <li>\(\rho(e) = I\) (単位行列)</li>
  <li>\(\rho(g) = I, -I, \ldots\) (色々沢山)</li>
</ul>
<p>自乗して \(I\) になるような行列は色々ある.</p>
<p>どの表現になるかはこれ以上からは一意には定まらない. 次の例に話を続ける.</p>
<h3>例. 対称式の表現</h3>
<p>2変数 \(x,y\) の一次式全体という集合 \(V\) を考える:</p>
\[V = \{ax+by : a,b \in \mathbb{C}\}.\]
<p>この要素について、 \(x, y\) を入れ替えるという操作 \(g\) を含む群を</p>
\[G = \{e,g\}\]
<p>とする. 操作の意味から \(g^2=e\) は自明. 従ってこの群自体は \(C_2\) である.</p>
<p>さて、 \(V\) の要素 \(ax+by\) は、 \(x, y\) を基底にとって</p>
\[\left(\begin{array}\\a\\b\end{array}\right)\]
<p>と書ける. この時 \(g\) の作用を</p>
\[g \circ \left(\begin{array}\\a\\b\end{array}\right)
=
\left(\begin{array}\\b\\a\end{array}\right)\]
<p>と書ける. ここで \(g\) をその表現で置き換えると</p>
\[\rho(g) \circ \left(\begin{array}\\a\\b\end{array}\right)
=
\left(\begin{array}\\b\\a\end{array}\right)\]
<p>となるが、ちょうどここに二次元表現が来ると、行列の演算であるように見える. だとすると、 \(\rho(g)\) としてふさわしい行列は、一意に定まって</p>
\[\left(\begin{array}\\
0 &amp; 1\\1 &amp; 0
\end{array}\right)
\left(\begin{array}\\a\\b\end{array}\right)
= \left(\begin{array}\\b\\a\end{array}\right)\]
<p>とすべきだろう. \(\rho(g) = \left(\begin{array}\\
0 &amp; 1\\1 &amp; 0
\end{array}\right)\) としたわけであるが、これはちゃんと自乗したら \(I\) になる行列.</p>
<p>ところで基底のとり方を \(x, y\) としたが、別にそうする理由はない. 例えば \(x+y, x-y\) という基底のとり方もあり得る. この場合</p>
\[g \circ \left(\begin{array}\\c\\d\end{array}\right)
=
\left(\begin{array}\\c\\-d\end{array}\right)\]
<p>とすればいいだけなので、</p>
\[\rho(g) = \left(\begin{array}\\
1&amp;0\\0&amp;-1
\end{array}\right)\]
<p>という表現がふさわしく見える.</p>
<p>以上の例は、準同型の制約からは表現は一意に定まらないが、それらは所詮、基底のとり方で変わるだけだという主張を支えるものである.</p>
<h2>定義. 部分表現</h2>
<p>表現 \(\rho: G \to GL(V)\) の部分表現 \(W\) とは、 \(W \subseteq V\) であって、 \(w \in W\) への (左) 作用を考えた時に</p>
\[\forall g.~ \forall w.~ g \circ w \in W\]
<p>が成立するもの. 自明な部分表現として \(V\) 自身と \(\emptyset\) .</p>
<h2>定義. 既約表現</h2>
<p>\(V\) の部分表現として \(V\) 自身と \(\emptyset\) 以外の表現を持たないような \(V\) を <strong>既約表現</strong> という.</p>
<h2>定理. 表現の分解</h2>
<p>有限群 \(G\) とその表現 \(V\) について、 \(V\) は有限個の既約表現の直和に分解できる:</p>
\[V = V_1 \oplus V_2 \oplus \cdots \oplus V_k\]
<p>ここで、表現の直和とはデカルト積.</p>
<h3>例. 対称式</h3>
<p>例えば \(V=\{ax+by\}\) は \(V_1=\{a(x+y)\}\) と \(V_2=\{b(x-y)\}\) とに分解できる. すなわち、</p>
\[
\left(\begin{array}\\
1 &amp; 0 \\ 0 &amp; -1
\end{array}\right)
\left(\begin{array}\\
a\\b
\end{array}\right)
=
\left(\begin{array}\\
1
\end{array}\right)
\left(\begin{array}\\
a
\end{array}\right)
\oplus
\left(\begin{array}\\
-1
\end{array}\right)
\left(\begin{array}\\
b
\end{array}\right)
\]
<p>と言っている.</p>
<h2>定義. 表現の間の射</h2>
<p>群 \(G\) の2つの表現 \(V\) と \(W\) の間の <strong>射</strong> \(f: V \to W\) とは、線形写像であって、また群の作用について準同型なもののこと.</p>
<p>すなわち、 \(g \in G\) , \(v \in V\) について</p>
\[f(g \circ v) = g \circ f(v)\]
<p>すなわち、</p>
<p><center></p>
<pre><code class="code language-dot">digraph {
  bgcolor=transparent;
  node [shape=plaintext width=1.4 height=0.4 fixedsize=true];
  edge [arrowhead=vee];
  v -&gt; fv [label=f];
  v -&gt; gv;
  fv -&gt; X;
  gv -&gt; X [label=f];
  fv [label=&quot;f(v)&quot;];
  gv [label=&quot;g・v&quot;];
  X [label=&quot;f(g・v) = g・f(v)&quot;]
  rankdir=TB;
  {rank=same v fv};
  {rank=same gv X};
}
</code></pre>
<p></center></p>
<p>\(V \to W\) なる射全体を \(\text{Hom}(V, W)\) と書く.</p>
<h3>例. \(C_2\) の一次元表現</h3>
<p>には先程示したように \(\mathbb{1}\) と \(\mathbb{sgn}\) とがある.</p>
<ul>
  <li>\(\mathbb{1}(e) = 1\)</li>
  <li>\(\mathbb{1}(g) = 1\)</li>
  <li>\(\mathbb{sgn}(e) = 1\)</li>
  <li>\(\mathbb{sgn}(g) = -1\)</li>
</ul>
<p>\(\mathbb{1} \to \mathbb{sgn}\) にどんな射があるだろうか.</p>
<p>射 \(f\) は線形関数でないといけないとした. 一次元の上の線形関数はスカラー倍する関数 \(f(x) = ax\) しかない. 準同型であるべきという制約から</p>
<ul>
  <li>\(f(g \circ v) = a(\mathbb{1}(g) v) = av\)</li>
  <li>\(g \circ f(v) = \mathbb{sgn}(g) (av) = -av\)</li>
</ul>
<p>これらが \(v \in V\) で等しくある必要があるので、結局 \(a=0\) . 即ち、</p>
\[f(x) = 0\]
<p>なる射だけがあり得る.</p>
<h3>例. 対称式の二次元表現</h3>
<p>\(V=\{ax+by\}\) の \(x\) と \(y\) を入れ替える操作 \(g\) の表現. 先ほど見たように \(x+y, x-y\) を基底に取ると、</p>
\[\rho(g) = \left(\begin{array}\\1 &amp; \\ &amp; -1 \end{array}\right).\]
<p>これを参考にして、 \(V \to V\) の射を調べる. 二次元表現の線形関数なので、 \(2 \times 2\) 行列 \(A\) だと思えばいい.</p>
<ul>
  <li>\(A \rho(g) v = \rho(g) A v\)</li>
  <li>\(\Rightarrow A \left(\begin{array}\\1 &amp; \\ &amp; -1 \end{array}\right) = \left(\begin{array}\\1 &amp; \\ &amp; -1 \end{array}\right) A\)</li>
  <li>\(\Rightarrow A = \left(\begin{array}\\a &amp; \\ &amp; d\end{array}\right)\)</li>
</ul>
<p>従って \(\text{Hom}(V, V) \simeq \mathbb{C}^2\) であることが分かる.</p>
<h2>定義. 表現の同型</h2>
<p>2つの表現 \(V, W\) が同型 \(V \simeq W\) であることを、次のように定める. 2つの表現の間の射</p>
<ul>
  <li>\(f: V \to W\)</li>
  <li>\(g: W \to V\)</li>
</ul>
<p>があって、 \(g \circ f = id_V\) , \(f \circ g = id_W\) が成り立つこと.</p>
<h2>Schur (シューア) の補題</h2>
<p>\(G\) の2つの <strong>既約</strong> 表現 \(V, W\) について次が成立する.</p>
\[\text{Hom}(V,W) \simeq \begin{cases}
\mathbb{C} &amp; \text{ when } V \simeq W \\
0 &amp; \text{ otherwise }
\end{cases}\]
<h3>例. 対称式の二次元表現</h3>
<p>明らかに \(V \simeq V\) であるが先ほど見たように \(\text{Hom}(V, V) \simeq \mathbb{C}^2\) であった. これから \(V\) が規約ではないことが分かる.</p>
<h2>定理. Abel群の既約表現は一次元</h2>
<p>簡単な証明を与える.</p>
<p>Abel 群 \(G\) の表現 \(\rho: G \to GL(V)\) を考える. \(G\) の可換性と \(\rho\) の準同型性から、</p>
\[\rho(g) \rho(h) = \rho(gh) = \rho(hg) = \rho(h) \rho(g)\]
<p>\(\{ \rho(g) : g \in G \}\) もまた可換群であることが分かる.</p>
<p>ところで、</p>
\[\rho(g) \rho(h) = \rho(h) \rho(g)\]
<p>は \(h\) という左作用をかける操作自体が \(V \to V\) の射になっていることを言っている.</p>
\[
\begin{array}\\
v          &amp; \rightarrow^h &amp; \rho(h, v) \\
\downarrow &amp;               &amp; \downarrow \\
\rho(g, v)  &amp; \rightarrow^h &amp; \rho(g) \rho(h, v)
\end{array}
\]
<p>Schur の補題から \(\rho(h) \ni \text{Hom}(V,V) \simeq \mathbb{C}\) . スカラー倍するという関数だけで ？？？</p>
<p>メモ不明</p>
<h3>\(C_n\) の既約表現の数</h3>
<p>\(C_n\) はAbel群なので、一次元表現、すなわち \(\rho: C_n \to C^\times\) だけを考えればよい.</p>
<p>\(\rho(e) = 1\) は自明. \(\rho(g)\) を決めた場合、 \(\rho(g^2), \rho(g^3), \ldots\) は自動的に定まるので、 結局 \(\rho(g)\) の値を定めることが、 \(\rho\) を定めることになる.</p>
<p>満たすべき性質は、 \(g^n = e\) なので、</p>
\[\rho(g)^n = 1\]
<p>\(1\) の \(n\) 乗根は一般に \(n\) 個ある:</p>
\[\rho(g) = 1, \omega, \omega^2, \ldots, \omega^{n-1}\]
<p>ここで \(\omega = \exp(2 \pi i &#x2F; n)\) .</p>
<p>従って、 \(C_n\) の既約表現は \(n\) 通りあり得る.</p>
<h3>Abel群の規約表現の数</h3>
<p>実はAbel群 \(G\) の規約表現は、その位数 \(\#G\) と同じ数だけ存在する. そしてその表現の間の積を</p>
\[(\rho_1 \times \rho_2)(g) = \rho_1(g) \times \rho_2(g)\]
<p>と定めることで、表現全体という集合も群になる.</p>
<h2>商群</h2>
<p>群 \(G\) とその部分群 \(H\) があるとき、 \(H\) の下で \(G\) の同値関係を</p>
\[g_1 \sim g_2 \iff g_1 g_2^{-1} \in H\]
<p>と定義する. \(G\) を \(H\) で割った商群を</p>
\[G&#x2F;H = G&#x2F;\sim = \{ [g] : g \in G \}\]
<p>と定める.</p>
<p>\(g_1 g_2^{-1} \in H \iff g_1 g_2^{-1} = h \iff g_1 = h g_2\) から、逆に、 \(g_2\) から同値クラスは \([g_2] = H g_2 (= \{ h g_2 : h \in H \})\) などと書ける. そういうわけで、</p>
\[G&#x2F;H = \{ Hg : g \in G\}\]
<p>というふうに書いたりもする.</p>
<p>\(G&#x2F;H\) は \(G\) という集合の分割をしていると見ることもできる. すなわち、</p>
\[G = \bigcup Hg = He \cup H g_1 \cup \cdots \cup H g_m\]
\[G&#x2F;H = \bigoplus Hg = He \oplus H g_1 \oplus \cdots \oplus H g_m\]
<p>ここで \(m\) は代表元の数. そして明らかに \(\#Hg = \#H\) . というわけで、位数に関して</p>
\[\#G = m~\#H\]
<p>これは次の定理を導く.</p>
<h3>ラグランジュの定理</h3>
<p>群 \(G\) の部分群 \(H\) の位数は \(\#G\) の約数</p>
<h3>系.</h3>
<p>群の左作用</p>
\[G \times S \to S\]
\[(g, s) \mapsto g \circ s\]
<p>について.</p>
<p>次を \(s\) の \(G\) 軌道という.</p>
\[G s = \text{Orb}(s) = \{ g \circ s : g \in G \}\]
<p>そして次を不動点という.</p>
\[\text{Fix}(s) = \{ g : g \circ s = s \}\]
<p>\(\text{Fix}(s)\) は \(G\) の部分群です. なぜなら、 これが \(G\) の部分集合なのは自明で、 また、 \(\forall g,h \in \text{Fix}(s)\) について、 \((g h^{-1})(s) = g(h^{-1} \circ s) = g \circ s = s\) から \(g h^{-1} \in \text{Fix}(s)\) が成立するので群.</p>
<blockquote><em>N.B.</em> \(G\) が群であることと \(\forall g, h \in G. ~ g h^{-1} \in G\) は同値であった</blockquote>
<p>ラグランジュの定理で \(H=\text{Fix}(s)\) と思うと、</p>
\[G = \text{Fix}(s) g_1 \cup \text{Fix}(s) g_2 \cup \cdots \cup \text{Fix}(s) g_k\]
<p>ここで \(g_1, g_2, \ldots, g_k\) は \(G&#x2F;\text{Fix}(s)\) の異なる代表元のつもり. その個数 \(k\) は実は \(\#G s\) と一致する.</p>
<p>なぜなら、上の式で右から \(s\) を掛けると、</p>
<ul>
  <li>
    \(G s = \text{Fix}(s) \circ g_1(s) \cup \text{Fix}(s) \circ g_2(s) \cup \cdots \cup \text{Fix}(s) \circ g_k(s)\)
    <ul>
      <li>\(= g_1(s) \oplus \cdots \oplus g_k(s)\)</li>
      <li>なぜなら \(\text{Fix}(s) \circ g(s) = \{ h(g(s)) : h \in \text{Fix}(s) \} = \{ g(s) \}\)</li>
    </ul>
  </li>
</ul>
<p>従って \(\#Gs = k\) .</p>
<p>以上から、</p>
\[\#G = \#\text{Fix}(s) \times \#Gs\]
<h2>共役類</h2>
<p>群 \(G\) について \(h \in G\) の共役類とは、</p>
\[c(h) = \{ h g h^{-1} : g \in G \}\]
<p>のこと.</p>
<h3>群作用としての共役類</h3>
<p>これも \(G (\ni g)\) の \(G (\ni h)\) への (左) 作用と見ることができる. すなわち、</p>
\[G \times G \to G\]
\[(g, h) \mapsto hgh^{-1}\]
<p>とすると、 \(c(h)\) は \(h\) の \(G\) 軌道. 不動点は</p>
\[Z_G(h) = \text{Fix}(h) = \{ g : hgh^{-1} = h \}\]
<p>したがって、</p>
\[\#G = \#c(h) \times \#Z_G(h)\]
<h3>同値関係としての共役類</h3>
<p>共役類は同値関係を与える. すなわち、</p>
\[g \sim h \iff \exists i. h = i g i^{-1} \iff g \in c(h)\]
<h2>定理. 既約表現の個数について</h2>
<p>\(G\) の規約表現全体を \(\hat{G}\) とする.</p>
<p>次の2つの定理がある:</p>
\[\#G = \sum_{V \in \hat{G}} (\text{dim} V)^2\]
\[\# G \text{ の共役類} = \# \hat{G}\]
<p>これらの定理を用いて、規約表現を頑張れば網羅して列挙できる.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>