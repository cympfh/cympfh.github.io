<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-send-o" style="position:absolute; left:0.4em; top:0.4em; width:1.3em;border-radius:0.8em;"></i></a>
</header>
<header>
<h1 class="title">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</h1>
</header>
<ul>
<li>
original paper: <a href=https://maartenfokkinga.github.io/utwente/mmf91m.pdf>https://maartenfokkinga.github.io/utwente/mmf91m.pdf</a>
</li>
</ul>
<div class="is-pulled-right">
<p><a class='tag is-blue' href=index.html#計算>計算</a> <a class='tag is-blue' href=index.html#圏論>圏論</a></p>
</div>
<p><span class="math inline">\(\require{AMScd}\)</span> <span class="math inline">\(\def\banana#1{(\!|#1|\!)}\)</span> <span class="math inline">\(\def\lense#1{[\!(#1)\!]}\)</span> <span class="math inline">\(\def\envelop#1{[\![ #1 ]\!]}\)</span> <span class="math inline">\(\def\wire#1{[\!\!\langle #1 \rangle\!\!]}\)</span> <span class="math inline">\(\DeclareMathOperator{\cons}{cons}\)</span> <span class="math inline">\(\DeclareMathOperator{\foldr}{foldr}\)</span> <span class="math inline">\(\def\Nil{\mathit{Nil}}\)</span> <span class="math inline">\(\def\Bool{\mathit{Bool}}\)</span> <span class="math inline">\(\def\true{\mathit{true}}\)</span> <span class="math inline">\(\def\false{\mathit{false}}\)</span> <span class="math inline">\(\def\const#1{#1^\bullet}\)</span> <span class="math inline">\(\def\VOID{\mathit{VOID}}\)</span> <span class="math inline">\(\def\join{\mathit{join}}\)</span> <span class="math inline">\(\def\triangle{\mathop{}\!\mathbin\Delta\;}\)</span></p>
<h2 id="概要">概要</h2>
<p>一般の再帰的データ構造について, ちょうど, リストに対する畳み込み (fold) といったような4種類の操作 (catamorphism, anamorphism, hylomorphism, paramorphism) を統一的に与える.</p>
<h2 id="表記">表記</h2>
<p>この論文では独特な括弧が4種類導入されている. できるだけオリジナルの見た目を模倣して, ここでは次のように表記する.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">名称</th>
<th style="text-align: center;">表記</th>
<th style="text-align: center;">代替表記</th>
<th style="text-align: left;">備考</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">バナナ括弧</td>
<td style="text-align: center;"><span class="math inline">\(\banana{\_}\)</span></td>
<td style="text-align: center;"><code>(| |)</code></td>
<td style="text-align: left;">果物のバナナ</td>
</tr>
<tr class="even">
<td style="text-align: left;">レンズ括弧</td>
<td style="text-align: center;"><span class="math inline">\(\lense{\_}\)</span></td>
<td style="text-align: center;"><code>[( )]</code></td>
<td style="text-align: left;">凹レンズ</td>
</tr>
<tr class="odd">
<td style="text-align: left;">封筒括弧</td>
<td style="text-align: center;"><span class="math inline">\(\envelop{\_}\)</span></td>
<td style="text-align: center;"><code>[[ ]]</code></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">有刺鉄線</td>
<td style="text-align: center;"><span class="math inline">\(\wire{\_}\)</span></td>
<td style="text-align: center;"><code>[&lt; &gt;]</code></td>
<td style="text-align: left;"><span class="math inline">\([\)</span> と <span class="math inline">\(\langle\)</span> の重ねあわせ</td>
</tr>
</tbody>
</table>
<p>他にこの論文で使われてる表記で次のものをこの文書でも用いる.</p>
<ul>
<li><span class="math inline">\(\const{c}\)</span>
<ul>
<li>型 <span class="math inline">\(C\)</span> の値 <span class="math inline">\(c\)</span> (或いは <span class="math inline">\(c \in C\)</span>) と任意の型 (集合) <span class="math inline">\(A\)</span> について, <span class="math inline">\(A \to C\)</span> なる定数関数のこと</li>
<li><span class="math inline">\(\forall a \in A, \const{c}(a)=c\)</span></li>
</ul></li>
</ul>
<p>また対象 (型, 集合) に関する表記であまり一般的に思えないものについては次のように一般的表記を用いる.</p>
<ul>
<li><span class="math inline">\(A \times B\)</span>
<ul>
<li>対象 <span class="math inline">\(A, B\)</span> の積</li>
<li>タプル型, 集合の直積</li>
</ul></li>
<li><span class="math inline">\(A + B\)</span>
<ul>
<li>対象 <span class="math inline">\(A, B\)</span> の直和</li>
<li>直和型, 集合の直和</li>
</ul></li>
<li><span class="math inline">\(f \colon A \to B\)</span>
<ul>
<li><span class="math inline">\(f\)</span> は <span class="math inline">\(A\)</span> から <span class="math inline">\(B\)</span> への射</li>
<li>あるいは関数, 演算</li>
</ul></li>
<li><span class="math inline">\([A]\)</span>
<ul>
<li>型 <span class="math inline">\(A\)</span> の要素に持つリストの型</li>
</ul></li>
</ul>
<h2 id="リストの場合">リストの場合</h2>
<p><span class="math inline">\([A]\)</span> 型の場合を考える.</p>
<h3 id="catamorphism">catamorphism</h3>
<p>&quot;cata-&quot; は catastrophic のそれであって, 下方へ, といった意味らしい. リストについての catamorphism は如何のような関数 <span class="math inline">\(h\)</span> である.</p>
<ul>
<li><span class="math inline">\(h \colon [A] \to B\)</span></li>
<li><span class="math inline">\(h~[] = b\)</span></li>
<li><span class="math inline">\(h~(\cons(a, as)) = a \oplus h(as)\)</span></li>
</ul>
<p>ここで <span class="math inline">\(b\)</span> は <span class="math inline">\(B\)</span> の定数. <span class="math inline">\(\oplus\)</span> は <span class="math inline">\(A \times B \to B\)</span> なる二項演算子. このような形の <span class="math inline">\(h\)</span> は Haskell のような言語では <code>foldr</code> として知られており <span class="math display">\[h = \foldr(b, \oplus)\]</span> のように書ける. すなわち <span class="math inline">\(h\)</span> という関数は <span class="math inline">\(b, \oplus\)</span> によって決定するから, ここでは <strong>バナナ括弧</strong> で括ることで <span class="math display">\[h = \banana{b, \oplus}\]</span> と書くことにする.</p>
<p>例えばリストの長さを取る関数は <span class="math inline">\(\banana{0, (\_,n)\mapsto n+1}\)</span> と書けることが分かる. 他に <code>filter</code> もこの形で定義できる.</p>
<h3 id="anamorphism">anamorphism</h3>
<p>ちょうど catamorphism の逆のもので, <code>unfold</code> のような名前で知られている関数 <span class="math inline">\(h\)</span> を次のように定義する.</p>
<ul>
<li><span class="math inline">\(h \colon B \to [A]\)</span></li>
<li><span class="math inline">\(h~b = \begin{cases} [] &amp; \text{ when } p~b \\ \cons(a, h~b&#39;) &amp; \text { otherwise, where } (a,b&#39;)=g~b\end{cases}\)</span></li>
</ul>
<p>ただしここで <span class="math inline">\(p\)</span> は <span class="math inline">\(B \to \Bool\)</span> なる述語関数 (<span class="math inline">\(\Bool\)</span> は普通の意味で). <span class="math inline">\(g\)</span> は <span class="math inline">\(B \to A \times B\)</span> なる関数.</p>
<p>やはりこの <span class="math inline">\(h\)</span> は <span class="math inline">\(p, g\)</span> で決まる関数なので, 今度はレンズ括弧で括って <span class="math display">\[h = \lense{g, p}\]</span> と書いて表す.</p>
<p>例えば, 関数 <span class="math inline">\(f \colon A \to A\)</span> を繰り返し適用する <code>iterate f</code> という関数 <span class="math inline">\(A \to [A]\)</span> は <span class="math inline">\(\lense{a \mapsto (a, f~a), \const{\mathrm{false}}}\)</span> と書ける.</p>
<h4 id="map-関数">map 関数</h4>
<p>リスト <span class="math inline">\([A]\)</span> と関数 <span class="math inline">\(f \colon A \to B\)</span> があるときに, リストの各要素に <span class="math inline">\(f\)</span> を適用することで <span class="math inline">\([A] \to [B]\)</span> という関数を構成することができる. Haskell では <code>map f</code> とこれを書くが, 論文に倣って <span class="math inline">\(f*\)</span> と書くことにする. これは <span class="math inline">\([A]\)</span> からの catamorphism として書くこともできるし, <span class="math inline">\([B]\)</span> への anamorphism と書くこともできる.</p>
<ul>
<li><span class="math inline">\(f* = \banana{[], (a, b) \mapsto \cons(f~a, f*b)}\)</span></li>
<li><span class="math inline">\(f* = \lense{\cons(a, as) \mapsto (f~a, as), \mathrm{nil}}\)</span>
<ul>
<li>where
<ul>
<li><span class="math inline">\(\mathrm{nil}~[]=\mathrm{true}\)</span></li>
<li><span class="math inline">\(\mathrm{nil}~\cons(x, xs)=\mathrm{false}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="hylomorphism">hylomorphism</h3>
<p>リストに関する hylomorphism とは, 例えば木構造をリストにしてやるような「線形再帰関数」のもの. 具体的には <span class="math display">\[h : A \to C\]</span> <span class="math display">\[h~a = \begin{cases}c &amp; \text{ when } p~a\\ b \oplus h~a&#39; &amp; \text{ otherwise, where } (b,a&#39;) = g~a\end{cases}\]</span> と書き表されるもの. ここで <span class="math inline">\(c \colon C\)</span>, <span class="math inline">\(g \colon A \to B \times A\)</span>, <span class="math inline">\(\oplus \colon B \times C \to C\)</span> であって <span class="math inline">\(h \colon A \to C\)</span> である.</p>
<p>今度の <span class="math inline">\(h\)</span> は <span class="math inline">\(c,\oplus, g,p\)</span> によって決定されるので <span class="math display">\[h=\envelop{(c,\oplus), (g,p)}\]</span> と書き表すことにする.</p>
<p>そしてこれは明らかに <span class="math display">\[\envelop{(c,\oplus), (g,p)} = \banana{c,\oplus} \circ \lense{g,p}\]</span> という合成の形に分解できる. この証明は論文にはあるが省略. リストが一見登場しないが, この合成の形を見れば, 中間でリストを経由してることが分かる.</p>
<p>例えば自然数の階乗を計算する関数 <span class="math inline">\(\mathbb N \to \mathbb N\)</span> は <span class="math inline">\(\envelop{(1,\times), ((1+n) \mapsto (1+n, n), \mathrm{zero})}\)</span> と書ける. ここで <span class="math inline">\(\mathrm{zero}\)</span> は引数がゼロかを判定する述語とする. つまり <span class="math inline">\(\lense{g,\mathrm{zero}}(m)=[m,m-1,\ldots,1]\)</span> であって <span class="math inline">\(\banana{1,\times}\)</span> はそれを乗算しながら畳み込む関数である.</p>
<h3 id="paramorphism">paramorphism</h3>
<p>原始再帰のパターンを提供するのが paramorphism であって, リストに関する paramorphism は 次のように定義される.</p>
<ul>
<li><span class="math inline">\(h \colon [A] \to B\)</span></li>
<li><span class="math inline">\(h~[]=b\)</span></li>
<li><span class="math inline">\(h~\cons(a,as)= a \oplus (as, h~as)\)</span></li>
</ul>
<p>ここで <span class="math inline">\(b\colon B\)</span>, <span class="math inline">\(\oplus\colon A \times([A]\times B) \to B\)</span> である. このような <span class="math inline">\(h\)</span> はやはり <span class="math inline">\(b,\oplus\)</span> で決定されるので, <span class="math display">\[h=\wire{b, \oplus}\]</span> と書くことにする.</p>
<p><span class="math inline">\(\oplus\)</span> の型が豪華になったので, 値を蓄積しながらのような関数が書けるようになった. 例えば <code>tails</code> は <span class="math inline">\(\wire{\cons(\Nil,\Nil), (a\oplus(as,ac)=\cons(\cons(a,as),ac))}\)</span> と書ける.</p>
<h2 id="代数的データ型-algebraic-data-types">代数的データ型 (Algebraic data types)</h2>
<h3 id="双関手-bifunctor">双関手 (bifunctor)</h3>
<p>双関手とは2つの対象の組を対象に写して2つの射の組を射に写すようなもので, <span class="math inline">\(f\colon A\to B\)</span> と <span class="math inline">\(g\colon C\to D\)</span> を <span class="math inline">\(f \dagger g \colon A \dagger C \to B \dagger D\)</span> とするような <span class="math inline">\(\dagger\)</span> といったもの. ただし <span class="math inline">\(1\dagger 1=1\)</span>, <span class="math inline">\(f\dagger g \circ h \dagger j = fh \dagger gj\)</span> となるもの. 双関手の変数として <span class="math inline">\(\dagger, \ddagger\)</span> を用いる.</p>
<h3 id="積">積</h3>
<p>2つの対象 <span class="math inline">\(A,B\)</span> の積とは <span class="math inline">\(A \times B\)</span> なる対象. <span class="math inline">\(f \colon A \to B\)</span> と <span class="math inline">\(g \colon C \to D\)</span> との積として <span class="math inline">\(f \times g \colon A \times C \to B \times D\)</span> を定める. 射影関数 <span class="math inline">\(\pi_1 : A \times C \to A\)</span>, <span class="math inline">\(\pi_2 : B \times D \to A\)</span> を伴う.</p>
<p>関数的に書くと</p>
<ul>
<li><span class="math inline">\((f \times g)(x, x&#39;)=(fx gx&#39;)\)</span></li>
<li><span class="math inline">\(\pi_1(x,x&#39;)=x\)</span></li>
<li><span class="math inline">\(\pi_2(x,x&#39;)=x&#39;\)</span></li>
</ul>
<p>また二項演算子 <span class="math inline">\(\triangle\)</span> を</p>
<ul>
<li><span class="math inline">\((f \triangle g) x = (fx, gx)\)</span></li>
</ul>
<p>と定める. 例えば <span class="math inline">\(f \times g = (f\pi_1) \triangle (g\pi_2)\)</span> である. また簡単に <span class="math inline">\(\triangle\)</span> を単項コンビネータとして用いて <span class="math inline">\(\triangle x = (x,x)\)</span> とする. これを用いると <span class="math inline">\(f \triangle g = (f \times g) \triangle\)</span> と書ける.</p>
<h3 id="和">和</h3>
<p>対象 <span class="math inline">\(A\)</span> と <span class="math inline">\(B\)</span> の和を, <span class="math inline">\(A\)</span> と <span class="math inline">\(B\)</span> と加えて <span class="math inline">\(\{\bot\}\)</span> との直和として定める. <span class="math display">\[A+B = A \amalg B \amalg \{\bot\}\]</span> <span class="math inline">\(f\colon A \to B, g \colon C \to D\)</span> に対して <span class="math inline">\(f+g \colon A+C \to B+D\)</span> を定める. これは関数的に書くと, <span class="math inline">\(A\)</span> のものは <span class="math inline">\(f\)</span> によって <span class="math inline">\(B\)</span> に, <span class="math inline">\(C\)</span> のものは <span class="math inline">\(g\)</span> によって<span class="math inline">\(D\)</span> に, そして <span class="math inline">\(\bot\)</span> は <span class="math inline">\(\bot\)</span> に写すもの.</p>
<ul>
<li><span class="math inline">\((f+g) \colon A+C \to B+D\)</span></li>
<li><span class="math inline">\((f+g) a = f a\)</span></li>
<li><span class="math inline">\((f+g) c = g c\)</span></li>
<li><span class="math inline">\((f+g) \bot = \bot\)</span></li>
</ul>
<p>自明な埋め込み射 <span class="math inline">\(A \to A+B\)</span> と <span class="math inline">\(B \to A+B\)</span> が存在する.</p>
<ul>
<li><span class="math inline">\(i_1 : A \to A+B\)</span></li>
<li><span class="math inline">\(i_1 a = a\)</span></li>
<li><span class="math inline">\(i_2 : B \to A+B\)</span></li>
<li><span class="math inline">\(i_2 b = b\)</span></li>
</ul>
<p>積の時と同様に <span class="math inline">\(\triangledown\)</span> という射に関する二項演算子を導入する. これは選択的に射を適用するようなもので <span class="math inline">\(f\colon A \to B, g \colon C \to B\)</span> について</p>
<ul>
<li><span class="math inline">\((f \triangledown g) \colon A+C \to B\)</span></li>
<li><span class="math inline">\((f \triangledown g) a = fa\)</span></li>
<li><span class="math inline">\((f \triangledown g) c = gc\)</span></li>
</ul>
<p>のようなもの.</p>
<p>例えば <span class="math inline">\(f\colon A \to B, g \colon C \to D\)</span> について 後ろに <span class="math inline">\(i\)</span> を合成すれば <span class="math inline">\(f+g = i_1 f \triangledown i_2 g\)</span> と書ける. そしてやはり単項コンビネータとしても流用して,</p>
<ul>
<li><span class="math inline">\(\triangledown \bot=\bot\)</span></li>
<li><span class="math inline">\(\triangledown (a \in A+C) = (a \in A)\)</span></li>
<li><span class="math inline">\(\triangledown (c \in A+C) = (c \in C)\)</span></li>
</ul>
<p>のように使う.</p>
<h3 id="矢印">矢印</h3>
<p>二項演算子 <span class="math inline">\(\to\)</span> を定める. 対象 <span class="math inline">\(A,B\)</span> について <span class="math inline">\(A\to B\)</span> はまた対象で, <span class="math inline">\(A\)</span> から <span class="math inline">\(B\)</span> への射全体の集まりを表す. 2つの射 <span class="math inline">\(f \colon A \to C\)</span> と <span class="math inline">\(g \colon C&#39; \to B\)</span> について <span class="math display">\[(f \to g) \colon (C \to C&#39;) \to (A \to B)\]</span> <span class="math display">\[(f \to g) h = g \circ h \circ f\]</span> を定める.</p>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="351pt" height="44pt" viewBox="0.00 0.00 350.66 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>
%3
</title>
<!-- A -->
<g id="node1" class="node">
<title>
A
</title>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text> </g> <!-- C --> <g id="node2" class="node">
<title>
C
</title>
<text text-anchor="middle" x="121.6621" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">C</text> </g> <!-- A&#45;&gt;C --> <g id="edge1" class="edge">
<title>
A-&gt;C
</title>
<path fill="none" stroke="#000000" d="M54.1264,-18C63.5336,-18 74.2518,-18 84.3352,-18"/> <polygon fill="#000000" stroke="#000000" points="84.5318,-21.5001 94.5318,-18 84.5318,-14.5001 84.5318,-21.5001"/> <text text-anchor="middle" x="74.3311" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">f</text> </g> <!-- C&#39; --> <g id="node3" class="node">
<title>
C'
</title>
<text text-anchor="middle" x="218.6621" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">C'</text> </g> <!-- C&#45;&gt;C&#39; --> <g id="edge2" class="edge">
<title>
C-&gt;C'
</title>
<path fill="none" stroke="#000000" d="M148.682,-18C158.7925,-18 170.4638,-18 181.3415,-18"/> <polygon fill="#000000" stroke="#000000" points="181.4507,-21.5001 191.4507,-18 181.4506,-14.5001 181.4507,-21.5001"/> <text text-anchor="middle" x="170.1621" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">h</text> </g> <!-- B --> <g id="node4" class="node">
<title>
B
</title>
<text text-anchor="middle" x="315.6621" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text> </g> <!-- C&#39;&#45;&gt;B --> <g id="edge3" class="edge">
<title>
C'-&gt;B
</title>
<path fill="none" stroke="#000000" d="M245.682,-18C255.7925,-18 267.4638,-18 278.3415,-18"/> <polygon fill="#000000" stroke="#000000" points="278.4507,-21.5001 288.4507,-18 278.4506,-14.5001 278.4507,-21.5001"/> <text text-anchor="middle" x="267.1621" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">g</text> </g> </g>
</svg>
<p><span class="math inline">\((g \leftarrow f)\)</span> を <span class="math inline">\((f \to g)\)</span> と同じ意味で用いる.</p>
<p>関手 <span class="math inline">\(F\)</span> について <span class="math display">\[(f \xrightarrow{F} g) = g \circ Fh \circ f\]</span> で用いる.</p>
<p>また次の合成則がある. <span class="math display">\[(f \to g) \circ (h \to j) = (h \circ f) \to (g \circ j)\]</span></p>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="536pt" height="44pt" viewBox="0.00 0.00 535.55 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<title>
%3
</title>
<!-- A -->
<g id="node1" class="node">
<title>
A
</title>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text> </g> <!-- B --> <g id="node2" class="node">
<title>
B
</title>
<text text-anchor="middle" x="121.6621" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text> </g> <!-- A&#45;&gt;B --> <g id="edge1" class="edge">
<title>
A-&gt;B
</title>
<path fill="none" stroke="#000000" d="M54.1264,-18C63.5336,-18 74.2518,-18 84.3352,-18"/> <polygon fill="#000000" stroke="#000000" points="84.5318,-21.5001 94.5318,-18 84.5318,-14.5001 84.5318,-21.5001"/> <text text-anchor="middle" x="74.3311" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">f</text> </g> <!-- C --> <g id="node3" class="node">
<title>
C
</title>
<text text-anchor="middle" x="218.6621" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">C</text> </g> <!-- B&#45;&gt;C --> <g id="edge2" class="edge">
<title>
B-&gt;C
</title>
<path fill="none" stroke="#000000" d="M148.682,-18C158.7925,-18 170.4638,-18 181.3415,-18"/> <polygon fill="#000000" stroke="#000000" points="181.4507,-21.5001 191.4507,-18 181.4506,-14.5001 181.4507,-21.5001"/> <text text-anchor="middle" x="170.1621" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">h</text> </g> <!-- D --> <g id="node4" class="node">
<title>
D
</title>
<text text-anchor="middle" x="309.6621" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">D</text> </g> <!-- C&#45;&gt;D --> <g id="edge3" class="edge">
<title>
C-&gt;D
</title>
<path fill="none" stroke="#000000" stroke-dasharray="1,5" d="M245.9651,-18C254.2434,-18 263.4839,-18 272.3026,-18"/> <polygon fill="#000000" stroke="#000000" points="272.3784,-21.5001 282.3784,-18 272.3783,-14.5001 272.3784,-21.5001"/> </g> <!-- E --> <g id="node5" class="node">
<title>
E
</title>
<text text-anchor="middle" x="403.5518" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">E</text> </g> <!-- D&#45;&gt;E --> <g id="edge4" class="edge">
<title>
D-&gt;E
</title>
<path fill="none" stroke="#000000" d="M336.8189,-18C346.0639,-18 356.5622,-18 366.4504,-18"/> <polygon fill="#000000" stroke="#000000" points="366.456,-21.5001 376.456,-18 366.456,-14.5001 366.456,-21.5001"/> <text text-anchor="middle" x="356.6069" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">j</text> </g> <!-- F --> <g id="node6" class="node">
<title>
F
</title>
<text text-anchor="middle" x="500.5518" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">F</text> </g> <!-- E&#45;&gt;F --> <g id="edge5" class="edge">
<title>
E-&gt;F
</title>
<path fill="none" stroke="#000000" d="M430.5717,-18C440.6822,-18 452.3534,-18 463.2311,-18"/> <polygon fill="#000000" stroke="#000000" points="463.3404,-21.5001 473.3403,-18 463.3403,-14.5001 463.3404,-21.5001"/> <text text-anchor="middle" x="452.0518" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">g</text> </g> </g>
</svg>
<h3 id="恒等関手-定数関手">恒等関手, 定数関手</h3>
<p>恒等関手 <span class="math inline">\(1\)</span> とは対象と射について恒等的に返すもので <span class="math inline">\(1D=D, 1f=f\)</span>.</p>
<p>自由に選んだ対象 <span class="math inline">\(D\)</span> に対して, 全ての対象を <span class="math inline">\(D\)</span> に写すような関手 <span class="math inline">\(\underline{D}\)</span> がある. ただし射は全て <span class="math inline">\(1_D\)</span> に写すとする.</p>
<h3 id="lifting">Lifting</h3>
<p>関手 <span class="math inline">\(F, G\)</span> に対して関手 <span class="math inline">\(FG\)</span> を次のように定める:</p>
<ul>
<li><span class="math inline">\(FG(D) = G(FD)\)</span></li>
<li><span class="math inline">\(FGf = G(Ff)\)</span></li>
</ul>
<p>また更に双関手 <span class="math inline">\(\dagger\)</span> があるときに関手 <span class="math inline">\(F \dagger G\)</span> を次で定める:</p>
<ul>
<li><span class="math inline">\((F \dagger G)D = FD \dagger GD\)</span></li>
<li><span class="math inline">\((F \dagger G)f = Ff \dagger Gf\)</span></li>
</ul>
<h3 id="sectioning">Sectioning</h3>
<p>二項演算子 <span class="math inline">\(\oplus\)</span> があるとき, 関数 <span class="math inline">\((a \oplus)\)</span> を <span class="math inline">\((a \oplus) b=a\oplus b\)</span> で定める. 同様に関数 <span class="math inline">\((\oplus b) a = a \oplus b\)</span> を定める. この書き方を sectioning という. 必ず括弧で括る.</p>
<p>以上の記号を用いると, 例えば対象 <span class="math inline">\(A,B\)</span> について <span class="math inline">\((\underline{A} \dagger 1)(B)=A \dagger B=(A \dagger)B\)</span> なので <span class="math inline">\(\underline{A} \dagger 1 = (A \dagger)\)</span> だと言える.</p>
<h3 id="その他">その他</h3>
<p>終対象 (単集合) を <span class="math inline">\(\mathbb 1\)</span> と書く. またこれの要素を <span class="math inline">\(() \in \mathbb 1\)</span> と書いて void と呼ぶ.</p>
<p>さて述語関数 <span class="math inline">\(p : A \to \Bool\)</span> に対して関数 <span class="math inline">\(p?\)</span> を次のように定める:</p>
<ul>
<li><span class="math inline">\(p? \colon A \to A+A\)</span></li>
<li><span class="math inline">\(p? a = \begin{cases} \bot &amp; \text{ when } p~a = \bot \\ i_1 &amp; \text{ when } p~a = \true \\ i_2 &amp; \text{ when } p~a = \false \\ \end{cases}\)</span></li>
</ul>
<p>例えば <span class="math inline">\((f \triangledown g) \circ p?\)</span> は我々がよく知る if 文 <code>if p then f else g</code> を表現している.</p>
<p>任意の値を <span class="math inline">\(()\)</span> に写す定数関数を <span class="math inline">\(\VOID\)</span> と呼ぶことにする. <span class="math inline">\(\VOID \circ f=\VOID\)</span> である.</p>
<p>再帰を作るために <span class="math inline">\(\mu : (A \to A) \to A\)</span> を定義する.</p>
<ul>
<li><span class="math inline">\(\mu~f = x\)</span>
<ul>
<li>where <span class="math inline">\(x = f~x\)</span></li>
</ul></li>
</ul>
<p>2つの関手 <span class="math inline">\(F,G\)</span> とがあるとき, 対象 <span class="math inline">\(A\)</span> に <span class="math inline">\(\varphi_A \colon FA \to GA\)</span> を与えるような <span class="math inline">\(\varphi\)</span> をポリモーフィズム (polymorphism, 多相関数) といい <span class="math inline">\(\varphi \colon F \to G\)</span> と書く. 自然関手とは可換性を保つポリモーフィズムだと言える. <span class="math inline">\(\varphi\)</span> が自然変換であるとはポリモーフィズムであって, 射 <span class="math inline">\(f : A \to B\)</span> があるならば, <span class="math inline">\(\varphi_B \circ Ff = Gf \circ \varphi_A\)</span> という可換性を満たすもののこと.</p>
<h3 id="再帰型">再帰型</h3>
<p>以上の操作を再帰的に行って得られる型を再帰型という (ってことだよね).</p>
<p>ここで次のような定理が知られている.</p>
<p>関手 <span class="math inline">\(F\)</span> であって連続なものを考えると, ある対象 <span class="math inline">\(L\)</span> があって, 次を満たす2つの射 <span class="math inline">\(in : FL \to L\)</span> と <span class="math inline">\(out : L \to FL\)</span> がある:</p>
<ul>
<li><span class="math inline">\(in \circ out = 1\)</span></li>
<li><span class="math inline">\(out \circ in = 1\)</span></li>
<li><span class="math inline">\(1 = \mu(in \xleftarrow{F} out)\)</span></li>
</ul>
<p><span class="math inline">\(F\)</span> に対して上記のような <span class="math inline">\((L,in)\)</span> のことを <span class="math inline">\(\mu_F\)</span> と書いて最小不動点と呼ぶ.</p>
<p>例として関手 <span class="math inline">\(LX = \mathbb 1 + A \times X\)</span> を考えると, その最小不動点は <span class="math inline">\(\mu_L = ([A], (\const{\Nil} \triangledown \cons))\)</span> であって正にリストとその構成を表している. 同様に <span class="math inline">\(NX= \mathbb 1 + N\)</span> の最小不動点は <span class="math inline">\((\mathbb N, (\const{0} \triangledown (1+)))\)</span> である.</p>
<h2 id="再帰スキーム">再帰スキーム</h2>
<p>一般の再帰型について cata-, ana-, hylo-, paramorphism を与えることをする.</p>
<p>関手 <span class="math inline">\(F\)</span> に対して <span class="math inline">\((L,in)=\mu_F\)</span> であるとする. 3つのポリモーフィズム</p>
<ul>
<li><span class="math inline">\(\varphi_A \colon FA \to A\)</span></li>
<li><span class="math inline">\(\psi_A \colon A \to FA\)</span></li>
<li><span class="math inline">\(\xi_A \colon F(A \times L) \to A\)</span></li>
</ul>
<p>があるとき次を定める.</p>
<ul>
<li>catamorphism
<ul>
<li><span class="math inline">\(\banana{\varphi}_F = \mu(\varphi_A \xleftarrow{F} out)\)</span></li>
</ul></li>
<li>anamorphism
<ul>
<li><span class="math inline">\(\lense{\psi}_F = \mu(in \xleftarrow{F} \psi_A)\)</span></li>
</ul></li>
<li>hylomorphism
<ul>
<li><span class="math inline">\(\envelop{\varphi, \psi}_F = \mu(\varphi_B \xleftarrow{F} \psi_A)\)</span></li>
</ul></li>
<li>paramorphism
<ul>
<li><span class="math inline">\(\wire{\xi}_F = \mu(f \mapsto \xi_A \circ F(1_L \triangle f) \circ out)\)</span></li>
</ul></li>
</ul>
<p>ここで <span class="math inline">\(A, B\)</span> は任意の対象. また左辺の括弧にはどの関手によって定めるものかを表す添字 <span class="math inline">\({}_F\)</span> があるが, これは誤解がない限り省略する.</p>
<blockquote>
<p>1つ目の <span class="math inline">\(\varphi_L \xleftarrow{F} out\)</span> は <span class="math inline">\(f \colon L \to A\)</span> を取って <span class="math inline">\(A \xleftarrow{\varphi_A} FA \xleftarrow{Ff} FL \xleftarrow{out} L\)</span> の合成を返す関数. これの <span class="math inline">\(\mu\)</span> なので <span class="math inline">\(f = \varphi_L \circ Ff \circ out\)</span> なる <span class="math inline">\(f\)</span> が <span class="math inline">\(\banana{\varphi}\)</span>.</p>
</blockquote>
<blockquote>
<p>2つ目以降について型だけ書くと <span class="math inline">\(\lense{\psi} \colon A \to L\)</span>, <span class="math inline">\(\envelop{\varphi, \psi} \colon A \to B\)</span>, <span class="math inline">\(\wire{\xi} \colon L \to L\)</span>.</p>
</blockquote>
<p>リストの場合を思い出すと <span class="math inline">\(\banana{e, \oplus}\)</span> などと書いてたものは <span class="math inline">\(\banana{\const{e} \triangle \oplus\!}\)</span> と同等のものであったことが分かる. 同様に <span class="math inline">\(\lense{g,p}\)</span> と書いていたものは <span class="math inline">\(\lense{(\VOID + g) \circ p?}\)</span> と書き直される. 具体的には次に計算規則として見ていく.</p>
<h2 id="計算規則">計算規則</h2>
<p>cata, ana, para については共通に Evaluation Rule (対訳不明), Uniqueness Property (唯一性?), Fusion Law (融合則) が成り立つことを見ていく. その中で次の幾つかの定理を用いる.</p>
<div class="thm">
<h4 id="fixed-point-fusion-free-theorem">fixed point fusion (free theorem)</h4>
<p>関数 <span class="math inline">\(f\)</span> が正格で, <span class="math inline">\(f \circ g = h \circ f\)</span> ならば <span class="math display">\[f (\mu g) = \mu h\]</span></p>
</div>
<p>hylo については ana と cata とに分解できることと次の定理を利用する.</p>
<div class="thm">
<p><span class="math inline">\(g \circ h = 1\)</span> ならば <span class="math display">\[\mu(f \xleftarrow{F} g) \circ \mu(h \xleftarrow{F} j) = \mu(f \xleftarrow{F} j)\]</span></p>
</div>
<h3 id="evaluation-rule-for-catamorphism-cataeval">Evaluation Rule for Catamorphism (CataEval)</h3>
<div class="thm">
<p>catamorphism の evaluation rule は次のようなものである:</p>
<p>関手 <span class="math inline">\(F\)</span> とポリモーフィズム <span class="math inline">\(\varphi \colon F \to 1\)</span> とその射 <span class="math inline">\(\varphi_A : FA \to A\)</span> について, <span class="math inline">\(\mu_F=(L,in)\)</span> とすると <span class="math display">\[\banana{\varphi} \circ in = \varphi_A \circ F \banana{\varphi}\]</span></p>
<p><span class="math display">\[\begin{CD}
L @&lt;in&lt;&lt; FL \\
@V\banana{\varphi}VV @VF\banana{\varphi}VV \\
A @&lt;\varphi_A&lt;&lt; FA
\end{CD}\]</span></p>
</div>
<p>これは <span class="math inline">\(\banana{\varphi}\)</span> の定義から従う. <span class="math inline">\(\banana{\varphi} = \mu( \varphi_A \xleftarrow{F} out )\)</span> であったが <span class="math inline">\(\mu\)</span> の定義より <span class="math inline">\(\banana{\varphi} = \varphi_A \circ F \banana{\varphi_A} \circ out\)</span>. 両辺の右に <span class="math inline">\(in\)</span> を掛けると, <span class="math inline">\(in\)</span> は <span class="math inline">\(out\)</span> の逆射だったので <span class="math inline">\(\banana{\varphi} \circ in = \varphi_A \circ F \banana{\varphi_A}\)</span> を得る.</p>
<p>さてこの法則は evaluation rule という名前の通り, <span class="math inline">\(\banana{\varphi}\)</span> を具体的に計算するための方法を示している.</p>
<h4 id="例">例</h4>
<p>リストの <code>foldr</code> は次のようなものだった</p>
<ul>
<li>関手 <span class="math inline">\(LX = 1+AX\)</span></li>
<li><span class="math inline">\(\mu_L = ([A], in)\)</span>
<ul>
<li><span class="math inline">\(in = \const{\Nil} \triangledown \cons\)</span></li>
</ul></li>
<li>ポリモーフィズム <span class="math inline">\(\varphi_X = \const{c} \triangledown \oplus\)</span>
<ul>
<li><span class="math inline">\(\const{c} \colon 1 \to X\)</span></li>
<li><span class="math inline">\(\oplus \colon A \times X \to X\)</span></li>
</ul></li>
</ul>
<p>これらに対して <span class="math inline">\(\banana{\varphi}\)</span> が foldr. では具体的な値について foldr の計算をしてみる.</p>
<p>ただし <span class="math inline">\(L[A]=1+A[A]\)</span> について <span class="math inline">\(() \in 1\)</span> の場合と <span class="math inline">\((a,as) \in A[A]\)</span> の場合に分ける. これは <span class="math inline">\(in~() = \Nil\)</span> と <span class="math inline">\(in(a,as) = \cons(a,as)\)</span> の場合に分けてるのと同等 (<span class="math inline">\(in\)</span> は同型射なので).</p>
<p><span class="math display">\[\begin{align*}
\banana{\varphi} \Nil
&amp; = \banana{\varphi} \circ in () \\
&amp; = \varphi \circ L\banana{\varphi} () \\
&amp; = \varphi \circ (1 + 1_A \banana{\varphi}) () \\
&amp; = \varphi () \\
&amp; = (\const{c} \triangledown \oplus) () \\
&amp; = c
\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}
\banana{\varphi} \cons(a, as)
&amp; = \banana{\varphi} \circ in (a,as) \\
&amp; = \varphi \circ L\banana{\varphi} (a,as) \\
&amp; = \varphi \circ (1 + 1_A \banana{\varphi}) (a,as) \\
&amp; = \varphi (a, \banana{\varphi} as) \\
&amp; = (\const{c} \triangledown \oplus) (a, \banana{\varphi} as) \\
&amp; = a \oplus (\banana{\varphi} as)
\end{align*}\]</span></p>
<p>これで全ての場合を網羅できている.</p>
<h3 id="uniqueness-property-for-catamorphism-cataup">Uniqueness Property for catamorphism (CataUP)</h3>
<div class="thm">
<p><span class="math display">\[f=\banana{\varphi}_F
\iff
f \bot = \banana{\varphi}_F \bot
\land
f \circ in = \varphi \circ Ff\]</span></p>
</div>
<p>すなわち, 先の Evaluation Rule を満たすような <span class="math inline">\(\banana{\varphi}\)</span> は唯一しか存在しないことを主張する.</p>
<p>これもほぼ自明. <span class="math inline">\((\Rightarrow)\)</span> は Evaluation Rule のまんまなので自明. <span class="math inline">\((\Leftarrow)\)</span>. <span class="math inline">\(f~in=\varphi Ff \implies f=\varphi Ff~out \implies f = \mu(\varphi \xleftarrow{F} out) = \banana{\varphi}\)</span>.</p>
<h3 id="fusion-law-for-catamorphism-catafusion">Fusion Law for catamorphism (CataFusion)</h3>
<div class=thm>
<p><span class="math inline">\(f \circ \varphi = \psi \circ Ff\)</span> のとき <span class="math display">\[f \circ \banana{\varphi} = \banana{\psi}\]</span></p>
<center>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="220pt" height="188pt" viewBox="0.00 0.00 219.63 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>
%3
</title>
<!-- L -->
<g id="node1" class="node">
<title>
L
</title>
<text text-anchor="middle" x="84.52" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">L</text> </g> <!-- A --> <g id="node2" class="node">
<title>
A
</title>
<text text-anchor="middle" x="84.52" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text> </g> <!-- L&#45;&gt;A --> <g id="edge1" class="edge">
<title>
L-&gt;A
</title>
<path fill="none" stroke="#000000" d="M84.52,-143.5867C84.52,-135.9407 84.52,-126.8916 84.52,-118.4274"/> <polygon fill="#000000" stroke="#000000" points="88.0201,-118.1686 84.52,-108.1686 81.0201,-118.1687 88.0201,-118.1686"/> <text text-anchor="middle" x="74.52" y="-121.8" font-family="Times,serif" font-size="14.00" fill="#000000">(|φ|)</text> </g> <!-- B --> <g id="node4" class="node">
<title>
B
</title>
<text text-anchor="middle" x="84.52" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text> </g> <!-- L&#45;&gt;B --> <g id="edge6" class="edge">
<title>
L-&gt;B
</title>
<path fill="none" stroke="#000000" d="M57.2751,-145.3129C36.8134,-130.4468 13.8454,-107.3339 23.48,-83 29.5572,-67.6508 41.1634,-53.8103 52.6376,-42.885"/> <polygon fill="#000000" stroke="#000000" points="55.028,-45.4422 60.0993,-36.1399 50.3339,-40.2494 55.028,-45.4422"/> <text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">(|ψ|)</text> </g> <!-- FA --> <g id="node3" class="node">
<title>
FA
</title>
<text text-anchor="middle" x="184.6304" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">FA</text> </g> <!-- A&#45;&gt;FA --> <g id="edge2" class="edge">
<title>
A-&gt;FA
</title>
<path fill="none" stroke="#000000" d="M121.7077,-90C133.5841,-90 146.4973,-90 157.5174,-90"/> <polygon fill="#000000" stroke="#000000" points="121.6114,-86.5001 111.6113,-90 121.6113,-93.5001 121.6114,-86.5001"/> <text text-anchor="middle" x="134.5752" y="-92.8" font-family="Times,serif" font-size="14.00" fill="#000000">φ</text> </g> <!-- A&#45;&gt;B --> <g id="edge3" class="edge">
<title>
A-&gt;B
</title>
<path fill="none" stroke="#000000" d="M84.52,-71.5867C84.52,-63.9407 84.52,-54.8916 84.52,-46.4274"/> <polygon fill="#000000" stroke="#000000" points="88.0201,-46.1686 84.52,-36.1686 81.0201,-46.1687 88.0201,-46.1686"/> <text text-anchor="middle" x="74.52" y="-49.8" font-family="Times,serif" font-size="14.00" fill="#000000">f</text> </g> <!-- FB --> <g id="node5" class="node">
<title>
FB
</title>
<text text-anchor="middle" x="184.6304" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">FB</text> </g> <!-- FA&#45;&gt;FB --> <g id="edge4" class="edge">
<title>
FA-&gt;FB
</title>
<path fill="none" stroke="#000000" d="M184.6304,-71.5867C184.6304,-63.9407 184.6304,-54.8916 184.6304,-46.4274"/> <polygon fill="#000000" stroke="#000000" points="188.1305,-46.1686 184.6304,-36.1686 181.1305,-46.1687 188.1305,-46.1686"/> <text text-anchor="middle" x="174.6304" y="-49.8" font-family="Times,serif" font-size="14.00" fill="#000000">Ff</text> </g> <!-- FB&#45;&gt;B --> <g id="edge5" class="edge">
<title>
FB-&gt;B
</title>
<path fill="none" stroke="#000000" d="M157.5174,-18C146.4973,-18 133.5841,-18 121.7077,-18"/> <polygon fill="#000000" stroke="#000000" points="121.6114,-14.5001 111.6113,-18 121.6113,-21.5001 121.6114,-14.5001"/> <text text-anchor="middle" x="134.5752" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">ψ</text> </g> </g>
</svg>
</center>
</div>
<p>どう証明してもいいけど, <span class="math inline">\(\banana{}\)</span> の定義のを開けば <span class="math display">\[\begin{align*}
\banana{\varphi} &amp; = \mu(\varphi \xleftarrow{F} out) \\
&amp; = \varphi \circ F\banana{\varphi} \circ out \\
\end{align*}\]</span> 両辺に左から <span class="math inline">\(f\circ\)</span> を掛けて <span class="math display">\[\begin{align*}
f \circ \banana{\varphi}
&amp; = f \circ \varphi \circ F\banana{\varphi} \circ out \\
&amp; = \psi \circ Ff \circ F\banana{\varphi} \circ out \\
&amp; = \psi \circ F(f \circ \banana{\varphi}) \circ out \\
\end{align*}\]</span> というわけで <span class="math inline">\(f \circ \banana{\varphi}\)</span> は <span class="math inline">\(\mu(\psi \xleftarrow{F} out)\)</span> である. 一方で <span class="math inline">\(\banana{\psi}\)</span> もその <span class="math inline">\(\mu\)</span> である. catamorphism の唯一性 (CataUP) よりそれらは等しく <span class="math display">\[\banana{\psi} = f \circ \banana{\varphi}\]</span> である.</p>
<p>論文では <span class="math inline">\(f \circ (\varphi \xleftarrow{F} out) = (\psi \xleftarrow{F} out) \circ f\)</span> であることと fixed point fusion を用いて証明できる, と言っている.</p>
<h4 id="リスト畳込み-foldr-の融合則">リスト畳込み (<code>foldr</code>) の融合則</h4>
<p>2つのリストの畳込み <span class="math inline">\(\banana{\varphi} = \banana{c \triangledown \oplus}\)</span> と <span class="math inline">\(\banana{\psi} = \banana{d \triangledown \otimes}\)</span> について, ある <span class="math inline">\(f\)</span> があって,</p>
<ul>
<li><span class="math inline">\(d = fc\)</span>,</li>
<li><span class="math inline">\(f(x \oplus xs) = y \otimes f(xs)\)</span></li>
</ul>
<p>のとき <span class="math display">\[f \circ \banana{\varphi} = \banana{\psi}.\]</span></p>
<h3 id="包含射は-catamorphism">包含射は catamorphism</h3>
<p>射 <span class="math inline">\(f \colon A \to B\)</span> に左単位射 <span class="math inline">\(g\)</span> (<span class="math inline">\(gf=1\)</span>) があるとすると, <span class="math inline">\(Fg\)</span> は <span class="math inline">\(Ff\)</span> の逆射になるので <span class="math inline">\(f \circ \varphi = (f \circ \varphi \circ Fg) \circ Ff\)</span> である. CataFusion で <span class="math inline">\(\psi = f \circ \varphi \circ Fg\)</span> を代入すれば <span class="math inline">\(f \circ \banana{\varphi} = \banana{f \circ \varphi \circ Fg}\)</span> を得る.</p>
<p><span class="math display">\[\begin{CD}
L @&lt;in&lt;&lt; FL \\
@V\banana{\varphi}VV @VF\banana{\varphi}VV \\
A @&lt;\varphi&lt;&lt; FA \\
@VfVV @AFgAA \\
B @. FB
\end{CD}\]</span></p>
<p>上の図式で <span class="math inline">\(A=L, \varphi=in\)</span> の場合を考える. 唯一性より <span class="math inline">\(\banana{in}=1\)</span> を得る. これらを代入することで, <span class="math display">\[f = \banana{f \circ in \circ Fg}\]</span> を得る. これに <span class="math inline">\(B=FL, f=out, g=in\)</span> を代入すると,</p>
<p><span class="math display">\[\begin{CD}
L @&lt;in&lt;&lt; FL \\
@V\banana{in}VV @VF\banana{in}VV \\
L @&lt;in&lt;&lt; FL \\
@VoutVV @AF~inAA \\
FL @&lt;F~in&lt;&lt; FFL
\end{CD}\]</span></p>
<p>一番下の <span class="math inline">\(F(in) : F^2L \to FL\)</span> の catamorphism を考えることで <span class="math display">\[\banana{out \circ in \circ F(in)} = \banana{F(in)} = out\]</span> を得る.</p>
<h3 id="catamorphism-は正格性を保つ">catamorphism は正格性を保つ</h3>
<p>まず関手 <span class="math inline">\(F\)</span> が正格性を保つ, すなわち <span class="math inline">\(f \bot=\bot \iff Ef \bot = \bot\)</span> とする. このとき <span class="math display">\[\varphi \bot = \bot \iff \banana{\varphi}_F \bot = \bot\]</span> が成り立つ. 添字の <span class="math inline">\(F\)</span> は <span class="math inline">\(F\)</span> の下でのバナナであることを表したのに註意.</p>
<p><span class="math inline">\((\Rightarrow)\)</span>. <span class="math inline">\(\banana{\varphi} = \bot\)</span> を仮定すると <span class="math display">\[\begin{align*}
\bot &amp; = \banana{\varphi} \bot \\
     &amp; = \banana{\varphi} in \bot \\
     &amp; = \varphi F\banana{\varphi} \bot \\
     &amp; = \varphi \bot
\end{align*}\]</span> より従う. ここで最後の式変形には <span class="math inline">\(F\)</span> が正格性を保存することと <span class="math inline">\(\banana{\varphi}\bot=\bot\)</span> を仮定していることから <span class="math inline">\(F\banana{\varphi}\bot=\bot\)</span> を用いた.</p>
<h3 id="evaluation-rule-for-anamorphism-anaeval">Evaluation Rule for Anamorphism (AnaEval)</h3>
関手 <span class="math inline">\(F\)</span> とその <span class="math inline">\(\mu_F=(L,in)\)</span> について, <span class="math inline">\(\psi_A : A \to FA\)</span> に対して <span class="math inline">\(\lense{\psi} = \mu(in \xleftarrow{F} \psi)\)</span> が定義だったので, <span class="math display">\[\lense{\psi} = in \circ F\lense{\psi} \circ \psi\]</span> である. この両辺に左から <span class="math inline">\(out \circ\)</span> を掛けることで次を得る.
<div class="thm">
<p>AnaEval <span class="math display">\[out \circ \lense{\psi} = F\lense{\psi} \circ \psi\]</span></p>
<p><span class="math display">\[\begin{CD}
X                 @&gt;\psi&gt;&gt;  FX \\
@V\lense{\psi}VV            @VF\lense{\psi}VV \\
L                 @&gt;out&gt;&gt;   FL
\end{CD}\]</span></p>
</div>
<p>これはやはり <span class="math inline">\(\lense{\psi}\)</span> に関する評価規則を示している.</p>
<h4 id="例.-unfold">例. unfold</h4>
<p><span class="math inline">\(A\)</span> のリスト型 <span class="math inline">\(F \colon X \to 1+AX\)</span> について, リストのunfoldは <span class="math inline">\(g : X \to AX\)</span> と <span class="math inline">\(p? \colon X \to X+X\)</span> によって <span class="math inline">\(\lense{\psi} = \lense{(VOID+g) \circ p?}\)</span> と表されると言った. これの評価を考える.</p>
<p><span class="math display">\[\begin{align*}
\lense{\psi} x &amp; = in F\lense{\psi} \psi x \\
&amp; = \begin{cases}
\bot &amp; \text{ when } p~x = \bot \\
in F\lense{\psi} () &amp; \text{ when } p~x = \true \\
in F\lense{\psi} (a,x&#39;) &amp; \text{ when } p~x = \false, (a,x&#39;) = g~x \\
\end{cases}
\end{align*}\]</span></p>
<p>ここで <span class="math inline">\(F\lense{\psi}=1+1\times \lense{\psi}\)</span> であるので,</p>
<ul>
<li><span class="math inline">\(in~F\lense{\psi}() = in() = \Nil\)</span></li>
<li><span class="math inline">\(in~F\lense{\psi}(a, x&#39;) = in(a,x&#39;) = \cons(a,x&#39;)\)</span></li>
</ul>
<p>となっていわゆる <code>unfold</code> を得る.</p>
<h4 id="例.-iterate">例. iterate</h4>
<p><span class="math inline">\(f:A \to A\)</span> とリスト型 <span class="math inline">\(F:X \to 1+AX\)</span> について <span class="math inline">\(\psi_A = 1_2 \circ (1_A \triangle f) : A \to FA\)</span> とする.</p>
<p><span class="math display">\[\begin{align*}
\psi_A x
&amp; = i_2(1\triangle f) x \\
&amp; = i_2(x,fx) \\
&amp; = (x, fx) ~ \in 1+AX
\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}
out \lense{\psi} x
&amp; = F\lense{\psi} \psi x \\
&amp; = (1+1\times\lense{\psi}) (x,fx) \\
&amp; = (x, \lense{\psi}(fx))
\end{align*}\]</span></p>
<p>(左からinを掛けることで) <span class="math display">\[\lense{\psi} x = \cons(x, \lense{\psi}(fx))\]</span> を得る. これは Haskell なのでは <code>iterate f</code> として知られる.</p>
<h3 id="anamorphism-の唯一性-anaup">anamorphism の唯一性 (AnaUP)</h3>
<div class="thm">
<p><span class="math display">\[f = \lense{\psi}_F \iff out \circ f = Ff \circ \psi\]</span></p>
</div>
<h3 id="anamorphism-の融合則-anafusion">anamorphism の融合則 (AnaFusion)</h3>
<div class="thm">
<p><span class="math inline">\(\varphi \circ f = Ff \circ \psi\)</span> のとき <span class="math display">\[\lense{\varphi} \circ f = \lense{\psi}\]</span></p>
</div>
<center>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="229pt" height="188pt" viewBox="0.00 0.00 229.27 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>
%3
</title>
<!-- B -->
<g id="node1" class="node">
<title>
B
</title>
<text text-anchor="middle" x="86.3794" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text> </g> <!-- FB --> <g id="node2" class="node">
<title>
FB
</title>
<text text-anchor="middle" x="194.269" y="-157.8" font-family="Times,serif" font-size="14.00" fill="#000000">FB</text> </g> <!-- B&#45;&gt;FB --> <g id="edge1" class="edge">
<title>
B-&gt;FB
</title>
<path fill="none" stroke="#000000" d="M113.6045,-162C126.7654,-162 142.7649,-162 157.0339,-162"/> <polygon fill="#000000" stroke="#000000" points="157.0527,-165.5001 167.0526,-162 157.0526,-158.5001 157.0527,-165.5001"/> <text text-anchor="middle" x="140.3242" y="-164.8" font-family="Times,serif" font-size="14.00" fill="#000000">ψ</text> </g> <!-- A --> <g id="node3" class="node">
<title>
A
</title>
<text text-anchor="middle" x="86.3794" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text> </g> <!-- B&#45;&gt;A --> <g id="edge4" class="edge">
<title>
B-&gt;A
</title>
<path fill="none" stroke="#000000" d="M86.3794,-143.5867C86.3794,-135.9407 86.3794,-126.8916 86.3794,-118.4274"/> <polygon fill="#000000" stroke="#000000" points="89.8795,-118.1686 86.3794,-108.1686 82.8795,-118.1687 89.8795,-118.1686"/> <text text-anchor="middle" x="76.3794" y="-121.8" font-family="Times,serif" font-size="14.00" fill="#000000">f</text> </g> <!-- L --> <g id="node5" class="node">
<title>
L
</title>
<text text-anchor="middle" x="86.3794" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">L</text> </g> <!-- B&#45;&gt;L --> <g id="edge7" class="edge">
<title>
B-&gt;L
</title>
<path fill="none" stroke="#000000" d="M59.192,-146.6763C37.0789,-132.0075 11.1249,-108.4057 21.6206,-83 28.0569,-67.4206 40.2373,-53.6146 52.3133,-42.778"/> <polygon fill="#000000" stroke="#000000" points="54.8204,-45.2405 60.1724,-36.0968 50.2865,-39.9072 54.8204,-45.2405"/> <text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">[(ψ)]</text> </g> <!-- FA --> <g id="node4" class="node">
<title>
FA
</title>
<text text-anchor="middle" x="194.269" y="-85.8" font-family="Times,serif" font-size="14.00" fill="#000000">FA</text> </g> <!-- FB&#45;&gt;FA --> <g id="edge5" class="edge">
<title>
FB-&gt;FA
</title>
<path fill="none" stroke="#000000" d="M194.269,-143.5867C194.269,-135.9407 194.269,-126.8916 194.269,-118.4274"/> <polygon fill="#000000" stroke="#000000" points="197.7691,-118.1686 194.269,-108.1686 190.7691,-118.1687 197.7691,-118.1686"/> <text text-anchor="middle" x="184.269" y="-121.8" font-family="Times,serif" font-size="14.00" fill="#000000">Ff</text> </g> <!-- A&#45;&gt;FA --> <g id="edge2" class="edge">
<title>
A-&gt;FA
</title>
<path fill="none" stroke="#000000" d="M113.6045,-90C126.7654,-90 142.7649,-90 157.0339,-90"/> <polygon fill="#000000" stroke="#000000" points="157.0527,-93.5001 167.0526,-90 157.0526,-86.5001 157.0527,-93.5001"/> <text text-anchor="middle" x="140.3242" y="-92.8" font-family="Times,serif" font-size="14.00" fill="#000000">φ</text> </g> <!-- A&#45;&gt;L --> <g id="edge6" class="edge">
<title>
A-&gt;L
</title>
<path fill="none" stroke="#000000" d="M86.3794,-71.5867C86.3794,-63.9407 86.3794,-54.8916 86.3794,-46.4274"/> <polygon fill="#000000" stroke="#000000" points="89.8795,-46.1686 86.3794,-36.1686 82.8795,-46.1687 89.8795,-46.1686"/> <text text-anchor="middle" x="76.3794" y="-49.8" font-family="Times,serif" font-size="14.00" fill="#000000">[(φ)]</text> </g> <!-- FL --> <g id="node6" class="node">
<title>
FL
</title>
<text text-anchor="middle" x="194.269" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">FL</text> </g> <!-- L&#45;&gt;FL --> <g id="edge3" class="edge">
<title>
L-&gt;FL
</title>
<path fill="none" stroke="#000000" d="M113.6045,-18C126.7654,-18 142.7649,-18 157.0339,-18"/> <polygon fill="#000000" stroke="#000000" points="157.0527,-21.5001 167.0526,-18 157.0526,-14.5001 157.0527,-21.5001"/> <text text-anchor="middle" x="140.3242" y="-20.8" font-family="Times,serif" font-size="14.00" fill="#000000">out</text> </g> </g>
</svg>
</center>
<p>唯一性より従う.</p>
<h3 id="全射は-anamorphism">全射は anamorphism</h3>
<p>以上のことは単に catamorphism の双対を取れば導けた. 全く同様に, 包含射即ち左単位射を持つ射が catamorphism であったことから, 全射即ち右単位射を持つ射は anamorphism である.</p>
<p>全射を <span class="math inline">\(f\)</span> として, ある <span class="math inline">\(g\)</span> によって <span class="math inline">\(fg=1\)</span> であるとすると, <span class="math display">\[f = \lense{Fg \circ out \circ f}\]</span> が成立する.</p>
<p>これに <span class="math inline">\(f=in, g=out\)</span> を代入することで, <span class="math display">\[\lense{F(out) \circ in \circ in} = \lense{F(out)} = in\]</span> を得る.</p>
<h3 id="splitting-hylomorphism-hylosplit">Splitting Hylomorphism (HyloSplit)</h3>
<span class="math inline">\(gh=1\)</span> のとき, 合成則 <span class="math inline">\(\mu(f \xleftarrow{F} g) \circ \mu(h \xleftarrow{F} j) = \mu(f \xleftarrow{F} j)\)</span> が成り立つ. これによって次の定理が成り立つ.
<div class="thm">
<p><span class="math display">\[\envelop{\varphi, \psi} = \banana{\varphi} \circ \lense{\psi}\]</span></p>
</div>
<h3 id="shifting-law-for-hylomorphism-hyloshift">Shifting Law for Hylomorphism (HyloShift)</h3>
<p>関手 <span class="math inline">\(F,M\)</span> があり, <span class="math inline">\(\varphi \colon ML \to B\)</span>, <span class="math inline">\(\psi \colon A \to FA\)</span>, <span class="math inline">\(\xi \colon F \to M\)</span> とする.</p>
<center>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="242pt" height="130pt" viewBox="0.00 0.00 242.00 130.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 126)">
<title>
%3
</title>
<!-- A -->
<g id="node1" class="node">
<title>
A
</title>
<text text-anchor="middle" x="27" y="-99.8" font-family="Times,serif" font-size="14.00" fill="#000000">A</text> </g> <!-- FA --> <g id="node2" class="node">
<title>
FA
</title>
<text text-anchor="middle" x="117" y="-99.8" font-family="Times,serif" font-size="14.00" fill="#000000">FA</text> </g> <!-- A&#45;&gt;FA --> <g id="edge1" class="edge">
<title>
A-&gt;FA
</title>
<path fill="none" stroke="#000000" d="M54.003,-104C62.0277,-104 70.9665,-104 79.5309,-104"/> <polygon fill="#000000" stroke="#000000" points="79.7051,-107.5001 89.705,-104 79.705,-100.5001 79.7051,-107.5001"/> <text text-anchor="middle" x="72" y="-109.8" font-family="Times,serif" font-size="14.00" fill="#000000">ψ</text> </g> <!-- B --> <g id="node6" class="node">
<title>
B
</title>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">B</text> </g> <!-- A&#45;&gt;B --> <g id="edge5" class="edge">
<title>
A-&gt;B
</title>
<path fill="none" stroke="#000000" d="M27,-85.7616C27,-74.3597 27,-59.4342 27,-46.494"/> <polygon fill="#000000" stroke="#000000" points="30.5001,-46.2121 27,-36.2121 23.5001,-46.2121 30.5001,-46.2121"/> </g> <!-- MA --> <g id="node3" class="node">
<title>
MA
</title>
<text text-anchor="middle" x="207" y="-99.8" font-family="Times,serif" font-size="14.00" fill="#000000">MA</text> </g> <!-- FA&#45;&gt;MA --> <g id="edge2" class="edge">
<title>
FA-&gt;MA
</title>
<path fill="none" stroke="#000000" d="M144.003,-104C152.0277,-104 160.9665,-104 169.5309,-104"/> <polygon fill="#000000" stroke="#000000" points="169.7051,-107.5001 179.705,-104 169.705,-100.5001 169.7051,-107.5001"/> <text text-anchor="middle" x="162" y="-109.8" font-family="Times,serif" font-size="14.00" fill="#000000">ξ</text> </g> <!-- FB --> <g id="node4" class="node">
<title>
FB
</title>
<text text-anchor="middle" x="99" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">FB</text> </g> <!-- MB --> <g id="node5" class="node">
<title>
MB
</title>
<text text-anchor="middle" x="189" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">MB</text> </g> <!-- FB&#45;&gt;MB --> <g id="edge3" class="edge">
<title>
FB-&gt;MB
</title>
<path fill="none" stroke="#000000" d="M126.003,-18C134.0277,-18 142.9665,-18 151.5309,-18"/> <polygon fill="#000000" stroke="#000000" points="151.7051,-21.5001 161.705,-18 151.705,-14.5001 151.7051,-21.5001"/> <text text-anchor="middle" x="144" y="-23.8" font-family="Times,serif" font-size="14.00" fill="#000000">ξ</text> </g> <!-- B&#45;&gt;MB --> <g id="edge4" class="edge">
<title>
B-&gt;MB
</title>
<path fill="none" stroke="#000000" d="M59.8959,-41.4168C72.8054,-49.26 88.1498,-57.0181 103.3311,-61 128.1204,-67.502 154.0867,-50.6206 170.8433,-36.1359"/> <polygon fill="#000000" stroke="#000000" points="61.6995,-38.4162 51.3795,-36.0187 57.9519,-44.3285 61.6995,-38.4162"/> <text text-anchor="middle" x="108" y="-56.8" font-family="Times,serif" font-size="14.00" fill="#000000">φ</text> </g> </g>
</svg>
</center>
<p>上の図式において <span class="math inline">\(\envelop{\ldots} \colon A \to B\)</span> は <span class="math inline">\(F\)</span> に於いても <span class="math inline">\(M\)</span> に於いてでも正しく定まり, <span class="math display">\[\envelop{\varphi_B\xi_B, \psi_A}_F = \envelop{\varphi_B, \xi_A\psi_A}_M\]</span> が成り立つ.</p>
<p>これは cata や ana と違って陽に <span class="math inline">\(\mu_F, \mu_M\)</span> が登場しないからこういうことが出来る.</p>
<h3 id="cata-と-ana-の関係">cata と ana の関係</h3>
<div class=thm>
<p><span class="math inline">\(\mu_F = (L, in_F)\)</span>, <span class="math inline">\(\mu_M = (L, in_M)\)</span> でこの間にポリモーフィズム <span class="math inline">\(\varphi \colon F \to M\)</span> があるとき, <span class="math display">\[\banana{in_M\circ\varphi}_F = \lense{\varphi\circ out_F}_M\]</span></p>
<center>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.40.1 (20161225.0304)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="269pt" height="98pt" viewBox="0.00 0.00 269.23 98.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 94)">
<title>
%3
</title>
<!-- L -->
<g id="node1" class="node">
<title>
L
</title>
<text text-anchor="middle" x="27" y="-67.8" font-family="Times,serif" font-size="14.00" fill="#000000">L</text> </g> <!-- FL --> <g id="node2" class="node">
<title>
FL
</title>
<text text-anchor="middle" x="134.8896" y="-65.8" font-family="Times,serif" font-size="14.00" fill="#000000">FL</text> </g> <!-- L&#45;&gt;FL --> <g id="edge1" class="edge">
<title>
L-&gt;FL
</title>
<path fill="none" stroke="#000000" d="M54.2251,-71.4953C67.386,-71.2513 83.3855,-70.9548 97.6545,-70.6902"/> <polygon fill="#000000" stroke="#000000" points="97.7399,-74.1894 107.6732,-70.5045 97.6101,-67.1906 97.7399,-74.1894"/> <text text-anchor="middle" x="80.9448" y="-73.8" font-family="Times,serif" font-size="14.00" fill="#000000">out</text> </g> <!-- ML --> <g id="node3" class="node">
<title>
ML
</title>
<text text-anchor="middle" x="234.2275" y="-29.8" font-family="Times,serif" font-size="14.00" fill="#000000">ML</text> </g> <!-- FL&#45;&gt;ML --> <g id="edge2" class="edge">
<title>
FL-&gt;ML
</title>
<path fill="none" stroke="#000000" d="M162.0342,-60.1628C172.9847,-56.1944 185.7885,-51.5543 197.5476,-47.2928"/> <polygon fill="#000000" stroke="#000000" points="198.9067,-50.5231 207.1158,-43.8253 196.5216,-43.9419 198.9067,-50.5231"/> <text text-anchor="middle" x="184.5586" y="-55.8" font-family="Times,serif" font-size="14.00" fill="#000000">φ</text> </g> <!-- L2 --> <g id="node4" class="node">
<title>
L2
</title>
<text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00" fill="#000000">L</text> </g> <!-- ML&#45;&gt;L2 --> <g id="edge3" class="edge">
<title>
ML-&gt;L2
</title>
<path fill="none" stroke="#000000" d="M207.1295,-31.9078C170.5913,-29.0867 105.3773,-24.0515 64.2494,-20.876"/> <polygon fill="#000000" stroke="#000000" points="64.3312,-17.372 54.0914,-20.0917 63.7922,-24.3512 64.3312,-17.372"/> <text text-anchor="middle" x="134.8896" y="-30.8" font-family="Times,serif" font-size="14.00" fill="#000000">in</text> </g> </g>
</svg>
</center>
</div>
<div class="thm">
<p><span class="math inline">\(\psi \circ \varphi=1\)</span> のとき, <span class="math inline">\(\mu\)</span> の合成則より <span class="math display">\[\lense{\psi} \circ \banana{\varphi} = 1\]</span></p>
</div>
<p>例えば <code>foldr</code> してから <code>unfold</code> した結果が元に戻るための十分条件として, ポリモーフィズムのレベルで合成が <span class="math inline">\(1\)</span> であることがある.</p>
<h3 id="evaluation-rule-for-paramorphism-paraeval">Evaluation Rule for Paramorphism (ParaEval)</h3>
<p>定義がだいぶ前なので, 改めて paramorphism の定義を書くと, <span class="math inline">\(\mu_F=(L,in)\)</span> について ポリモーフィズム <span class="math inline">\(\xi_A \colon F(AL) \to A\)</span> があるとき <span class="math inline">\(\wire{\xi}\)</span> とは, <span class="math inline">\(f \colon L \to L\)</span> なる射によって <span class="math display">\[\wire{\xi} \equiv \mu(f \mapsto \xi_L \circ F(1 \triangle f) \circ out)\]</span> と書かれるもの.</p>
<p>従って <span class="math display">\[\wire{\xi} = \xi_L \circ F(1_L \triangle \wire{\xi}) \circ out\]</span> 両辺に右から <span class="math inline">\(in\)</span> を掛けることで <span class="math display">\[\wire{\xi} \circ in = \xi_L \circ F(1_L \triangle \wire{\xi})\]</span> を得、これが paramorphism の評価規則になっている.</p>
<h4 id="例.-リスト">例. リスト</h4>
<p><span class="math inline">\(FX=1+AX\)</span> について <span class="math inline">\(\xi_A \colon F(AL) \to A\)</span> の paramorphism を考える.</p>
<p><span class="math inline">\(F(1_L \triangle \wire{\xi}) x = (1+1 \times (1_L \triangle \wire{\xi})) x\)</span> は <span class="math inline">\(x \in 1\)</span> なら <span class="math inline">\(() \in 1\)</span>, さもなくば <span class="math inline">\(x=(a,b)=A \times L\)</span> であって値は <span class="math inline">\((a, (b, \wire{\xi}~b))\)</span> であることに註意すると,</p>
<p><span class="math display">\[\begin{align*}
\wire{\xi} \Nil
&amp; = \wire{\xi} in~() \\
&amp; = \xi F(1 \triangle \wire{\xi}) () \\
&amp; = \xi ()
\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}
\wire{\xi} \cons(a,as)
&amp; = \wire{\xi} in(a,as) \\
&amp; = \xi F(1 \triangle \wire{\xi}) (a, as) \\
&amp; = \xi (a, (as, \wire{\xi}~as))
\end{align*}\]</span></p>
<h3 id="唯一性-paraup">唯一性 (ParaUP)</h3>
<div class="thm">
<p><span class="math display">\[f = \wire{\xi}_F \iff f \circ in = \xi \circ F(1 \triangle f)\]</span></p>
</div>
<h3 id="融合則-parafusion">融合則 (ParaFusion)</h3>
<div class="thm">
<p><span class="math inline">\(f \circ \varphi = \psi \circ F(1 \times f)\)</span> のとき <span class="math display">\[f \circ \wire{\varphi} = \wire{\psi}\]</span></p>
<p><span class="math display">\[\begin{CD}
L                 @&gt;out&gt;&gt;       FL                \\
@V\lense{\psi}VV                @.                \\
L                 @&lt;\varphi&lt;&lt;   F(1 \times L)     \\
@VfVV                           @VVF(1\times f)V  \\
L                 @&lt;\psi&lt;&lt;      F(L \times L)
\end{CD}\]</span></p>
</div>
<h3 id="定理">定理</h3>
<div class="thm">
<p><span class="math display">\[f = \wire{f \circ in \circ F\pi_1}\]</span></p>
</div>
<h2 id="parameterized-types-パラメータ化された型">Parameterized Types (パラメータ化された型)</h2>
<p>最初のほうで map 関数というものをやった. 即ち型 <span class="math inline">\(A,B\)</span> に対しては型 <span class="math inline">\([A], [B]\)</span> というものを定義することが出来, 射 <span class="math inline">\(f\colon A \to B\)</span> に対して <span class="math inline">\(f* \colon [A] \to [B]\)</span> というものを定めることが出来た. また明らかに <span class="math inline">\(1*=1\)</span>, <span class="math inline">\(f* \circ g* = (fg)*\)</span> が成り立つ. この意味で <span class="math inline">\(*\)</span> は関手である <span class="math inline">\((A* = [A])\)</span>. これを一般化する.</p>
<h3 id="sectioning-について-復習">Sectioning について (復習???)</h3>
<p>双関手 <span class="math inline">\(\dagger\)</span> とある対象 <span class="math inline">\(A\)</span> について, <span class="math display">\[(A \dagger) = \underline{A} \dagger 1\]</span> であった. つまりこれは関手であって,</p>
<ul>
<li><span class="math inline">\((A\dagger)B = A \dagger B\)</span></li>
<li><span class="math inline">\((A\dagger)f = (\underline{A} \dagger 1) f = 1_A \dagger f\)</span></li>
</ul>
<p>と写す.</p>
<p>射 <span class="math inline">\(f \colon A \to B\)</span> について <span class="math inline">\((f \dagger)\)</span> はポリモーフィズムであって (!!),</p>
<ul>
<li><span class="math inline">\((f \dagger) \colon (A\dagger) \to (B\dagger)\)</span></li>
<li><span class="math inline">\((f \dagger)_X \colon (A\dagger X) \to (B\dagger X)\)</span></li>
<li><span class="math inline">\((f \dagger)_X = f \dagger 1_X\)</span></li>
</ul>
<h3 id="maps">Maps</h3>
<p>関手 <span class="math inline">\(*\)</span> を次のように定義し直す.</p>
<p>ある双関手 <span class="math inline">\(\dagger\)</span> と対象 <span class="math inline">\(A\)</span> について <span class="math inline">\(\mu(A\dagger) = (A*,in_A)\)</span> であると定義する. 同様に対象 <span class="math inline">\(B\)</span> については <span class="math inline">\(\mu(B\dagger) = (B*,in_B)\)</span></p>
<p>ある射 <span class="math inline">\(f \colon A \to B\)</span> があるとき, <span class="math display">\[\varphi = in_B \circ (f \dagger)_{B*} \colon A\dagger B* \to B*\]</span> が定まる. この catamorphism を <span class="math inline">\(f*\)</span> であると定義する. <span class="math display">\[f* = \banana{in_B \circ (f \dagger)_B{*}}_{(A\dagger)}\]</span></p>
<p><span class="math display">\[\begin{CD}
A*   @&lt;in_A&lt;&lt; A\dagger A* \\
@Vf*=\banana{\varphi}VV \\
B*   @&lt;in_B&lt;&lt; B\dagger B* @&lt;(f\dagger)_{B*}&lt;&lt; A \dagger B*
\end{CD}\]</span></p>
<p>先の &quot;cata と ana の関係&quot; でも見たように, <span class="math display">\[f* = \lense{(f \dagger)_{A*} \circ out_A}_{(A\dagger)}\]</span></p>
<p><span class="math display">\[\begin{CD}
A* @&gt;out_A&gt;&gt; A \dagger A* @&gt;(f\dagger)&gt;&gt; B \dagger A* \\
@Vf*=\lense{\psi}VV \\
B* @&lt;in_B&lt;&lt; B \dagger B*
\end{CD}\]</span></p>
<p>と書き直すことも出来る.</p>
<p>以上で関手 <span class="math inline">\(*\)</span> が定義された. これはリストのマップとして定義した <span class="math inline">\(*\)</span> の一般化になっている. <span class="math inline">\(A\dagger B = 1+A \times B\)</span> とすればリストの場合が導出出来る.</p>
<h4 id="合成">合成</h4>
<p>合成に関して次が成立する. <span class="math display">\[\begin{align*}
f* \circ g*
&amp; = \banana{in \circ (f\dagger)} \circ \banana{in \circ (g\dagger)} \\
&amp; = \banana{in \circ (f\dagger) \circ (g\dagger)} \\
&amp; = \banana{in \circ ((f \circ g) \dagger)} \\
&amp; = (f \circ g)*
\end{align*}\]</span></p>
<h3 id="map-reduce">Map-Reduce</h3>
<p>関手 <span class="math inline">\(F\)</span> と対象 <span class="math inline">\(A\)</span> について <span class="math inline">\(A \dagger X = A + FX\)</span> としたときの <span class="math inline">\((A*,in)=\mu(A \dagger)\)</span> を <span class="math inline">\(A\)</span> の上の free <span class="math inline">\(F\)</span>-type と呼ぶ.</p>
<p><span class="math inline">\(f \colon A \to B\)</span> について, <span class="math inline">\(f* = \banana{in_B \circ (f\dagger)_{B*}}\)</span> であったが, 今 <span class="math inline">\(\tau_B = in \circ i_1 \colon B \to B*\)</span>, <span class="math inline">\(\join_B = in \circ i_2 \colon B* \to B*\)</span> とすると, <span class="math display">\[f* = \banana{(\tau_B \circ f) \triangledown \join_B}\]</span> と書き直せる.</p>
<p>射 <span class="math inline">\(\varphi\)</span> に対して次で定める <span class="math inline">\(\varphi/\)</span> を <span class="math inline">\(\varphi\)</span> の reduction と呼ぶ: <span class="math display">\[\varphi/ = \banana{1 \triangledown \varphi}\]</span> これに関して次が成り立つ. <span class="math display">\[\begin{align*}
\banana{f \triangledown \varphi}
&amp; = \banana{(1 \triangledown \varphi) \circ (f + 1)} \\
&amp; = \banana{1 \triangledown \varphi} \circ f* \\
&amp; = \varphi/ \circ f*
\end{align*}\]</span></p>
<p>さて実は <span class="math inline">\(\tau, \join\)</span> は自然変換である. <span class="math display">\[\begin{CD}
A @&gt;f&gt;&gt; B \\
@V\tau_AVV @V\tau_BVV \\
A* @&gt;f*&gt;&gt; B*
\end{CD}\]</span> <span class="math display">\[\begin{CD}
FA* @&gt;Ff*&gt;&gt; FB* \\
@V{\join_A}VV @V{\join_B}VV \\
A* @&gt;f*&gt;&gt; B*
\end{CD}\]</span> このことから <span class="math inline">\(f*\)</span> の評価規則を得る:</p>
<ul>
<li><span class="math inline">\(f* \circ \tau = \tau \circ f\)</span></li>
<li><span class="math inline">\(f* \circ \join = \join \circ Ff*\)</span></li>
</ul>
<p>一方で <span class="math inline">\(\varphi/\)</span> の評価規則は普通に CataEval から次のようになる:</p>
<ul>
<li><span class="math inline">\(\varphi/\circ \tau = 1\)</span></li>
<li><span class="math inline">\(\varphi/\circ \join = \varphi \circ F(\varphi/)\)</span></li>
</ul>
<h3 id="モナド">モナド</h3>
<p>free type があるとき, モナドを次のようにして与えることが出来る. つまり</p>
<ul>
<li>関手 <span class="math inline">\(*\)</span></li>
<li>自然変換 <span class="math inline">\(\tau \colon 1 \to *\)</span></li>
<li>自然変換 <span class="math inline">\(\join/ \colon ** \to *\)</span></li>
</ul>
<p>について</p>
<ul>
<li><span class="math inline">\(\join/ \circ \tau = 1\)</span></li>
<li><span class="math inline">\(\join/ \circ \tau* = 1\)</span></li>
<li><span class="math inline">\(\join/ \circ \join/ = \join/ \circ \join/*\)</span></li>
</ul>
<p>が成り立つ.</p>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
