<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>不偏ゲームのグランディ数 (ニム数)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">不偏ゲームのグランディ数 (ニム数)</h1>
<p><p class=date style='text-align: right'>2017-03-25 (Sat.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#ゲーム理論>ゲーム理論</a> <a class='tag is-red' href=index.html#グランディ数>グランディ数</a> <a class='tag is-red' href=index.html#ニム和>ニム和</a> </div></p>
\[
\def\I{\mathcal I}
\def\P{\mathcal P}
\def\G{\mathcal G}
\def\mex{\mathrm{mex}}
\def\bar#1{\overline{#1}}
\]
<h2>index</h2>
<p><div id=toc></div></p>
<h2>不偏ゲームとは何か</h2>
<p>二人が交互に手を打つ (一つの局番に関する操作) 完全情報ゲームであって, 二人ともが打てる手が同じものを不偏ゲームという. ただし, 千日手が無く, どのような手を打っていても有限回でゲームが終了することが保証されているものだけを扱う.</p>
<p>典型的な, 不偏ゲームの例に <a href="https://ja.wikipedia.org/wiki/ニム">Nim (石取りゲーム)</a> である. 端的に言ってしまうなら, あらゆる不偏ゲームは Nim（石取りゲーム）をちょっと拡張した程度のものに帰着することができる.</p>
<p>一方で, 例えばオセロやチェスは動かせるコマが色によって区別されており, 二人のプレイヤーで打てる手が違うので, 不偏ゲームの定義からは外れる.</p>
<p>以降では不偏ゲームを指して「ゲーム」という.</p>
<h2>コンウェイによる抽象化</h2>
<p>まず直感的にゲームを形式化する. ゲームとは, 局面の初期状態 \(I_0\) と, 局面に対して打つ手を定めるルール \(R\) の2つ組 \((I_0, R)\) のことである. 局面の状態空間を \(\I\) とすると,</p>
<ul>
  <li>初期状態 \(I_0 \in \I\)</li>
  <li>ルール \(R \colon \I \to \P(\I)\)</li>
</ul>
<p>だと言える. ここで \(\P(\I)\) は \(\I\) の冪集合のこと. ある局面 \(\I\) に対してルール \(R\) はいくつか（０個以上）の手を用意していて, それらによって \(\{I_1, \ldots, I_N\} \subset \I\) に写ることを</p>
\[R(I) = \{I_1, \ldots, I_N\}\]
<p>と定めることができる.</p>
<p>さて「ゲーム」の定義に初期状態 \(I_0\) を入れておいたがこれは必要だろうか. 特に次のような状況を考える. もし \(R(I_0) = R(I_1)\) のとき, この２つの局面 \(I_0, I_1\) を区別する必要があるだろうか. もし単に勝ち負けの決定に興味があるのなら, この区別は必要なく, 必要なのは今の状態 \(I_0\) ではなくて \(R(I_0)\) だけである.</p>
<p>というわけで, 次の形式化を思いつく:</p>
<ul>
  <li>
    ゲーム集合 \(\G\)
    <ul>
      <li>\(g \in \G\) をゲーム（あるいは局面）という</li>
      <li>\(g\) は \(\G\) の部分集合</li>
    </ul>
  </li>
</ul>
<p>この \(g\) は先程までの局面 \(I \in \I\) に対応しているが具体的には集合 \(R(I)\) の形を持っている. \(R(I)\) がまた \(\I\) の部分集合だったのと同様に \(g\) は \(\G\) の部分集合である.</p>
<p>今ゲーム \(g\) があるときに先手は</p>
\[g&#x27; \in g\]
<p>という手を選んで打つことが出来る. つまり \(|g| = n\) なら, \(n\) 個の選択肢があることになる. そして \(g&#x27;\) を選んでこれを後手の人に渡す.</p>
<p>ところで, ここでは「ゲーム」という言葉と普段我々が使う「局面」という言葉を区別しない. 日常的な感覚ではゲームは最初の定義のような形であって局面はその中の一つの状態のことだろう. だが, 局面が変化したある状態を切り取ってきて, これを初期状態とするゲームを考えることが出来る. 最初の定義で言えばゲームとは \((I_0, R)\) のことだったが, これは局面 \(I_0\) のことを指してると思ってもいいし, 局面 \(I_1\) のことをゲーム \((I_1, R)\) のことと思っても良い.</p>
<h3>例</h3>
<p>簡単のために, つまらない石取りゲームを考える. 局面の状態として石が \(N\) 個山積みにしてある. 二人のプレイヤーはここからちょうど \(1\) 個ずつ取り除いていく. 石が取れなくなった人の負け.</p>
<p>石が \(N\) 個ある状態というのを, 今の集合の形式で書き直したものを \(\bar{N}\) と書くことにしよう. するとゲーム集合というのは</p>
\[\G = \{ \bar{0}, \bar{1}, \ldots, \bar{N} \}\]
<p>である. \(N\) より大きな局面はここでは考える必要がない.</p>
<p>さてまず自明なのは \(\bar{0}\) で, これは石がゼロ個の状態であって何もできない. これを空集合で表す.</p>
\[\bar 0 = \{\}\]
<p>次に \(\bar 1\) を考える. このゲームでは選択肢は特に無く, 一個取り除いて \(\bar{0}\) にすることしかできない.</p>
\[\bar 1 = \{ \bar 0 \} = \{\{\}\}\]
<p>他も同様で,</p>
\[\bar 2 = \{ \bar 1 \} = \{\{\{\}\}\}\]
<p>といった具合.</p>
<h3>性質</h3>
<p>不偏ゲームの定義から次が言える.</p>
<ul>
  <li>\(\{\} \in \G\)</li>
  <li>\(g \in G\) は有限集合</li>
</ul>
<p>これは不偏ゲームが有限ステップで終了することを言っている. 特に \(\{\}\) はこれ以上打てる手が無いような局面のことを言っているので <strong>最終局面</strong> と呼ぶことにする. これを初期状態にするゲームは当然初めから何もできないので, 先手は何も出来ずに負け, 後手必勝のゲームだと言える.</p>
<h2>グランディ数</h2>
<p>不偏ゲームは先手/後手のどちらが必勝かが予め決まっている. これを調べるにあたって <strong>グランディ数</strong> という道具が大変便利である. これはニム数, Grundy value, Nim value, Nimber, Energy など様々な呼ばれ方をすることもある.</p>
<p>グランディ数とは不偏ゲーム \(g\) を自然数（ \(0\) 以上の整数）に写す写像, またはその写した先の値のことを言う.</p>
\[g: \mathcal{G} \to \mathbb{N}\]
\[g(G) = \mex \{ g(G&#x27;) : G&#x27; \in G \}\]
<p>ここで \(\mex\) とは, 最小除外数 (minimum exclusion) などと呼ばれるもので, \(\mex T\) ( \(T\) は自然数の部分集合) とは, \(T\) に含まれない自然数の中で最小の数のことである. \(\mex T = \min(\mathbb{N} \setminus T)\) と言ってもいい.</p>
<p>例えば</p>
<ul>
  <li>\(\mex \{\} = 0\)</li>
  <li>\(\mex \{0\} = 1\)</li>
  <li>\(\mex \{0, 1, 3\} = 2\)</li>
</ul>
<p>定義から, \(G\) が最終局面ならば, \(g(G) = \text{mex }\{\} = 0\) である.</p>
<h3>例. 自明石取りゲーム</h3>
<p>先程のちょうど一個の石を取り除くだけのゲームでは次のようになる.</p>
<ul>
  <li>\(\mex \bar 0 = 0\)</li>
  <li>\(\mex \bar 1 = 1\)</li>
  <li>\(\mex \bar 2 = 0\)</li>
  <li>\(\mex \bar 3 = 1\)</li>
  <li>\(\mex \bar 4 = \vdots\)</li>
</ul>
<h3>例. 制限付き石取りゲーム</h3>
<h4>ルール</h4>
<p>取れる石の数に制限を設けた Nim を考える.</p>
<p>山に \(N\) 個の石がある. プレイヤーが行える操作は \(1\) 個以上 \(3\) 個以下の石を取ることである. これを交互に行い, 先に手が打てなくなった方の負け (つまり最後の一個を取れば勝ち).</p>
<h4>グランディ数</h4>
<p>石が \(N\) 個あるゲームを \(\bar{N}\) とすると,</p>
<ul>
  <li>\(\bar{0} = \{\}\)</li>
  <li>\(\bar{1} = \{ \bar{0} \}\) ( \(= \{\{\}\}\) )</li>
  <li>\(\bar{2} = \{ \bar{0} , \bar{1} \}\)</li>
  <li>\(\bar{3} = \{ \bar{0} , \bar{1} ,\bar{2} \}\)</li>
  <li>\(\bar{k} = \{ \bar{k-3} , \bar{k-2} , \bar{k-1} \}\) ( \(k &gt; 3\) )</li>
</ul>
<p>これらに対して, グランディ数 \(g\) を計算すると次のようになる.</p>
<ul>
  <li>\(g(\bar{0}) = \text{mex }\{\} = 0\) ,</li>
  <li>\(g(\bar{1}) = \text{mex }\{0\} = 1\) ,</li>
  <li>\(g(\bar{2}) = \text{mex }\{0,1\}=2\) ,</li>
  <li>\(g(\bar{3}) = \text{mex }\{0,1,2\}=3\) ,</li>
  <li>\(g(\bar{4}) = \text{mex }\{1,2,3\}=0\) .</li>
</ul>
<p>簡単に次のような事実に気附く:</p>
\[g(\bar{n}) = n \bmod 4\]
<p>更に石の数の制限を 1 個以上 \(k\) 個以下とするとき,</p>
\[g(\bar{n}) = n \bmod (k+1)\]
<p>と出来そう. 制限なし (いくつでも取っていい) なら, \(k=\infty\) とすることで,</p>
\[g(\bar{n}) = n\]
<p>を得る.</p>
<h3>定理</h3>
<p><div class=thm> 不偏ゲーム \(G\) のグランディ数 \(g\) が \(g(G)=0\) のとき, またそのときに限り, ゲーム \(G\) は後手必勝である. </div></p>
<p>ゲームのグランディ数が \(0\) である状態を考える.</p>
<ol>
  <li>\(G=\{\}\) のとき, これは最終局面であるので後手必勝であるし \(g(G)=0\) である.</li>
  <li>\(G \ne \{\}\) のとき, 先手には打てる手があるので, 先手は \(G&#x27; \in G\) に写したとする.</li>
</ol>
<p>\(g(G)=0\) より \(g(G&#x27;)&gt;0\) . \(g(G&#x27;)&gt;0\) より \(G&#x27; \ne \{\}\) であることと, \(\exists G&#x27;&#x27; \in G&#x27;, g(G&#x27;&#x27;)=0\) が分かる. 即ち, 先手がどのような手を打っても, 後手はゲームのグランディ数を再び \(0\) にできる.</p>
<p>後手はゲームのグランディ数を常に \(0\) になるような手を打ち続けることで, いつかは \(G=\{\}\) にでき勝てる (千日手は無いと仮定している).</p>
<h2>ゲーム和 (直和) とそのグランディ数 (ニム和)</h2>
<p>しばしばゲームはより簡単なゲームに分解でき, それらの和とすることで簡単に考えることが出来る. 典型的な例は複数山の Nim である. 一山からなる Nim の直和だと見做すことが出来る.</p>
<h3>ゲーム和の定義</h3>
<p>ゲーム \(G\) と \(H\) の和 \(G + H\) とは, その2つを並べて, プレイヤーは \(G, H\) の内一つを自由に選んで手を打つようなゲームのことである. どちらともに最終局面の場合に限って, 和も最終局面だとする.</p>
<p>形式的には次のように再帰的に定義する.</p>
<ul>
  <li>\(G+\{\} = G\)</li>
  <li>\(\{\}+H = H\)</li>
  <li>\(G+H = \{ G&#x27;+H : G&#x27; \in G \} \cup \{ G+H&#x27; : H&#x27; \in H \}\)</li>
</ul>
<p>特にこの三式目が再帰的定義となっているので註意.</p>
<p>この二項演算子を用いることで \(G_1 + G_2 + \cdots + G_n\) が定義出来る.</p>
<h3>ニム和</h3>
<p>グランディ数 \(g(G), g(H)\) が明らかな時 \(g(G+H)\) を容易に計算することが出来,</p>
\[g(G+H) = g(G) \oplus g(H)\]
<p>と書ける. この \(\oplus\) をニム和という.</p>
<p>ニム和の具体的な計算であるが, これは実はグランディ数 (自然数) を bit 表現したときの <a href="https://ja.wikipedia.org/wiki/排他的論理和#.E3.83.93.E3.83.83.E3.83.88.E3.81.94.E3.81.A8.E3.81.AE.E6.8E.92.E4.BB.96.E7.9A.84.E8.AB.96.E7.90.86.E5.92.8C">排他的論理和</a> となっている.</p>
<p>\(n\) 個のゲーム和のグランディ数も, 同じ \(\oplus\) を用いて</p>
\[g(G_1,G_2,..,G_n) = g(G_1) \oplus g(G_2) \oplus \ldots \oplus g(G_n)\]
<p>で与えられる.</p>
<h3>2つ山の制限付き Nim (石取りゲーム)</h3>
<p>2つの山があって, それぞれ \(n\) 個, \(m\) 個の石からなる. プレイヤーは交互に, 1つの山を選んで石を取る. 先ほどと同様に, 取る石の数は1個以上3個以下と制限する. 手が打てなくなったら負け (最後の最後の一個を取ったら勝ち).</p>
<p>局面の状態は \((n,m)\) で表せるので先ほどと同様に \(\bar{(n,m)}\) と書くことにする. 終盤局面は \(\bar{(0,0)}\) である.</p>
<p>愚直にグランディ数を計算するには先ほどと同様に, \(\bar{(0,0)}\) から \(\bar{(4,4)}\) くらいまでのグランディ数を愚直に計算すれば良い.</p>
<p>二次元のテーブルの上でグランディ数を具体的に書きだしてみると, 周期性が見えて, やはりなんとなく分かるが, 先ほどのニム和の性質が満たされていることも確認できる. すなわち,</p>
\[g \bar{(n,m)} = g(\bar{n}) \oplus g(\bar{m})
= (n \bmod 4) \oplus (m \bmod 4)\]
<p>である.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>