<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Language Identification in the Limit</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../../../../../resources/css/c.css">
  <link rel="stylesheet" href="./c.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Language Identification in the Limit</h1>
</header>
<section>
<div class="author">
Gold
</div>
<div class="title">
Language Identification in the Limit
</div>
<div class="public">
Information and Control 10 (1967)
</div>
</section>
<h1 id="動機-子供の言語学習">動機: 子供の言語学習</h1>
<p>正しい例 (instance) を子供は逐次的に受け取ることで子供は言語を学習していく. これをモデルにしたAIを考えようというのが動機である.<br />
また実際の子供の場合は学習結果として自分で作文を行い, 結果正しい文を発話できたか否かを相手の反応から学習し, それからなんらかの形で修正を加えるかもしれない.</p>
<h1 id="言語の同定モデル">言語の同定モデル</h1>
<p>言語の学習モデルを考える</p>
<ol class="incremental" type="1">
<li>学習の定義</li>
<li>情報提示の方法</li>
<li>名付け関係 (naming relation)</li>
</ol>
<p>以上が、モデルに必要である.</p>
<p>3つめは言語自体を区別する行為である. 一つの文を与えられたときにそれが英語か日本語かを区別するみたいな?</p>
<p>情報提示の方法として、こうする<br />
まず時間とは有限時間から始まり量子化されたものだとする<br />
つまり <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">t=1,2,3,...</annotation></semantics></math> と書くもの</p>
<h2 id="学習可能性">学習可能性</h2>
<p>毎時間、未知の言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> に関する情報が提示される <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>i</mi><mn>1</mn></msub><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>,</mo><msub><mi>i</mi><mn>3</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">i_1, i_2, i_3,...</annotation></semantics></math></p>
<p>学習という行為を手続き<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>とすると, 今までに提示された情報全てを用いて <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>t</mi></msub><mo>=</mo><mi>G</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>i</mi><mn>1</mn></msub><mo>,</mo><msub><mi>i</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><msub><mi>i</mi><mi>t</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">g_t = G(i_1, i_2, \ldots i_t)</annotation></semantics></math> これを推測 (guess; guessing) という. ただし推測するのは言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の名前である</p>
<p>さて「極限における同定」とは、<br />
十分時間の経った時間以降、推測が同じになることである</p>
<p>また、「極限において同定可能」とは、<br />
効率的な <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> が存在することである</p>
<p>極限であることの意味として、一つ挙げられている.<br />
学習者は自分がいつ正しく言語を学習できているかを知る必要はないのである</p>
<h2 id="情報提示">情報提示</h2>
<p>提示される情報として2種類を考える. text と informant である. それぞれ次のように定められるもの</p>
<p>text とは、言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> から得られる文字列の列 <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">x_1, x_2, ...</annotation></semantics></math> のこと. 時刻 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math> において文字列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">x_t \in L</annotation></semantics></math> を提示するわけ</p>
<p>さらに text に中でも3つクラスを定義することにする</p>
<ol class="incremental" type="1">
<li>Arbitary Text: 任意の関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x_t = f(t)</annotation></semantics></math></li>
<li>Recursive Text: 再帰関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x_t = f(t)</annotation></semantics></math></li>
<li>Primitive Recursive Text: 原始再帰関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>t</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x_t = f(t)</annotation></semantics></math></li>
</ol>
<p>さて一方で、 informant とは 文字列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>t</mi></msub><mo>∈</mo><msup><mi>A</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">y_t \in A^+</annotation></semantics></math> についてそれを提示するとともに <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> に含まれるか否かを提示する</p>
<ol class="incremental" type="1">
<li>Arbitary informant: 提示する文字列は任意の関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>t</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y_t = f(t)</annotation></semantics></math> と表されるもの</li>
<li>Methodical informant: 文字列は事前に列挙されていて逐次的に前から提示される</li>
<li>Request informant: 学習者が <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>t</mi></msub><annotation encoding="application/x-tex">y_t</annotation></semantics></math> を選ぶ</li>
</ol>
<h2 id="naming-relation">naming relation</h2>
<ol class="incremental" type="1">
<li>tester</li>
<li>generator</li>
</ol>
<p><code>tester</code> は文字列が渡されてそれが言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> に属するかどうかを判定するもの</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tester ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p><code>generator</code> は実際に言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> を生成するもの</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">generator ::</span> <span class="dt">IO</span> [<span class="dt">String</span>]</code></pre></div>
<h2 id="等価性">等価性</h2>
<h3 id="学習モデルの等価性">学習モデルの等価性</h3>
<p>ちょうど同じ言語族についてどちらであっても正しく 極限において同定するとき、 等価なモデルだとする</p>
<h3 id="naming-relations-の等価性">naming relations の等価性</h3>
<p>任意の情報提示についてそれぞれの naming relation を用いた学習モデルが等価</p>
<h3 id="情報提示の等価性">情報提示の等価性</h3>
<p>任意の naming relations を用いた学習モデルが等価であること</p>
<p>極限同定 (identification in the limit) とはパターン認識 (the pattern recognition literature) の枠組みでしばしば使われる [Aizerman+, 1964]. 学習者は、ステップごとに未知の object を渡されて、その名前を推測する. 有限の時間で持って、いつかは学習を完了し、 それ以降は常に、正しい推測が出来るようになる.</p>
<p>有限同定 (finite identification) とは、普通に同定と言ったときに用いられる枠組みである. 最も有名なのはオートマトン理論 [Gill, 1961] であろう. 学習者は、情報の提示を十分受け取ったと思ったら、 そこで提示を受諾を打ち止めなければならない.</p>
<p>固定時間同定 (fixed-time identification) とは、予め与えられる情報の量 (時間、ステップ数) が固定されて有限であること.</p>
<p>ある object の class が極限同定可能であるとは、 何でもいいけど、効率的な推定アルゴリズム <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math> が存在すること. 効率を無視する場合は 非効率に極限同定可能 (ineffectively identifiable in the limit) だという.</p>
<p>情報提示の(無限)列 (information string) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>i</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{i\}</annotation></semantics></math> としてあり得るものの集合を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>I</mi><mi>∞</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>ω</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">I^\infty(\omega)</annotation></semantics></math> と書く. 一つの情報提示列は、ただ一つの object を表現するものである. このようなとき、区別可能 (distinguishability) という.</p>
<p>collapsing uncertainty condition: よく分からん</p>
<h1 id="極限同定の方法">極限同定の方法</h1>
<h1 id="非効率的な極限同定の方法">非効率的な極限同定の方法</h1>
<h1 id="text提示の弱さ">text提示の弱さ</h1>
<h1 id="学習時間">学習時間</h1>
<h1 id="generator-から-tester-への変換">generator から tester への変換</h1>
<h1 id="帰納推論">帰納推論</h1>
</body>
</html>
