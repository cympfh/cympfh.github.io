<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>微分可能多様体の定義から接写像まで</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">微分可能多様体の定義から接写像まで</h1>
<p><p class=date style='text-align: right'>2017-05-06 (Sat.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#幾何学>幾何学</a> <a class='tag is-red' href=index.html#微分幾何>微分幾何</a> </div></p>
<p>\(\require{amscd}\)</p>
<p>おさらいをやっていく.</p>
<h2>微分可能多様体の定義</h2>
<p>微分可能多様体とは次のように定義する図形のことである.</p>
<p><div class=thm> ある位相空間 (ハウスドルフ空間であること) と、ある自然数 \(n\) があって、空間の上の開集合の族</p>
\[\{U_i\}_{i \in I}\]
<p>がある. \(U_i\) は一般には無限個あることを想定する. 各 \(U_i\) に対しては写像</p>
\[\varphi_i : U_i \to \mathbb{R}^n\]
<p>が定められているものとする. ここで \(\mathbb{R}^n\) は \(n\) 次元ユークリッド空間のこと.</p>
<p>ここで次のような性質 (微分可能性) を要請する:</p>
\[U_i \cap U_j \ne \emptyset \Rightarrow
\varphi_i \circ \varphi_j^{-1} ~\text{is}~ C^r \text{-class }\]
<p>大抵は \(C^\infty\) 級のことを考える (簡単なので). またここでは、式を簡単にするために単に合成関数として書いているが、 実際は \(\varphi_i\) の入力を \(U_i \cap U_j\) に制限するために \(\varphi_j^{-1}\) の定義域を制限する必要があるが、省略した.</p>
<p>以上の時、</p>
\[\{ (U_i, \varphi_i) \}_{i \in I}\]
<p>によって図形を表現し、これを \(n\) <strong>次元微分可能多様体</strong> と呼ぶ. </div></p>
<p>各 \(U_i\) のことを近傍とかいう. 特に \(x \in U_i\) の関係のとき「 \(U_i\) は \(x\) の (一つの) 近傍である」とかいう. また \(\varphi_i\) のことを \(U_i\) の局所座標という. 実際、単に位相空間にすぎない \(U_i\) に \(n\) 次元の座標を与えている.</p>
<h2>接ベクトル</h2>
<h3>多様体上の曲線</h3>
<p>適当な開区間から多様体への写像のことを多様体上の曲線と定める. 区間はなんでも良いがここでは \([-\epsilon, \epsilon]\) ということにする. すなわち多様体 \(M\) 上の曲線 \(c\) とは</p>
\[c: [-\epsilon, \epsilon] \to M\]
\[c: (-\epsilon \leq t \leq \epsilon) \mapsto (x \in M)\]
<blockquote><strong>N.B.</strong> \(x \in M\) と書いた場合の \(M\) は点の集合としての図形であって、 \(x\) は図形の中のある一つの点のことである. 先の定義に従って忠実に述べると \(x\) とは、ある \(i\) があって \(x \in U_i\) である.</blockquote>
<h3>点 \(x\) の接ベクトル</h3>
<p>\(M\) のある点 \(x\) の接ベクトルを定義する. 話をすっ飛ばすと、 \(x\) の接ベクトルとは \(x\) を通る曲線のことである (これは正確ではない). 便宜上、 \(0 \in [-\epsilon, \epsilon]\) を \(x\) に写すものに限ることにする (ここは本質ではない).</p>
\[c: [-\epsilon, \epsilon] \to M\]
\[c(0) = x\]
<p>ある \(i\) があって \(x \in U_i\) なわけだが、定義域 (すなわち \(\epsilon\) ) を十分小さくすることで、 \(c\) の値域が \(U_i\) に完全に含まれることにしておく. \(U_i\) に寄り添って局所座標 \(\varphi_i\) があるわけだが、これは点 \(x\) に対して一つ決めればいいだけなので、 添字を無視して単に \(\varphi\) とだけ書く.</p>
<p>なんやかんやあって曲線そのものを接ベクトルと見做すのは都合が悪いので、次のような写像</p>
\[\varphi^* : \mathcal{C}_x \to \mathbb{R}\]
\[\varphi^*(c) = \frac{d \varphi \circ c}{dt}(t=0)\]
<p>を使って同値関係を定めるのが良い. ここで \(0 \mapsto x\) な曲線全体のことを \(\mathcal{C}_x\) と書いた.</p>
<blockquote><strong>N.B.</strong> \(t=0\) での微分値を求めてるのは、今、 \(t=0\) で \(x\) を通ると仮定しているからであって、一般にはその値を代入する.</blockquote>
<p>すなわち、</p>
\[c \sim c&#x27;  \overset{\text{def}}{\Longleftrightarrow} \varphi^*(c) = \varphi^*(c&#x27;)\]
<p>なる曲線同士の同値関係 \(\sim\) を定める.</p>
<p>この同値関係は \(\phi_i\) を (もしあるならば) \(\phi_j\) と取り替えても不都合がないという点で都合がよい.</p>
<p>\(\mathcal{C}_x&#x2F;\!\sim\) のことを \(T_xM\) と書いて <strong>接空間</strong> と呼ぶ. 接空間の元を ( \(x\) の上の) <strong>接ベクトル</strong> という.</p>
<h3>接空間はベクトル空間である</h3>
<p>接空間は足し引き、スカラー倍ができる空間である. それは曲線の足し引きとスカラー倍から類推できるだろう.</p>
<ul>
  <li>
    \(u, v \in T_xM\) について
    <ul>
      <li>\(au + bv = \lambda t. au(t) + bv(t)\) ( \(a, b\) は実数)</li>
    </ul>
  </li>
</ul>
<p>というわけで、接空間といったとき、暗にベクトル空間としての性質を仮定することにする. その方が便利なので.</p>
<p><div class=thm> 接空間の基底ベクトルは実は次のようである.</p>
<p>\(m\) 次元多様体 \(M\) 上のある点 \(x\) 上の接空間 \(T_xM\) の基底ベクトルは、 \(m\) 次元ユークリッド空間の基底ベクトルを</p>
\[e_1, e_2, \ldots, e_m\]
<p>としたとき、</p>
\[c_i = \lambda t.~ \varphi^{-1}(t e_i) ~~(i=1,2,\ldots,m)\]
<p>である (すなわち接空間は \(m\) 次元ベクトル空間である).</p>
<p>これは基底の一つのとり方に過ぎないわけだが、このとり方の便利さは次の性質にある:</p>
\[\varphi^*(c_i) = e_i\]
<p>これは \(\varphi^*\) の全射性を示すのにも使われる. </div></p>
<h2>多様体の上の写像</h2>
<p>ユークリッド空間そのものが多様体の一例であることを考えると、 曲線はある多様体からある多様体への写像の例になっている.</p>
<p>\(m\) 次元多様体 \(M\) から \(n\) 次元多様体 \(N\) への写像</p>
\[F: M \to N\]
<p>とは、(普通に) \(x \in M\) を \(y \in N\) に写す写像のことである.</p>
<p>普通、大抵、どんな写像でも良いとするわけではなくて、ここでは連続な写像 \(F\) のことを考えたい. 連続であることを \(C^r\) 級 (すなわち微分可能性) で表現したい. しかし、 \(F\) の定義域/値域は単に位相空間の上の図形にすぎないので微分をすることはできない.</p>
<p>(常套手段であるが) このために \(M, N\) には局所座標が設けられている. すなわち、次のようにする.</p>
<p><div class=thm> まずある点 \(x \in M\) の周りで微分可能であることを調べる. \(x\) の近傍 \(U_i\) を持ってきて、その中の十分小さい領域 \(U&#x27;\) を取って</p>
\[F : U&#x27; (\subseteq U_i) \to V&#x27; (\subseteq V_j)\]
<p>に制限する. \(F\) の両端にそれぞれの局所座標 ( \(U_i\) に対して \(\varphi_i\) 、 \(V_j\) に対して \(\psi_j\) ) を合成することで</p>
\[\psi_j \circ F \circ \varphi_i^{-1} : \mathbb{R}^m \to \mathbb{R}^n\]
<p>を得る. これはおなじみの実関数であるので自由に微分が可能. これが \(C^r\) 級であるとき、 \(F\) は \(x\) の周りで \(C^r\) 級であると定義する.</p>
<p>全ての \(x \in M\) の周りで \(F\) が \(C^r\) 級であるとき、 \(F\) 自体を単に \(C^r\) 級であると定義する. </div></p>
<h2>接写像</h2>
<h3>Introduction</h3>
<p>さて考える.</p>
<ul>
  <li>\(M\) を \(m\) 次元多様体、</li>
  <li>\(N\) を \(n\) 次元多様体とし、</li>
  <li>\(C^\infty\) 級の写像 \(F: M \to N\) があるとする.</li>
</ul>
<p>\(M\) 上のある点 \(x\) を通る曲線の集合 \(\mathcal{C}_x\) があって、そこに同値関係を導入したものが \(T_xM\) であった.</p>
<p>写像 \(F\) は \(x\) を \(y = F(x)\) に写すとする.</p>
<p>写像 \(F\) は点を点に写すものであるが、曲線の像に注目すれば、 \(M\) 上の曲線を \(N\) 上の曲線に写すことができる. 曲線とは写像のことであったが、写像の像を更に移せばよい. それはつまり関数合成のことである.</p>
<ul>
  <li>\(M\) 上の曲線 \(c \in \mathcal{C}_x\) に対して</li>
  <li>\(c&#x27; = F \circ c\) は \(N\) 上の曲線である.</li>
  <li>\(c\) が \(t=0\) で \(x\) を通るような曲線であったことに対して、</li>
  <li>
    \(c&#x27;\) は \(t=0\) で \(y\) を通るような曲線である.
    <ul>
      <li>すなわち \(c&#x27; \in \mathcal{C}_y\) .</li>
    </ul>
  </li>
</ul>
\[\begin{CD}
M   @&gt;F&gt;&gt;  N     \\
@.       @.  \\
C_x   @&gt;F \cdot c&gt;&gt;  C_y     \\
@.       @.  \\
T_xM   @&gt;?&gt;&gt;  T_yN    \\
\end{CD}\]
<p>以上話したことを一言で述べると、 写像 \(M \to N\) から写像 \(\mathcal{C}_x \to \mathcal{C}_y\) を導いた. では、これを \(\sim\) で割って \(T_xM \to T_yN\) を導くことはできるだろうか?</p>
<h3>同値類の写像</h3>
<p><div class=thm> ある関数 \(f: X \to Y\) がある. \(X, Y\) 上の同値関係 \(\sim\) によって関数</p>
\[f&#x27; : X&#x2F;\!\sim \to Y&#x2F;\!\sim\]
<p>を自然に導くとは、次のように関数 \(f&#x27;\) を定められること.</p>
<ol>
  <li>\(f&#x27;([x]) = [f(x)]\) (写像の構成)</li>
  <li>\(x \sim x&#x27;\) のとき \(f&#x27;([x]) \sim f&#x27;([x&#x27;])\) (同値関係の保存)</li>
</ol>
<p>ただしここで \(x \in X, y \in Y\) に対してそれらの代表元を \([x] \in X&#x2F;\!\sim, [y] \in Y&#x2F;\!\sim\) と書いた. </div></p>
<p>「導くことはできるか」を確認するにはこれを確認すればよい. すなわち、</p>
\[F \circ c :~ \mathcal{C}_x \to \mathcal{C}_y\]
<p>から</p>
\[T_xM \to T_yN\]
<p>を自然に導くことはできるか??</p>
<h3>関手</h3>
<p>もし導くことができるのなら、 \(T\) (添字とか細かいことは気にしないで) というのは次のようなオペレータと見做せないだろうか. すなわち、 定義域の \(M\) を \(T_xM\) に写し、 値域 \(N\) を \(T_yN\) に写し、 写像 \(F: M \to N\) を \(T_xM \to T_yN\) に写す.</p>
<p>こうなると、写像 \(F\) を写した先の写像のことは \(T_xF\) と書くのが妥当に思えてくる. (この文書の中においてはほんと添字はあんま気にせんで.)</p>
\[\begin{CD}
M   @&gt;F&gt;&gt;  N     \\
@VVV       @VVV  \\
T_xM   @&gt;T_xF&gt;&gt;  T_yN    \\
\end{CD}\]
<blockquote>この上から下への矢印は本来は射じゃなくて関手. 許して.</blockquote>
<p>先章まで述べてきたことを言い直すと、こうだ. 接空間を考えることで、 写像 \(F\) から \(T_xF\) を導くことはできるだろうか???</p>
<h3>やっていく.</h3>
<p>出来る.</p>
<p>具体的な写像の構成は、次のようである. 代表元を取る操作とかはいちいち書かないが、察して.</p>
\[T_xF : T_xM \to T_y N\]
\[T_xF(u) = (F \circ c)(u)\]
<p>次に同値性を保存していることを確認する.</p>
<p>\(u \sim v\) を仮定する. \(u, v\) は \(T_xM\) の元なので \(M\) の上の適当な局所座標を取って定義される \(\varphi^*: U_i \to \mathbb{R}\) によって同値性は定義される. すなわち \(\varphi^*(u) = \varphi^*(v)\) である.</p>
<p>このときに、</p>
\[T_xF(u) \sim T_xF(v)\]
<p>であることを確認できればよい. \(T_xF(u), T_xF(v)\) は \(T_yN\) の元であるので、そこでの適当な局所座標から定義される関数 \(\psi^*\) によって同値性を確認する必要があることに註意.</p>
<p>すなわち、</p>
\[\psi^*(F \circ u) = \psi^*(F \circ v)\]
<p>を確認したい.</p>
<p>やっていく:</p>
\[\begin{align*}
\psi^*(F \circ u)
&amp; = \frac{d \psi \circ F \circ u}{dt}(0) \\
&amp; = \frac{d \psi \circ F \circ \varphi^{-1} \circ \varphi \circ  u}{dt}(0) \\
&amp; = \frac{d \psi \circ F \circ \varphi^{-1}}{d x}(x=x_0) \cdot \frac{d \varphi \circ  u}{dt}(t=0)
\\
\end{align*}\]
<p>最後の式変形では微分のチェーンルールを用いている. また、 分母の \(dx\) は \(M\) の局所座標 ( \(\varphi\) の値域) 上での微分であって、 \(x_0 = \varphi(u(0))\) としている. これは \(\psi \circ F \circ \varphi^{-1}\) が実関数であるから書けることに註意. 同様に \(\varphi \circ u\) も実関数であるからこれも \(t\) で微分できている.</p>
<p>さて今、 \(\varphi^*(u) = \varphi^*(v)\) を仮定しているので、 \(\frac{d \varphi \circ  u}{dt}(t=0) = \frac{d \varphi \circ  v}{dt}(t=0)\) である. 従って、</p>
\[\begin{align*}
\psi^*(F \circ u)
&amp; = \frac{d \psi \circ F \circ \varphi^{-1}}{d x}(x=x_0) \cdot \frac{d \varphi \circ  u}{dt}(t=0) \\
&amp; = \frac{d \psi \circ F \circ \varphi^{-1}}{d x}(x=x_0) \cdot \frac{d \varphi \circ  \color{red}{v}}{dt}(t=0) \\
\end{align*}\]
<p>加えてこの一項目の \(\frac{d \psi \circ F \circ \varphi^{-1}}{d x}(x=x_0)\) が、もはや \(u, v\) に依存してないことに註意すれば、結局</p>
\[\begin{align*}
\psi^*(F \circ u)
&amp; = \psi^*(F \circ v)
\end{align*}\]
<p>となる. というわけで同値性の保存が成立していることが確認できた.</p>
<p>以上で、 写像 \(F\) から \(T_xF\) を導けることが示された. この \(T_xF\) のことを <strong>接写像</strong> という.</p>
<blockquote>\(T_xF\) と書いてはいるが、どの \(x\) についても導けるので、記号に \(x\) を入れる必要はないだろう. 関手として見做すとき、これは共変であるので、 接写像 \(F_*\) と書くことが多い.</blockquote>
<h2>接写像の行列表示</h2>
<p>接写像はベクトル空間 \(T_xM\) から ベクトル空間 \(T_yN\) への写像であるから、 写す値をベクトル表示することで、関数 \(T_xF\) を行列表示することができるはずである. やっていく.</p>
<p>具体的には基底がどう写るかを調べる.</p>
<ul>
  <li>\(c_i = \lambda t.~ \varphi^{-1}(te_i)\)</li>
  <li>\(\varphi^*(c_i) = \left. \frac{d}{dt} \varphi(\varphi^{-1}(te_i)) \right|_{t=0} = e_i\)</li>
</ul>
<p>ただし \(e_i = (0, \ldots, 0, 1, 0, \ldots, 1) \in \mathbb{R}^m\) (または \(\mathbb{R}^n\) ). これを \(T_xF\) で写す</p>
<ul>
  <li>\(T_xF(c_i) = F \circ c_i\)</li>
  <li>\(\psi^*(F \circ c_i) = \left. \frac{d}{dt} \psi(F (\varphi^{-1} (te_i))) \right|_{t=0}\)</li>
</ul>
<p>ここで \(\psi \circ F \circ \varphi^{-1}\) という関数は \(F\) を通して \(M\) の上の局所座標 \((x_1, x_2, \ldots, x_m)\) から \(N\) 上局所座標 \((y_1, y_2, \ldots, y_n)\) へ写しているものだと解釈できる.</p>
\[(y_1, y_2, \ldots, y_n) = (F_1(x_1), F_2(x_2), \ldots, F_n(x_n))\]
<p>しかも \(x\) の上の \(e_i\) 方向に (i.e. \(x_i\) 成分を) 動かしたときの微分値であるから、これは、 \(F\) を \(x_i\) で偏微分した値だと言える. したがって、</p>
\[\frac{d}{dt} \psi(F(\varphi^{-1}(x_1, x_2, \ldots, x_m))) =
\left(
\frac{\partial F_1}{\partial x_i},~
\frac{\partial F_2}{\partial x_i},~
\ldots,~
\frac{\partial F_n}{\partial x_i} \right)\]
<p>というわけで、</p>
\[\psi^*(F \circ c_i) =
\left.
\left(
\frac{\partial F_1}{\partial x_i},~
\frac{\partial F_2}{\partial x_i},~
\ldots,~
\frac{\partial F_n}{\partial x_i} \right)
\right|_{x=x_0}\]
<p>となる.</p>
<p><div class=thm> さて、ベクトル表示をすることは、 \(\varphi^*, \psi^*\) で写すことに相当する. なぜなら今用いている基底ベクトル \(c_i \in T_xM\) は、 \(\varphi^*(c_i) = e_i (i=1,2,\ldots,m)\) となるようなものだからである.</p>
<p>これは \(N\) 上でも同様で、 \(\varphi^*(d_i) = e_i (i=1,2,\ldots,n)\) となるような \(d_i\) を \(T_yN\) の基底ベクトルと定める.</p>
<p>というわけで、 \(\sum_i a_i c_i\) は \(\varphi^*\) によって自然にユークリッド空間上の点 \((a_1, a_2, \ldots, a_m)\) に写せる.</p>
<p>逆に \((b_1, b_2, \ldots, b_m) \in \mathbb{R}^n\) を \(\sum_j b_j d_j\) に戻すことも容易だろう. </div></p>
<p>では先程求めた</p>
<ol>
  <li>\(\varphi^*(c_i) = \left. \frac{d}{dt} \varphi(\varphi^{-1}(te_i)) \right|_{t=0} = e_i\)</li>
  <li>\(\psi^*(F \circ c_i) =
\left.
\left(
\frac{\partial F_1}{\partial x_i},~
\frac{\partial F_2}{\partial x_i},~
\ldots,~
\frac{\partial F_n}{\partial x_i} \right)
\right|_{x=x_0}\)</li>
</ol>
<p>これらを \(T_xM, T_yN\) に引き戻すことをしよう.</p>
<ol>
  <li>\(\varphi^*(c_i) = e_i \mapsto c_i\)</li>
  <li>\(\psi^*(F \circ c_i) \mapsto \sum_{j=1}^n \left. \frac{\partial F_j}{\partial x_i} \right|_{x=x_0} d_j\)</li>
</ol>
<p>この一つ目から二つ目に \(F\) によって移されたわけである. \(\mapsto\) の左が行列表示で右が基底の線形結合の形で書き表したものである.</p>
<p>行列表示ができそうに思えてくる. すなわち、</p>
\[\left[ \begin{array}{c}
0\\ \vdots\\ 0\\ 1\\ 0\\ \vdots\\ 1
\end{array} \right]
\mapsto
\left.
\left[ \begin{array}{c}
\frac{\partial y_1}{\partial x_i} &amp;
\frac{\partial y_2}{\partial x_i} &amp;
\cdots,
\frac{\partial y_n}{\partial x_i}
\end{array} \right]
\right|_{x=x_0}\]
<p>というわけで \(F\) を次のように行列表示することができる.</p>
\[\left.
\left[ \begin{array}{c}
\frac{\partial y_1}{\partial x_1} &amp; \frac{\partial y_2}{\partial x_1} &amp; \cdots &amp; \frac{\partial y_n}{\partial x_1} \\
\frac{\partial y_1}{\partial x_2} &amp; \frac{\partial y_2}{\partial x_2} &amp; \cdots &amp; \frac{\partial y_n}{\partial x_2} \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
\frac{\partial y_1}{\partial x_m} &amp; \frac{\partial y_2}{\partial x_m} &amp; \cdots &amp; \frac{\partial y_n}{\partial x_m}
\end{array} \right]
~
\right|_{x=x_0}\]
<p>これはいわゆるヤコビアン ( \(DF\) ) のことである.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>