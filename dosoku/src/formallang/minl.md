# 極小言語戦略

## 参考文献

1.  T.Shinohara: "Polynomial Time Inference of Extended Regular Pattern Languages", 1991
    - Regular Pattern の minimal common genelization (mcg) を多項式時間で求める
1. Arimura+: "Finding Minimal Generalizations for Unions of Pattern Languages and its Application to Inductive Inference from Positive Data"
    - [www-ikn.ist.hokudai.ac.jp/~arim/papers/arimura_stacs94.pdf](http://www-ikn.ist.hokudai.ac.jp/~arim/papers/arimura_stacs94.pdf)
    - k-mmg を多項式時間で求める


## 概要

[汎化システム](generalization_system.html) によって作られる言語のいくつかは,
極小言語戦略と呼ばれる戦略で作る推論機械によって [正提示で極限同定可能](limit_identification.html)（単に推論可能という）.

## 正提示からの推論

今考えている問題は次のようなものである.

- 言語のクラス $\mathcal L$
    - これは既知
- 言語 $L^\* \in \mathcal L$
    - これは未知
- 正提示 $S \subset L$
    - これは初め空集合が与えられ, 逐次的に $s \in L^\*$ が与えられ $S$ に追加していく

$S$ から $L^\*$ を予測するという問題.

そして今, 言語クラスは汎化システム $(D, \preceq)$ で与えられているものとする.
すなわち, ある集合 $D$ と写像 $L$ があって
$$L : D \xrightarrow{\sim} \mathcal L$$
という同型対応がついている.
推論機械は言語を直接出力する代わりに description $d \in D$ を出力する.

## 無矛盾な推論

推論すべき真の description $p$ は
$L^\* = L(p)$
であるから
$$S \subseteq L(p)$$
を満たす.
この最後の包含が成り立っていることを「無矛盾である」とか「 $p$ は $S$ を被覆する」などと言う.

極限同定においては極限値が正しければよいので途中の推論ではどんなに誤っていてもよく,
従って上の意味で矛盾していてもよい.
しかし一つの戦略として, 常に無矛盾な推論をすることが妥当そうに見える.

## 極小言語戦略

極小言語戦略とは, 正提示に対して無矛盾な言語の内, 極小なものを推論結果として出力する手法を言う.
ここで極小であるとは, 言語の集合としての包含関係によって定まる順序に関する.
（最小とは限らないので極小であることに注意.）
そしてその極小な言語を **極小言語 (minimal language; minl)** と言う.

いくつかの汎化システムが成す言語クラスは実は極小戦略によって推論可能である.

> この戦略はすなわち, 無矛盾なものであればいくらでもありえるし特に $\top \in D$ といった自明なものもある中で,
> 集合の小ささと推論の良さと思おうという気持ちである.

$S$ から極小言語（その description）を出力する仮定を `MINL` とすれば極小言語戦略とは次のような擬似コードで表される:

```python
S = set()
g = None  # この時点の推論結果
while s = input():
    S.add(s)
    if s in L(g):
        guess(g)  # 更新の必要なし
    else:
        g = MINL(S)  # 更新
        guess(g)
```

## [正規パターン言語](generalization_system.html) は推論可能

この言語クラスは極小言語戦略を用いることで推論可能である.
正規パターン言語は消去不能と消去可能の2タイプがあったが, どちらでも推論可能である.
ただしアルファベットサイズは 3 以上あり, その汎化システムは完全であるものとする
$(L(p) \subseteq L(q) \iff p \preceq q)$.

### 正規パターン言語の極小言語戦略

そもそもこの正規パターン言語クラスについて極小言語を見つける方法があることを言う.

テキストの集合 $S$ が与えられた時, これを被覆する description 全体は
$$E = \{ p \mid S \subset L(p) \} = \{ p \mid \forall s \in S, s \preceq p \}.$$
この中で極小なものを与える $q \in E$ を探す.
（この $q$ のことを minimal common generalization という.）

言い直すと, 見つけたいのは $S$ に対して次のような $q$.

- $\forall s \in S, s \preceq q$ であって
- $p$ が同様に $\forall s \in S, s \preceq p$ を満たすなら
- $p \not\prec q$ であること

代入の前後でパターンの長さがどう変わるかを考えるとよい.

#### 定理

パターン $p$ についてその文字数（長さ）を $|p|$ と書く.
また $p$ の中に出現するアルファベットの数を $|p|_a$ と書くことにする.

$p \preceq q$ のとき

- 消去不能: $|p| \geq |q|$
- 消去可能: $|p|_a \geq |q|_a$

が成り立つ.

この定理は次の2つの事実を与える.

1. $s \preceq p$ を満たす $p$ は（同値なものを除いて）高々有限通りしかない
1. 極小言語を与える $p$ は長さが最小なもの

1つ目について.
消去不能なら話は簡単で, $s \preceq p \implies |s| \geq |p|$ である.
長さが $|s|$ のパターンは有限通りしかない
（アルファベットは定義より有限であり, また同値なものだけを考えれば変数も高々 $|s|$ 種類しかないとおもっていいので）.
従って $s \preceq p$ なる $p$ は $(|\Sigma| + |s|)^{|s|}$ 通り以下だと言える.
次に消去可能な場合だが, こちらはアルファベットの数は $|s|$ 以下であって, 変数はその前後に挟むだけなので全体で $2|s|+1$ の長さが最長（変数が連続で並ぶパターンは一つだけのものと同値）. 従って全体の長さについて同様に上限があり, そのようなパターンは有限通り.

2つめについて.
極小を与えるには $p \not\prec q$ が必要で, これは $|p| \not\lt |q|$ を導く（消去不能の場合）.
従って $E$ の中でその長さが最小のものが候補になる.
長さ最小が複数あった場合だが, 長さが同じで同値でないパターン同士は汎化関係になく順序がつかないのでどうでもいい（これは非自明な気がするが証明略）.

以上の中で候補となるパターンは有限通りでしかもその候補の集合も与えられている.
すなわち
$n=|s|$ とすれば
$$(\Sigma \cup \{x_1, x_2, \ldots, x_n \} )^n$$
である（消去不能の場合）.
この中で確かに $s \preceq q$ であって長さ最小のものを出力すればよい.

（このように任意の $S$ に対してそれを被覆する言語の候補が高々有限であるとき, その言語クラスは「有限の厚みを持つ」と表現する.
そして実は有限の厚みを持つ言語クラスはいつも正提示から推論可能である [Shinohara91].）

### 効率的な探索

今述べた方法では指数通りの候補を調べ上げる必要があり非効率的.
そんなことしなくてももっと簡単に見つかる.

#### 考察

- $S = \{$
    - 00*01*11
    - 11*01*11
    - 10*01*1
    - 00*01*01
- $\}$

直感的に $p = x01y$ が見えてくる.
なぜなら全て共通して $01$ が真ん中に出現するから.
最長共通部分列を見つければいいのでは?
あ、でもただし
[一般個数の列の最長共通部分列問題は NP-困難である](https://ja.wikipedia.org/wiki/%E6%9C%80%E9%95%B7%E5%85%B1%E9%80%9A%E9%83%A8%E5%88%86%E5%88%97%E5%95%8F%E9%A1%8C).
そこで longest ではなく maximal common subsequence を考える.
文字列の集合 $S$ に対して共通部分列全体を $CS(S)$ と書く.
maximal common subsequence とは $CS(S)$ の中で文字列をパターンと見た時の $\preceq$ に関する極大元のことである.
これを $MCS(S)$ と書くことにする.
$$s \in MCS(S) \iff s \in CS(S), (t \in CS(S) \implies s \not\prec t)$$

#### 補題

今 $s = (s_1, s_2, \ldots, s_k) \in MCS(S)$ だとする $(s_i \in \Sigma)$.
このとき, $s$ の各文字の間に適切に変数を挟んで出来るパターン $p$ が $S$ の minl を与える.

適切な変数の挟み方は次のような $k+1$ ステップで与えられる.

- とりあえず全部に変数を挟む
    - $q_0 = x_1 s_1 x_2 s_2 \cdots s_k x_{k+1}$
- 各変数について消せるだけ消す
    - $q_i = q_{i-1}[/x_i]$ if $S \subseteq L(q_i)$ ($[/x_i]$ は変数 $x_i$ の消去を表す)
    - $q_i = q_{i-1}$ otherwise
        - $i=1,2,\ldots,k$

これで得られる $q_{k+1}$ が minl を与える.

##### 証明

minl でないとすると, ある $q'$ ($q' \ne q_{k+1}$) があって
$$S \subseteq L(q') \subset L(q_{k+1})$$
である.
従って $q' \prec q_{k+1}$.
それぞれのパターンのアルファベット部分だけ取り出した文字列を
$c(q')$ などと書くと,
汎化関係より $c(q_{k+1})$ は $c(q')$ の部分列になっている.
一方で $c(q_{k+1})$ は $s$ であるし, また $s$ が $S$ の maximal common subsequence であることから, $c(q') = c(q_{k+1}) = s$.
つまり $q'$ に登場するアルファベットは $q_{k+1}$ と同様で $s_1, s_2, \ldots, s_k$ であることがわかった. $q'$ はこれにやはり変数を挟んだ形である.

さて $q' \prec q_{k+1}$ であったので, $q_{k+1}$ の変数に代入をすることで $q'$ は作れる.
変数にアルファベットを代入すると $c(q) \ne s$ になってしまうので駄目で, 変数に 0 個以上の変数を代入するしかない. 消去可能パターンでは 1 個以上の代入は同値なので
$q' \ne q_{k+1}$ のためにはどれかの変数を消去（空文字列の代入）するしかない.
変数消去の仕方を考えると次のパターンに分けられる.

1. そもそも変数が無い
    - $q_{k+1}$ は object なので instance を持たず矛盾
1. 全ての変数を消去する
    - $q'$ が object なので $S$ は単集合
    - そのような場合は作り方から $q_{k+1}$ も object (作る過程で全て変数を消去してる)
1. 消す変数と消さない変数がある
    - 初めて消す変数を $x_j$ とする ($x_j$ が $q_{k+1}$ にあるとして)
    - $q_{k+1}$ を作る途中の $q_{j-1}$ を考える
        - $q' \preceq q_{j-1}[/x_j]$
        - 従って $q_j$ を作るときに $x_j$ は消すハズ
        - 作り方に矛盾

各変数ごとに $S \subseteq L(q)$ を調べる必要があるが,
Aho らの ["The Design and Analysis of Computer Algorithms"](https://doc.lagout.org/science/0_Computer%20Science/2_Algorithms/The%20Design%20and%20Analysis%20of%20Computer%20Algorithms%20%5BAho%2C%20Hopcroft%20%26%20Ullman%201974-01-11%5D.pdf)
によれば, ちょうど $L(q)$ を受理する（つまり $q$ にマッチする）有限決定オートマトンを $O(|q|)$ で作ることができて, 全体として
$O(|q| + \sum_{s \in S} |s|)$
で検査出来る.

あとは MCS さえ効率的に求まればよい.

