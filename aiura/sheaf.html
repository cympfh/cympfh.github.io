<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>層</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">層</h1>
<p><p class=date style='text-align: right'>2017-11-12 (Sun.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#層>層</a> </div></p>
<h2>index</h2>
<p><div id=toc></div></p>
\[\def\O{\mathcal{O}}\]
<h2>前層 (preshaef)</h2>
<p>二通りの定義を与える.</p>
<h3>定義1</h3>
<p><div class=thm> 位相空間 \(X\) の <strong>前層</strong> とは、 集合 \(A\) , 関数 \(E: A \rightarrow \O(X)\) , 関数 \(\rceil: A \times \O(X) \rightarrow A\) ( \((a, U) \mapsto a \rceil U\) ) からなる三組 \((A, E, \rceil)\) であって次のようなもの.</p>
<ol>
  <li>任意の \(a, b \in A\) に対して \(a \rceil \emptyset = b \rceil \emptyset\)</li>
  <li>\(a \rceil Ea = a\) \(~~~\) (註意: \(\rceil\) の結合則は \(E\) の適用より弱い)</li>
  <li>\(E (a \rceil U) = E a \cap U\)</li>
  <li>\((a \rceil U) \rceil V = a \rceil U \cap V\) \(~~\) (註意: \(\cap\) の結合則のが \(\rceil\) より強い)</li>
</ol>
<p></div></p>
<h4>例</h4>
<p>関数の集合 \(A\) , 関数の定義域を与える手続き \(E\) , 普通の意味で関数の(定義域の)制限 \(\rceil\) .</p>
<p>註意すべき点として、層としての制限 \(\rceil\) の右項には \(Ef\) よりも広い集合を与えても構わないということ. 関数の制限 (これを区別する意味で \(\lceil\) と書く) の右項には普通、ドメインより小さい領域を与えるだろう. そこで次のように \(\rceil\) を定め直せばよい:</p>
\[f \rceil U := f \lceil (Ef \cap U)\]
<p>また、ドメインが空集合な関数は空集合ただ1つである.</p>
\[f \rceil \emptyset = \emptyset = g \rceil \emptyset\]
<p>ドメイン (定義域) が空集合であるような関数は <strong>存在しない</strong> しないのではなく, <strong>唯1つ</strong> 存在することに註意 (参考; <a href="https://ja.wikipedia.org/wiki/%E7%A9%BA%E9%96%A2%E6%95%B0">空関数</a> ).</p>
<blockquote>明らかに前層とはこれを抽象化したものである</blockquote>
<h3>定義2</h3>
<p><div class=thm> 位相空間 \(X\) の <strong>前層</strong> とは、 \(X\) の開集合を適当な集合の集合 \(\mathcal{A}\) に写すような</p>
\[F : \O(X) \to \mathcal{A}\]
<p>及び \(U,V \in \O(X)\) について \(U \subseteq V\) ならば</p>
\[r_{UV} : F(V) \to F(U)\]
<p>が定まっているようなもの. これらの \(\left(F, r = \{ r_{UV} : U, V \in \O(X) \}\right)\) を前層だという. ただし次を要請する.</p>
<ol>
  <li>\(F(\emptyset)\) は単集合</li>
  <li>\(r_{UU}\) は恒等写像</li>
  <li>\(U \subseteq V \subseteq W\) のとき \(r_{UW} = r_{UV} \circ r_{VW}\)</li>
</ol>
<p></div></p>
<p>こちらは圏論的に <strong>関手</strong> として前層を定義している (参考; <a href="http://cympfh.cc/taglibro/2018/07/17.html">前層はモノイド(右)作用の一般化</a> ).</p>
<p>これら2つの定義が等価であることを確認する.</p>
<h3>定義1 → 定義2</h3>
<p><div class=thm> 前層が \((A,E,\rceil)\) で与えられた時、次で定義2を構成できる.</p>
<ol>
  <li>\(F(U) = \{ f \in A : Ef = U \}\)</li>
  <li>\(r_{UV}(f) = f \rceil U\)</li>
</ol>
<p></div></p>
<p>要請を満たすことを確認する.</p>
<ol>
  <li>
    \(F(\emptyset) = \{ f : Ef = \emptyset \}\) は単集合か?
    <ul>
      <li>\(f = f \rceil (Ef)\) より \(f \in F(\emptyset) \Rightarrow f = f \rceil \emptyset\)</li>
      <li>
        \(F(\emptyset)\) が 2つ以上の要素をもって \(f,g\) がそうであるとき、
        <ul>
          <li>\(f = f\rceil \emptyset = g\rceil \emptyset = g\)</li>
          <li>従って、 \(F(\emptyset)\) は要素を高々1つしか持たない</li>
        </ul>
      </li>
      <li>
        また \(F(\emptyset)\) は空集合でもない
        <ul>
          <li>
            任意の \(a\) について
            <ul>
              <li>\(E(a \rceil \emptyset) = Ea \cap \emptyset = \emptyset\)</li>
            </ul>
          </li>
          <li>であるので、 \((a \rceil \emptyset) \in F(\emptyset)\)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    \(r_{UU}\) は恒等写像か?
    <ul>
      <li>明らか</li>
    </ul>
  </li>
  <li>
    \(r_{UW} = r_{UV} \circ r_{VW}\)
    <ul>
      <li>\(r_{VW} : F(W) \to F(V)\)</li>
      <li>\(r_{UV} : F(V) \to F(U)\)</li>
      <li>
        \(f \in F(W) = \{ f : Ef = W \}\) について
        <ul>
          <li>\(r_{VW}(f) = f \rceil V\)</li>
          <li>\((r_{UV} \circ r_{VW}(f) = (f \rceil V) \rceil U = f \rceil (V \cap U) = f \rceil U = r_{UV}(f)\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
<p>というわけでok.</p>
<h3>定義2 → 定義1</h3>
<p><div class=thm> 逆に前層が \((F, r)\) で与えられたとき、 先ほどの全く逆によって構成できる.</p>
<ol>
  <li>\(A = \bigcup_{U \in \O(X)} F(U)\)</li>
  <li>\(f \in F(U) \iff Ef = U\)</li>
  <li>
    \(f \rceil U = r_{VW}(f)\)
    <ul>
      <li>where \(V = U \cap W, W=Ef\)</li>
    </ul>
  </li>
</ol>
<p></div></p>
<p>要請を満たすことを確認する.</p>
<ol>
  <li>
    \(a,b \in A\) について
    <ul>
      <li>
        \(a \rceil \emptyset = r_{VW}(a)\)
        <ul>
          <li>
            ここで \(V = \emptyset, W = Ef = U_a\) で
            <ul>
              <li>\(r_{VW} : F(W) \to F(V)\)</li>
              <li>\(F(V)\) は単集合であるので、 \(r_{VW}\) は一点に写す関数</li>
            </ul>
          </li>
          <li>従って \(r_{VW}(a) = r_{VW&#x27;}(b)\)</li>
        </ul>
      </li>
      <li>よって \(a \rceil \emptyset = b \rceil \emptyset\)</li>
    </ul>
  </li>
  <li>
    \(f \rceil (Ef) = r_{VW} f\)
    <ul>
      <li>ただし \(V = Ef \cap W, W = Ef\)</li>
      <li>なので \(V=W\) なんで \(r_{VW}\) は恒等写像</li>
      <li>というわけで、 \(f \rceil (Ef) = f\)</li>
    </ul>
  </li>
  <li>
    \(f \rceil U = r_{VW}(f) \in F(V)\)
    <ul>
      <li>ここで \(V = U \cap Ef\)</li>
      <li>\(E(f \rceil U) = V = U \cap Ef\)</li>
    </ul>
  </li>
  <li>
    \((f \rceil U) \rceil V = f \rceil (U \cap V)\)
    <ul>
      <li>大体同様に</li>
    </ul>
  </li>
</ol>
<p>ところでしかし、この定義1と2とが本当に対応してるかを見るには、 定義1の前層を定義2に(上の方法で)した後、再び(上の方法で)定義1に戻して得た前層が、元の前層と同じ (あるいは同型) であることを確かめないといけない.</p>
<h2>両立 (compatible)</h2>
<p>前層 \(A\) の2つの元 \(f, g \in A\) が <strong>両立</strong> するとは、 <div class=thm></p>
\[f \rceil Eg = g \rceil Ef\]
<p></div> とあること.</p>
<p>関数集合の例でいうと、 定義域の交わる部分で関数の値が一致することを表す.</p>
<h2>層 (sheaf)</h2>
<p>やはり二通りの定義を与える.</p>
<h3>定義1</h3>
<p>\(X\) の上の前層 \(A\) が次を満たすとき、 \(A\) を \(X\) の上の <strong>層</strong> と呼ぶ.</p>
<p><div class=thm></p>
<ul>
  <li>
    \(\forall f,g \in F\) が両立するような \(F \subset A\) に対して、次の2つを成立させる \(g\) が唯一つ存在すること
    <ol>
      <li>\(\forall f \in F, g \rceil Ef = f\)</li>
      <li>
        \(Eg = \bigcup_{f \in F} Ef\)
        <ul>
          <li>このような \(g\) を \(F\) に対して \(\cup F\) と書く</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>
<p></div></p>
<h4>例</h4>
<p>前に述べた関数の例は層である</p>
<h3>定義2</h3>
<p>定義1と同値な定義を与える.</p>
<p><div class=thm></p>
<p>位相空間 \(X\) に対して 位相空間 \(S\) と局所同相写像 \(p: S \to X\) があるとき、 \((S, p)\) を \(X\) の上の <strong>層</strong> という.</p>
<p></div></p>
<p>ここで \(p: S \to X\) が局所同相写像とは、任意の点 \(s \in S\) に対して、 定義域を \(s\) を含むように適切に小さく制限して得た写像 \(p \lceil U\) が同相写像であること.</p>
<h3>定義1 → 定義2</h3>
<p>層 \(A\) が与えられた時、</p>
\[\tilde{S} = \{ (x, f) ~:~ f \in A, x \in Ef \}\]
<p>\(\tilde{S}\) の上の同値関係</p>
\[(x_1,f_1) \equiv (x_2, f_2) \iff
x_1=x_2
\land
\exists U (x \in U), U \subseteq Ef_1\cap Ef_2 \land
f_1 \rceil U = f_2 \rceil U\]
<p>で割って</p>
\[S = \tilde{S}\!\!\equiv\]
<p>とする. 同値関係で明らかに \(x\) については1つに定まるので</p>
\[p : S \to X\]
\[p (x, f) = x\]
<p>という関数が定まる.</p>
<p>\(S\) に位相を入れる. \(x \in X\) の近傍を \(V_x\) とするとき \((x,f)\) の近傍を</p>
\[\{ (y, f) &#x2F;\! \equiv ~:~ y \in V_x\}\]
<p>と定める. これによって位相を入れる ( <a href="neigh-to-topo.html">近傍によって位相を入れる</a> 参照).</p>
<p>以上の \((S,p)\) が層 \(A\) に対応する定義2の形の層である.</p>
<h3>定義2 → 定義1</h3>
<p>\(X\) 上の層 \((S,p)\) から \((A,E,\rceil)\) の形の層を次のようにして構成できる.</p>
<p>\(U \in \O(X)\) について</p>
\[\Gamma(U) = \{ f : f:U \to S, p \circ f = i \}\]
<p>として</p>
<ol>
  <li>\(A = \bigcup \Gamma(U)\)</li>
  <li>\(Ef=U \iff f \in \Gamma(U)\)</li>
  <li>
    \(f \rceil V = f \lceil (V \cap Ef)\)
    <ul>
      <li>右辺は単なる関数の制限</li>
    </ul>
  </li>
</ol>
<p>定義2 であっても前層でかつ定義1の層と一致することがわかる.</p>
<p>ここで \(\Gamma\) の定義で出てくる \(i\) は \(U \to X\) の埋め込みである. \(\Gamma(U)\) の要素は \(p\) に対する \(U\) 上の切断のこと. 以下のような可換図式が成り立つ.</p>
<img src="data:image/png;base64,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">

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>