# 基礎

$\def\Var\mathrm{Var}$

## 型なしラムダ計算

次ような構文で定義される $M$ をラムダ項という.

- $M ::= \Var | \lambda \Var. M | M M$
- $\Var ::= x | y | z | \cdots$

1. ここで $\Var$ は変数と呼ばれる.
1. $\lambda \Var. M$ は関数抽象と呼ばれる.
1. $M M$ は関数適用と呼ばれる.

普通の数式のように優先度を与えるのに括弧を適切に用いる.

次のような略記を導入する.
$\lambda$ が続くスタイル
$$\lambda x. (\lambda y. M) = \lambda x. \lambda y. M$$
を
$$\lambda x, y. M$$
と書く.
個数は2つに限らない:
$$\lambda x, y, z. M$$

### 自由変数 (Free Variables)

関数抽象 $\lambda x. M$ において $x$ は束縛されているとか束縛変数であるという.
逆にそうでない変数を自由変数という.

例えば
$\lambda x,y. xyz$
では $x,y$ は束縛変数で, $z$ が自由変数である.
自由変数は次の関数 $FV$ で列挙できる.

- $FV(x) = \{x\}$ ($x$ は変数)
- $FV(\lambda x. M) = FV(M) \setminus \{x\}$
- $FV(MN) = FV(M) \cup FV(N)$

### 計算規則

以下に挙げるルールに従って,
ラムダ項 $M$ を別なラムダ項 $[M]$ に置き換えてよい.

- $\alpha$-変換（引数のリネーム）
    - $[\lambda x. M] = \lambda y. M\{x:=y\}$
        - $M\{x:=y\}$ とは $M$ の中の変数 $x$ に $y$ を代入したもの
            - 代入については後述
        - ただし $y \not\in FV(M)$ だとする
- $\beta$-簡約（関数適用）
    - $[(\lambda x. M) N] = M\{x:=N\}$
        - この右辺も代入で, 後述する
- $\eta$-変換（関数の外延性）
    - $[\lambda x. M x] = M$

この中で特に $\beta$-簡約を繰り返し適用できるだけ適用することをラムダ計算という.
またこの3つの規則によって互いから互いに写るとき, 2つのラムダ項は同値であるという.

#### 代入

ラムダ項 $M$ に出現する変数 $x$ をラムダ項 $N$ に置き換える操作を
$$M\{x := N\}$$
と書いてこれを **代入** と呼ぶ.
ただし, 単に置き換えるだけだと変数が衝突して困ったことが起き得る.

例えば
$M = \lambda x, y. y x ~(= \lambda x. (\lambda y. y x))$
を考える.
これの内側の $\lambda y. y x$ は先の $\alpha$-変換により
$\lambda z. z x$
と等価であってほしいだろう.
さて $M y$ という関数適用を考えると,
$$M x = (\lambda x. (\lambda y. y x)) y = (\lambda y. y x)\{x:=y\}$$
この最後の $\{x:=y\}$ を単なる置換だとすると
$$M x = \lambda y. y y$$
となる.
一方で予め等価な
$M = \lambda x,z. z x$
にしておくと
$$M x = \lambda z. z y$$
となる.
$\lambda y. y y$
と
$\lambda z. z y$
との意味が違うのは明らかだろう.

何がいけなかったか.
中ですでに $y$ が束縛変数として使われているのに, それと名前が衝突してしまったからだ.
$y$ を全く新しい $z$ にリフレッシュしておいた方は何も問題がなかった.
というわけでそうする.

- $x\{y:=N\} = N$ (if $x = y$)
- $(\lambda x. M) \{y := N\} = \lambda z. (M \{ x:= z \})\{y:=N \}$
    - $z$ は $M$ に出現しない新しい変数
    - とはいえ $x \ne y$ のときは無理にそうせず $x$ のままでもいいけどね
- $(M_1 M_2)\{y:=N\} = (M_1\{y:=N\}) ~ (M_2\{y:=N\})$
- それ以外の時はそのまま
    - $M\{y:=N\} = M$

### 計算の停止性

$\Omega = (\lambda x. x x) (\lambda x. x x)$ とする.
これは関数適用の形をしているから $\beta$-簡約を適用できる.
すると
$$\begin{align*}
[\Omega] & = (x x) \{ x := (\lambda x. x x) \} \\
         & = (\lambda x. x x) (\lambda x. x x) \\
        & = \Omega
\end{align*}$$
と, 自分自身に写る.
従って $\Omega$ の計算は停止しないということが分かる.

ちなみに簡約の順序によっても計算は停止したりしなかったりする.
$M = (\lambda x. \lambda y. y) \Omega$
を考える.
$\Omega$ の中身を先に簡約しようとするともちろん停止しないが,
全体の関数適用を先に簡約すれば
$[M] = (\lambda y. y)\{x := \Omega\} = \lambda y. y$
として停止する.

## 型付きラムダ計算

普通のプログラミング言語にあるような型の概念をラムダ項に導入する.
これによる計算を型付きラムダ計算という.
この計算では先の $\Omega$ のような項はそもそも定義できない.

構文は型なしラムダ項と同じ.

型を次で定義する.

- $E ::= e | E \to E$

すなわち, $e, (e \to e), e \to (e \to e), (e \to e) \to e$ などが型である.
ここで $\to$ は右結合で $e \to e \to e$ は $e \to (e \to e)$ を意味するとする.

ラムダ項に対して次のように型を与える.
ここで「$M$ の型が $f$ である」ことを $M \colon f$ と書くことにする.

- 変数 $x$ の型は任意
    - $x \colon f$ ($f \in E$)
- $\lambda x. M$ の型は $x$ の型が $f$, $M$ の型が $g$ のとき,
    - $\lambda x. M \colon f \to g$
- $M N$ の型は $M$ の型が $(f \to g)$ でかつ $N$ の型が $f$ のときに限り,
    - $M N \colon g$

この最初の2つは自由に型が付けられるが,
3つ目は $M$ と $N$ の型について適切な条件が要請されており, これを満たさないような $M N$ はラムダ項として **認めない** とする.
これによって先の $\Omega$ が弾かれる.

### 補題
型付ラムダ計算において
$\Omega = (\lambda x. x x) (\lambda x. x x)$
は定義されない.

これを定義するためにはその部品である
$\omega = \lambda x. x x$
を定義する必要があるが, これがすでに定義できない.

出来ると仮定してこれに型を付けてみよう.
登場する変数は $x$ のみであるので $x$ の型を $f$ だと置く.
$x x$ と関数適用しているので,
1つ目の $x$ は2つ目の $x$ を受け取って何かを返す形をしているので
$$x \colon f \to g$$
である.
そしてこれ自体の型が $f$ だと初めに置いたので
$f = f \to g$
となる.
そのようなものは無い.
