% Thu Jul 02 2020

## 日記 - 最近作った渾身のコマンド

### [qj](https://github.com/cympfh/qj)

ターミナル / シェルスクリプトから JSON をダンプする.
ずっと欲しかったので今日仕事をサボって作ってた.

シェルスクリプトからJSONを吐くことがある.
例えば Slack の incoming webhook は JSON データをPOSTで送る.
Slack じゃなくても今どきの WebAPI ではよくある.
シェルスクリプトから雑に curl で投げたいときに JSON データだけどうにかしてダンプする必要がある.
例えば,

```bash
cat <<EOM > payload.json
{
    "channel": "#hoge",
    "text": "$TEXT"
}
EOM
```

みたいにすれば簡単なテンプレート言語として機能してくれる.
のだけど, `$TEXT` に改行が入っていたら, クオーテーション文字が入っていたら, これはおそらく正しくJSONとして機能しない（改行は大丈夫かな？どうだろう？）.

これは別に JSON というデータフォーマットに限ったことじゃない.
シェルスクリプトに優しいデータフォーマットなんてもはやない.
YAML なら安全に吐けるというなら YAML を吐いて JSON に変換してもいいが, それも難しい.

というわけで作った.
`jq` という JSON からデータをフィルタ（射影）するコマンドがあるが,
おおよそそれの逆をするという気持ちから `qj` とした.

README の例だが, こんな感じ:

```bash
   qj -e .=3
3

   qj -e .x=1 -e .y=2 -e .z[0]=3
{"x":1,"y":2,"z":[3]}

   qj -e '.hello="world"'  # Use quoting for Shell Escaping
{"hello":"world"}

   qj -e '.persons[1].name="Alice"'
{"persons":[null,{"name":"Alice"}]}
```

jq 方式の値一個をフィルタする式と, その値のペアを `=` で区切って指定してく.
値の数だけこれを並べないといけないので, 出来上がる式の割にかなり冗長に書いていかないといけない.

だから本当は jq がそうであるようにパイプを使って上手いこと

```bash
   qj -e '.x | (.y=2, .z=3)'
{
  "x": {"y": 2, "z": 3}
}
```

このくらい書けるのがいいんだけど, そういうことまでは書けない.

またこのコマンドがほしかったモチベーションの全てが, 文字列のエスケープが面倒くさい, なので, 値は特にパースできなかったときは丸々全て文字列ということにする.

```bash
   qj -e '.=hoge'
"hoge"

   qj -e '.=ho"ge'
"ho\"ge"

   qj -e ".=$(seq 3)"
"1\n2\n3"
```

クオーテーションが入ってても改行が入ってても出来るだけ文字列として解釈するようにする.

シェルスクリプトから Slack の incoming webhook に POST は次のように出来る

```bash
qj .channel=#channel .username=bot .text=hello! .icon_emoji=:ghost: |
    curl -XPOST --data @- https://hooks.slack.com/services/XXXXXXXXXXXX
```

このくらいの単純な JSON なら記述量も減るし, エスケープのこと考えなくていいし楽.

### [web-grep](https://github.com/cympfh/web-grep)

これは中の実装に関してはまじでただの
[tanakh/easy-scraper](https://github.com/tanakh/easy-scraper)
のラッパーです.

それはともかくめちゃくちゃ便利.
web スクレイピングといえば, 私は次の二つを取っていた.

1. curl して目印を grep してその前後から気合で取ってくる
2. curl して真面目にHTMLをパース
  - XML の再帰的データ構造になっているので, root から所望のデータが入っているところまで辿る

1 で十分ということもある.
これでいいときはこれでいい. 2 を選ぶより楽だし都合がいいこともある.
そうでない場合は 2 をする必要がある.
問題は所望のデータの場所を指定するパスを保守するのが面倒だということ.
最初に必死こいてそのパスを探すのに, あるとき簡単に変わってしまう.

easy-scaper は XML に関するパターンマッチを実現してくれる.
web-grep ではプレースホルダーとして `{}` を用いて例えば次のようにパターンを記述する.

```
<a class="link">{}</a>
```

これは `link` というクラス属性を持つ `a` タグに包まれた中のテキストを表現する.
HTML 自体を取得したいことはないからテキストにしか `{}` はマッチしない.

`{}` は属性にも使える.

```
<a class="{}"></a>
```

これは `a` タグのクラス名を取得する.

このパターンマッチはHTML中の唯一つにマッチすることを初めから仮定していないのもいい.
パスでデータの場所を指定する方法はちょうど一つを指しているが,
このパターンで指定する方法はマッチしなければゼロ個だし, 複数にマッチすればその全てを列挙してくれる.
例えば `<li>` で列挙されたデータを全部取得したいというときに便利だ.

```bash
   seq 3 | sed 's#.*#<li>&</li>#' | web-grep '<li>{}</li>'
1
2
3
```
