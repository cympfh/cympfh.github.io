<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>コンパクト空間からハウスドルフ空間への連続全単射は同相写像</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-svg-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title" id="1-コンパクト空間からハウスドルフ空間への連続全単射は同相写像">コンパクト空間からハウスドルフ空間への連続全単射は同相写像</h1>
<p><p class=date style='text-align: right'>2020-09-28 (Mon.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#位相空間>位相空間</a> </div></p>
<h2 id="2-概要">概要</h2>
<p>位相空間とはなにかの知識までを仮定する.</p>
<p>一般に位相空間の間に連続な全単射があったとき, これの逆写像は連続とは限らず, 従って同相（位相同型）を与えない. しかしこれがコンパクト空間からハウスドルフ空間への連続全単射の場合には同相を与える.</p>
<p>このことの説明と証明をする.</p>
<h2 id="2-諸概念">諸概念</h2>
<h3 id="3-位相空間, 開集合">位相空間, 開集合</h3>
<p><a href="topo">ここ</a> で説明したので略.</p>
<h3 id="3-連続写像">連続写像</h3>
<p>2つの位相空間 \(X,Y\) の間に写像 \(f \colon X \to Y\) があったときに, この \(f\) が <strong>連続</strong> であるとは次を満たすこと.</p>
<ul>
  <li>\(Y\) の任意の開集合 \(U\) に対してその逆像 \(f^{-1}(U) \subset X\) が開集合</li>
</ul>
<h3 id="3-同相写像">同相写像</h3>
<p>連続写像 \(f\) であって, その逆写像 \(f^{-1}\) もあってそれもまた連続であるとき, この \(f\) を <strong>同相写像</strong> （または位相同型写像とも）という.</p>
<h3 id="3-開被覆">開被覆</h3>
<p>位相空間 \(X\) の <strong>開被覆</strong> （あるいは単に被覆）とは, 開集合の族</p>
\[\{ U_\lambda \mid U_\lambda \subset X \}_\lambda\]
<p>であって, \(\bigcup_\lambda U_\lambda = X\) を満たすようなもののこと.</p>
<h3 id="3-コンパクト空間">コンパクト空間</h3>
<p>位相空間 \(X\) が <strong>コンパクト</strong> であるとは, 任意の被覆 \(\{ U_\lambda \}_{\lambda \in \Lambda}\) が与えられたときに, そこから有限個の開集合</p>
<ul>
  <li>
    \(\{ U_i \}_{i \in I}\)
    <ul>
      <li>\(I \subset \Lambda\) , \(|I|\) は有限</li>
    </ul>
  </li>
</ul>
<p>を取り出して \(\bigcup_i U_i = X\) と出来ること.</p>
<p>言い換えれば, 無限個の開集合からなる被覆があるとき, 上手く選ぶことで必ず有限の被覆に出来ること.</p>
<h3 id="3-ハウスドルフ空間">ハウスドルフ空間</h3>
<p>位相空間 \(X\) が次を満たすとき, これを <strong>ハウスドルフ空間</strong> であるという.</p>
<ol>
  <li>任意の二点 \(x,y \in X\) を取り出す</li>
  <li>
    開集合 \(U_x, U_y\) が必ず存在して次を満たす:
    <ul>
      <li>\(x \in U_x\)</li>
      <li>\(y \in U_y\)</li>
      <li>\(U_x \cap U_y = \emptyset\)</li>
    </ul>
  </li>
</ol>
<p>便宜上, この二点 \(x,y\) から \(U_x, U_y\) を選ぶ操作を \(H\) として \((U_x,U_y) = H(x,y)\) と書くことにする. この開集合の選び方はただ一通りである必要はないが, 便宜上 \(H\) はその中から一つを決定的に返すものとする.</p>
<h2 id="2-補題 1: コンパクト空間の部分閉集合はコンパクト">補題 1: コンパクト空間の部分閉集合はコンパクト</h2>
<p>コンパクト空間 \(X\) に対して閉集合 \(Y \subset X\) を考える. このとき \(Y\) もコンパクトになる.</p>
<p>\(Y\) に任意の被覆 \(\{ U_\lambda \}_{\lambda \in \Lambda}\) を与える. この各 \(U_\lambda\) を \(U_\lambda \cup (X \setminus Y)\) に置き換えればこれは \(X\) の被覆になる. ここで \(Y\) が閉集合であることから \(X \setminus Y\) は開集合であることを利用している.</p>
<p>さて \(X\) はコンパクトなので, 上手く \(I \subset \Lambda\) を選ぶことで,</p>
\[\bigcup_I (U_i \cup (X \setminus Y)) = X\]
<p>ここからそのまま</p>
\[\bigcup_I U_i = X \cap Y = Y\]
<p>を得る. これは結局 \(Y\) に対する有限の被覆になる.</p>
<p>以上から \(Y\) はコンパクト.</p>
<h2 id="2-補題 2: コンパクト空間を連続写像で写す像はコンパクト">補題 2: コンパクト空間を連続写像で写す像はコンパクト</h2>
<p>コンパクト空間 \(X\) と連続写像 \(f\) によって \(Y = fX\) であるとする. このとき \(Y\) もコンパクトになる.</p>
<p>\(Y\) に任意の被覆 \(\{ U_\lambda \}\) を与える. これの \(f\) の逆像を考えると, \(f\) が連続であることから各 \(f^{-1}(U_\lambda)\) は \(X\) の開集合になる. 被覆全体も \(f^{-1}(Y)=X\) なので, 結局 \(X\) の被覆 \(\{ f^{-1}(U_\lambda) \}\) が手に入る.</p>
<p>そして \(X\) はコンパクトなので, やはり \(I\) を上手く選んで, 有限の被覆</p>
\[\{ f^{-1}(U_i) \}_{i \in I}\]
<p>を構成できる. そしてこれを再び \(f\) で移せば, \(Y\) の有限の被覆</p>
\[\{ U_i \}_{i \in I}\]
<p>を構成できる.</p>
<p>従って \(Y\) はコンパクト.</p>
<h2 id="2-Remark: 開集合であることはより小さい開集合を取れることと同値">Remark: 開集合であることはより小さい開集合を取れることと同値</h2>
<p>位相空間 \(X\) の部分集合 \(V \subset X\) が開集合であることは次と同値.</p>
\[\forall x \in V ,~ \exists V_y \subset V ,~ y \in V_y\]
<p>ここで \(V_y\) は開集合であることとする.</p>
<h2 id="2-定理: コンパクト空間からハウスドルフ空間への連続全単射は同相写像">定理: コンパクト空間からハウスドルフ空間への連続全単射は同相写像</h2>
<p>コンパクト空間 \(X\) とハウスドルフ空間 \(Y\) があって, その間に連続な全単射 \(f \colon X \to Y\) があるとする.</p>
<p>\(f\) が同相写像とはそれと逆写像のどちらもが連続であることだったが, \(f\) が連続なのは仮定しているので, これの逆写像 \(f^{-1}\) が連続であることだけ確認すれば, \(f\) が同相写像であると言える.</p>
<p>連続写像の定義から, \(f^{-1}\) が連続であるとは, 任意の開集合 \(U \subset X\) に対して \(fU \subset Y\) が開集合であること. このことを先程の Remark を使って証明する. すなわち, 任意の点 \(y \in fU\) に対して,</p>
\[y \in K \subset fU\]
<p>を満たすような開集合 \(K\) が存在すれば, 定理が証明される.</p>
<p>自明なケースとして, \(fU = Y\) または \(fU = \emptyset\) である場合は自明に開集合なのでこのケースは除外する. すると, \(fU\) も \(Y \setminus fU\) も空でない集合となる.</p>
<p>一点 \(y \in fU\) と \(Y \setminus fU\) の各点を次のようにして分離する:</p>
\[\{ H(y, y&#x27;) \mid y&#x27; \in Y \setminus fU \}\]
<p>さて \(X\) はコンパクトで \(U\) は開集合なので, 補題 1 より, \(X \setminus U\) はコンパクト. これを \(f\) で写すと \(f(X \setminus U) = fX \setminus fU = Y \setminus fU\) を得るが, これも補題 2 よりコンパクト.</p>
<p>そこで \(Y \setminus fU\) の被覆を次のように作る.</p>
\[\{ V_{y&#x27;} \cap (Y \setminus fU) \mid y&#x27; \in Y \setminus fU, (\_, V_{y&#x27;}) = H(y, y&#x27;) \}\]
<p>この各開集合は \(y&#x27; \in Y\) によって添字付することが出来る. そしてコンパクトであることから, 有限の点集合 \(J \subset Y\) を上手く選んで,</p>
\[Y \setminus fU = \bigcup \{ V_{y&#x27;} \cap (Y \setminus fU) \mid y&#x27; \in J \setminus fU, (\_, V_{y&#x27;}) = H(y, y&#x27;) \}\]
<p>と出来る. ここから</p>
\[Y \setminus fU \subset \bigcup \{ V_{y&#x27;} \mid y&#x27; \in J \setminus fU, (\_, V_{y&#x27;}) = H(y, y&#x27;) \}\]
<p>を導く. さて, この右辺に対応して,</p>
\[K = \bigcap \{ V_{y} \mid y&#x27; \in J \setminus fU, (V_y, \_) = H(y, y&#x27;) \}\]
<p>を考える.</p>
<p>実は, \(V_y\) と \(V_{y&#x27;}\) が分離されてることから</p>
\[fU \supset K\]
<p>であることが言える.</p>
<p>なぜなら, もし \(fU\) 外の点 \(z \in Y \setminus fU\) を右辺が持つなら, 全ての \(y&#x27;\in J\) に対して \(z \in V_y\) , すなわち \(z \not\in V_{y&#x27;}\) . \(\bigcup V_{y&#x27;}\) に \(z\) が含まれないことになり, 被覆であったことに反するから.</p>
<p>さて \(K\) は有限個 \((J)\) の開集合の積であり, そのようなものは一般にまた開集合である. 従って,</p>
\[y \in K \subset fU\]
<p>を満たす開集合 \(K\) を見つけることが出来た. このことは任意の \(y \in fU\) に対しても行うことが出来る.</p>
<p>以上から \(fU\) は開集合であり, 定理も証明された.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>