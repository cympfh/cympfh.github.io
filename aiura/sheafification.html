<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>層化 (sheafification)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-svg-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title" id="1-層化 (sheafification)">層化 (sheafification)</h1>
<p><p class=date style='text-align: right'>2018-04-22 (Sun.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#層>層</a> </div></p>
<p>位相空間 \(X\) の上の前層について考える. 前層があるとき、以下のステップを踏むことでまず中間層に誘導し、さらにそれを層に誘導できる. この手続きを層化という.</p>
<h2 id="2-INDEX">INDEX</h2>
<p><div id=toc></div></p>
<h2 id="2-前層・層の定義">前層・層の定義</h2>
<p><a href="sheaf.html">前記事</a> に書いた.</p>
<h2 id="2-諸定義">諸定義</h2>
<p>層 \(A\) の2元 \(f,g\) について</p>
\[[f=g] := \bigcup \{ U : f \rceil U = g \rceil U \}\]
<p>と定める. \(U\) についての和を取っていることに註意. 特に \([f=f] = X\) (全体) である.</p>
<p>2元 \(f,g\) が互いのドメインで制限したときに等しいことを「両立している」と表現する. すなわち</p>
\[f \rceil Eg = g \rceil Ef\]
<p>のことである.</p>
<h2 id="2-中間層の定義">中間層の定義</h2>
<p>前層 \(A\) について</p>
\[\forall f,g \in A, Ef \cap Eg \subseteq [f=g] \implies f\rceil Eg=g\rceil Ef\]
<p>が成立するものを中間層と言う. (逆は一般の前層で成立する.)</p>
<h2 id="2-前層から中間層への誘導">前層から中間層への誘導</h2>
<p>前層 \(A\) に次の同値関係を入れる.</p>
\[f \equiv g \iff Ef=Eg \subseteq [f=g]\]
<p>これで割って</p>
\[\begin{align*}
\hat{A} = A&#x2F;\!\!\equiv \\
\varphi : A \to \hat{A} \\
E \varphi(f) = Ef \\
\varphi(f) \rceil U = \varphi( f \rceil U)
\end{align*}\]
<p>とする. この \(\hat{A}\) が中間層になっている.</p>
<h2 id="2-誘導されたそれが中間層であることの確認">誘導されたそれが中間層であることの確認</h2>
<p>前層であることまでは自明だとして、中間層としての条件が満たされてることだけ確認する.</p>
<p>すなわち、任意の2元 \(f,g \in A\) に対する \(\varphi(f), \varphi(g) \in \hat{A}\) について</p>
\[E\varphi(f) \cap E\varphi(g) \subseteq [\varphi(f)=\varphi(g)] \implies \varphi(f)\rceil E\varphi(g)=\varphi(g)\rceil E\varphi(f)\]
<p>であることを確認する.</p>
<p>この式は \(E\varphi\) と \(\varphi \rceil\) の定義から</p>
\[Ef \cap Eg \subseteq [\varphi(f)=\varphi(g)] \implies \varphi(f\rceil Eg)=\varphi(g\rceil Ef)\]
<p>と書き直せる.</p>
<p>さらに \(\implies\) から見て右辺は \(\varphi\) のイコールなので同値関係のことを言っている.</p>
\[\begin{align*}
     &amp; \varphi(f\rceil Eg)=\varphi(g\rceil Ef) \\
\iff &amp; f\rceil Eg \equiv g\rceil Ef \\
\iff &amp; E(f\rceil Eg) = E(g\rceil Ef) \land E(g \rceil Ef) \subseteq [f \rceil Eg=g \rceil Ef] \\
\iff &amp; Ef \cap Eg \subseteq [f \rceil Eg=g \rceil Ef] \\
\end{align*}\]
<p>と書き直せる.</p>
<p>改めて示したい式を書き直すと <div class=thm></p>
\[
Ef \cap Eg \subseteq [\varphi(f)=\varphi(g)]
\implies
Ef \cap Eg \subseteq [f \rceil Eg=g \rceil Ef]
\]
<p></div> となる.</p>
<p>背理法で示す. 右辺が \(\not\subseteq\) だとすると、</p>
\[\exists x \in Ef \cap Eg, x \not\in [f \rceil Eg=g \rceil Ef]\]
<p>という点 \(x \in X\) があるはずである. \([- = -]\) の定義まで戻れば、そのような点 \(x\) に対して</p>
\[\forall U (x \in U), f \rceil Eg \rceil U \ne g \rceil Ef \rceil U\]
<p>である. さらに \(U \subseteq Ef \cap Eg\) となるように小さいものに限ると右辺がすっきりして</p>
\[\forall U (x \in U \subseteq Ef \cap Eg), f\rceil U \ne g\rceil U\]
<p>と言える.</p>
<p>さて \(\implies\) より左辺について. 今の点 \(x\) がやはり \([\varphi(f) = \varphi(g)]\) に含まれないために \(\not\subseteq\) であることを示す.</p>
<p>とりあえず \([-=-]\) を展開してく.</p>
\[\begin{align*}
[\varphi(f) = \varphi(g)]
&amp; = \bigcup \{ U : \varphi(f) \rceil U = \varphi(g) \rceil U \} \\
&amp; = \bigcup \{ U : f \rceil U \equiv g \rceil U \} \\
&amp; = \bigcup \{ U : Ef \cap U=Eg \cap U \land Ef \cap U \subseteq [f\rceil U=g\rceil U] \}
\end{align*}\]
<p>ある \(U\) で \(x \in U\) かつ \(Ef\cap U=Eg\cap U\) だとする. このとき、いつも</p>
\[Ef \cap U \not\subset [ f \rceil U = g \rceil U ]\]
<p>である. なぜなら</p>
\[Ef \cap U \subset [ f \rceil U = g \rceil U ]\]
<p>であるとすると (背理法)、 \(x \in Ef \cap U\) なので</p>
\[\begin{align*}
x &amp; \in [ f \rceil U = g \rceil U ] \\
  &amp; =   \bigcup \{ V : f \rceil U \rceil V = g \rceil U \rceil V \} \\
  \iff &amp; \exists V, x \in V \land f \rceil U \rceil V = g \rceil U \rceil V \\
  \iff &amp; \exists V, x \in V \land f \rceil (U \cap V) = g \rceil (U \cap V)
\end{align*}\]
<p>最後の \((U \cap V)\) に対してさらに \((U \cap V) \cap (Ef \cap Eg)\) を \(W\) とすれば \(x \in W \subseteq Ef \cap Eg\) に対して \(f \rceil W = g \rceil W\) となってしまう.</p>
<p>したがって、 \([\varphi(f) = \varphi(g)]\) は点 \(x\) が含まない. というわけで</p>
\[
Ef \cap Eg \not\subseteq [\varphi(f)=\varphi(g)]
\]
<p>である.</p>
<p>以上から対偶が示されたので順も示された.</p>
<p>というわけで、 \(\hat{A}\) は中間層である. (背理法の中で更に背理法を使ってしまった.)</p>
<h2 id="2-中間層から層への誘導">中間層から層への誘導</h2>
<p>中間層 \(A\) があるとき、</p>
\[\mathcal{F} = \{ F \subseteq A | F \text{の2元は両立} \}\]
<p>を定める. この上に関数 \(E, \rceil\) を次のように定める.</p>
<ul>
  <li>\(EF = \bigcup_{f \in F} Ef\)</li>
  <li>\(F \rceil U = \{ f \rceil U | f \in F\}\)</li>
</ul>
<p>\(\mathcal F\) が層であるかなどは見ないが \(E(F \rceil U) = EF \cap U\) などは成り立つ.</p>
<p>\(\mathcal F\) 上に同値関係を次のように定める.</p>
<p>\(F_1, F_2 \in \mathcal F\) について</p>
\[F_1 \equiv F_2
\iff
EF_1 = EF_2
\land
F_1 \cup F_2 \in \mathcal F\]
<p>\(\mathcal F\) の定義ゆえ、 \(F_1 \cup F_2 \in \mathcal F\) とは、 \(F_1\) の任意の元と \(F_2\) の任意の元とが両立することであることに註意.</p>
<p>また中間層故、この \(\equiv\) は確かに同値関係になる.</p>
<p>以上から \(\def\FS{\mathcal F\!&#x2F;\!\!\equiv}\FS\) が定まる. \(\varphi\) を商を取る関数</p>
\[\varphi : \mathcal F \to \FS\]
<p>とする.</p>
<p>\(\FS\) 上の \(E, \rceil\) は \(\varphi\) によって自然に導かれる. すなわち、</p>
<ul>
  <li>\(E(\varphi F) = \bigcup_{f \in F} Ef\)</li>
  <li>\((\varphi F) \rceil U = \varphi (F \rceil U)\)</li>
</ul>
<p>このとき \(\langle \FS, E, \rceil \rangle\) は層となる.</p>
<h2 id="2-誘導されたそれが層であることの確認">誘導されたそれが層であることの確認</h2>
<p>中間層 \(A\) から誘導して得た \(\langle \FS, E, \rceil \rangle\) が層であることを確認する.</p>
<p>まず前層であることを簡単に見ていって、加えて、層であることを確認する</p>
<h3 id="3-notations">notations</h3>
<p>主に \(\varphi\) を省略したいので、紛らわしくない限り次の略記法を用いる.</p>
<p>\(F \in \mathcal F\) について</p>
\[E(\varphi F) = EF = \bigcup_f Ef\]
<p>であるので、 \(E(\varphi F)\) を単に \(EF\) と書く.</p>
<p>\(\varphi\) の切断を \(\psi\) とする. ここで切断とは</p>
\[\forall F \in \FS,~ \varphi (\psi F) = F\]
<p>となるような \(\psi : \FS \to \mathcal F\) のこと. つまり、代表元を1つ取ってくるような関数のこと.</p>
<h3 id="3-前層であることの確認">前層であることの確認</h3>
<p>前層の公理を満たすことを実際に確かめる</p>
<ol>
  <li>
    \(\forall F \in \mathcal F, (\varphi F) \rceil \emptyset = \{ \ast \}\)
    <ul>
      <li>ただしここで \(f \in A, f \rceil \emptyset = \ast\) とした</li>
    </ul>
  </li>
  <li>\((\varphi F) \rceil EF = \varphi \{ f \rceil EF | f \in F \} = \varphi \{ f | f \in F \} = \varphi F\)</li>
  <li>\(E(F \rceil U) = \bigcup_f E(f \rceil U) = \bigcup_f (Ef \cap U) = \bigcup_f Ef \cap U = EF \cap U\)</li>
  <li>\((F \rceil U) \rceil V = \{f \rceil U | f \in F\}=\{f \rceil U \cap V | f \in F\}=F \rceil (U \cap V)\)</li>
</ol>
<p>以上から前層であることが確かめられた.</p>
<h3 id="3-層であることの確認">層であることの確認</h3>
<p>前層であることは確かめたので、次を確かめればよい.</p>
<blockquote>任意の \(\mathcal G \subseteq \mathcal F\) について、 \(\mathcal G&#x2F;\!\equiv\) の任意の2元が両立するならば、 唯一の和 \(\bigcup \mathcal G\) が存在する.</blockquote>
<p>まず、和として満たすべき性質を満たす集合が作れること (存在性) を示す. 次に、その存在が唯一なものであること (唯一性) を示す.</p>
<h4 id="4-1. 存在性">1. 存在性</h4>
\[\bar{G} = \varphi \left( \bigcup_{G \in \mathcal G} G \right)\]
<p>これが和としての性質を満たすことを確かめる. 和としての性質とは次の2つである.</p>
<ol>
  <li>\(E\bar{G} = \bigcup_{G \in \mathcal G&#x2F;\!\equiv} EG\)</li>
  <li>\(G \in \mathcal G&#x2F;\!\equiv \implies \bar{G} \rceil EG = G\)</li>
</ol>
<p>確認する. 1つ目は \(\bar{G}\) の作り方から明らか.</p>
<p>2つ目. \(\varphi G_0 \in \mathcal G&#x2F;\!\equiv\) について、</p>
\[\begin{align*}
\bar{G} \rceil EG_0
&amp; = \varphi \left( \bigcup_{G \in \mathcal G} G \right) \rceil EG_0 \\
&amp; = \varphi \left(
    \{ g \rceil EG_0 | G \in \mathcal G, g \in G \}
\right) ~~~\text{ ... } E \text{ の定義より} \\
&amp; = \varphi \left(
    \bigcup_{G \in \mathcal G} (G \rceil EG_0)
\right) ~~~\text{ ... } G \text{ ごとにまとめた} \\
&amp; = \varphi \left(
    \bigcup_{G \in \mathcal G} (G_0 \rceil EG)
\right) ~~~\text{ ... } \varphi G \text{ と } \varphi G_0 \text{ は両立してるので (ただしそんなに自明ではない)} \\
&amp; = \varphi \left(
    G_0 \cup \bigcup_{G \ne G_0} (G_0 \rceil EG)
\right) ~~~\text{ ... 後の説明の便宜上 } G=G_0 \text{ の場合とそれ以外とに分けた} \\
&amp; = \varphi G_1 \text{ とおく}
\end{align*}\]
<p>示したいのは \(\varphi G_0 = \varphi G_1\) であること. すなわち \(G_0 \equiv G_1\) であること. \(\equiv\) であることを示すには次の2つを見れば良いのだった.</p>
<ol type=a>
  <li>\(EG_0 = EG_1\)</li>
  <li>\(G_0 \cup G_1 \in \mathcal F\)</li>
</ol>
<h5 id="5-i.">i.</h5>
\[\begin{align*}
EG_1
&amp; = E\left( G_0 \cup \bigcup_{G \ne G_0} (G_0 \rceil EG) \right) \\
&amp; = EG_0 \cup \bigcup_{G \ne G_0} E(G_0 \rceil EG) \\
&amp; = EG_0 \cup \bigcup_{G \ne G_0} (EG_0 \cap EG) \\
&amp; = EG_0
    ~~~\text{... } EG_0 \supseteq (EG_0 \cap EG) \text{ より}
\end{align*}\]
<h5 id="5-ii.">ii.</h5>
\[\begin{align*}
G_0 \cup G_1
&amp; = G_0 \cup \left( G_0 \cup \bigcup_{G \ne G_0} (G_0 \rceil EG) \right) \\
&amp; = \left( G_0 \cup \bigcup_{G \ne G_0} (G_0 \rceil EG) \right) \\
&amp; = G_1
\end{align*}\]
<p>というわけで \(G_0 \cup G_1 = G_1\) なので \(G_1 \in \mathcal F\) であることを確かめればよい.</p>
\[\varphi G_1 = \varphi \left(
    \bigcup_{G \in \mathcal G} \psi(G_0 \rceil EG)
\right)\]
<p>であったことを思い出すと、 2元 \(f, g \in G_1\) は</p>
<ul>
  <li>\(\exists F \in \mathcal{G}, f \in (G_0 \rceil EF)\)</li>
  <li>\(\exists G \in \mathcal{G}, g \in (G_0 \rceil EG)\)</li>
</ul>
<p>と書ける. \((G_0 \rceil EF)\) などは単なる集合なので更に次のように書き換えられる.</p>
<ul>
  <li>\(\exists F \in \mathcal{G}, \exists f&#x27; \in G_0,~ f = f&#x27; \rceil EF\)</li>
  <li>\(\exists G \in \mathcal{G}, \exists g&#x27; \in G_0,~ g = g&#x27; \rceil EG\)</li>
</ul>
<p>このときに \(f, g\) が両立していることを見たい. ここで \(f&#x27;, g&#x27;\) は \(G_0\) の元であって \(G_0\) は \(\mathcal F\) の元である. \(\mathcal F\) の作り方を思い出すと、 \(f&#x27;, g&#x27;\) は両立しているのだった. これを利用する.</p>
\[\begin{align*}
f \rceil Eg
&amp; = (f&#x27; \rceil EF) \rceil Eg \\
&amp; = (f&#x27; \rceil EF) \rceil Eg&#x27; \rceil EG \\
&amp; = (g&#x27; \rceil Ef&#x27;) \rceil EF \rceil EG ~~~\text{... 両立性より} \\
&amp; = g \rceil Ef&#x27; \rceil EF ~~~\text{... 戻していく} \\
&amp; = g \rceil Ef
\end{align*}\]
<p>というわけで \(f, g\) は両立している. というわけで \(G_0 \cup G_1 = G_1\) の任意の2元はつねに両立している. なので \(G_0 \cup G_1 \in \mathcal F\) である.</p>
<p>以上 i. ii. より、 \(\varphi G_0 = \varphi G_1\) である.</p>
<p>以上より \(\bar{G}\) は和としての性質を満たしている.</p>
<h4 id="4-2. 唯一性">2. 唯一性</h4>
<p>他に和としての性質を満たす \(\varphi H \in \FS\) があるとする. このとき</p>
\[\varphi H = \bar{G}\]
<p>であることを示すことで、和が唯一であって</p>
\[\bigcup \mathcal G = \FS\]
<p>であることが証明できたことになる.</p>
<p>やっていく.</p>
<h5 id="5-i.">i.</h5>
<p>どちらも和としての性質を満たすことを仮定しているので</p>
\[EH = \bigcup EG = E \bar{G}\]
<h5 id="5-ii.">ii.</h5>
<p>\(H \cup \psi \bar{G} = H \cup \bigcup_{G \in \mathcal G} G\) の任意の2元が両立することを見る.</p>
<h6 id="6-1.">1.</h6>
<p>\(g_1, g_2 \in \bigcup_{G \in \mathcal G} G\) が両立することは、 \(\bar{G}\) が和の性質を満たすことを示すときに、さっき示した.</p>
<h6 id="6-2.">2.</h6>
<p>\(h_1, h_2 \in H\) が両立すること. これは \(H \in \mathcal F\) であることから自明.</p>
<h6 id="6-3.">3.</h6>
<p>というわけで本題は、</p>
<blockquote>\(g \in \bigcup_{G \in \mathcal G} G\) と \(h \in H\) とが両立すること.</blockquote>
<p>\(g\) についてはある \(G \in \mathcal G\) があって \(g \in G \in \mathcal G\) である.</p>
<p>\(H\) は \(\mathcal G\) の和なので、そのような \(G\) を用いて、</p>
\[H \rceil EG = G\]
<p>となる. 左辺は</p>
\[\{ h&#x27; \rceil EG | h&#x27; \in H \}\]
<p>なので、 \(h\) について \(h \rceil EG\) という値は、 \(H \rceil EG\) に属する. 従って \(G\) にも属する. というわけで、</p>
\[\exists g&#x27; \in G,~ h \rceil EG = g&#x27;\]
<p>まずこの式の両辺の \(E\) の値を取ることで</p>
\[Eh \cap EG = Eg&#x27;\]
<p>を得る.</p>
<p>また両辺に \(\rceil Eg\) を掛けることで</p>
\[\begin{align*}
h \rceil Eg
&amp; = h \rceil EG \rceil Eg ~~~\text{... } Eg \subset EG \text{ なので} \\
&amp; = g&#x27; \rceil Eg \\
&amp; = g \rceil Eg&#x27; ~~~\text{... } G \text{ の2元は両立してる} \\
&amp; = g \rceil (Eh \cap EG) ~~~\text{... すぐ上で求めた値を代入した} \\
&amp; = (g \rceil EG) \rceil Eh
&amp; = g \rceil Eh
\end{align*}\]
<p>というわけで \(h \rceil Eg = g \rceil Eh\) が得られ、 \(g, h\) も無事両立している.</p>
<p>というわけで \(H \cap \psi \bar{G}\) の2元はいつも両立している.</p>
<p>というわけで</p>
\[\varphi H = \bar{G}\]
<p>が得られた!!</p>
<p>以上.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>