% 2006年度 計算機数学B 講義資料

<section>
<div class="author">東北大学 赤間陽二</div>
<div class="title">2006年度 計算機数学B 講義資料</div>
<div class="public">[http://www.math.tohoku.ac.jp/akama/Jugyou.html](http://www.math.tohoku.ac.jp/akama/Jugyou.html)</div>
<div class="note">[tohoku.md](tohoku.html)</div></section>

ググっていたら偶然見つけたもので、
東北大学の先生が講義のレジュメとしてpdfファイルをネットの上で公開された状態で置いてあったので読ませてもらう.
9年前のものなので (2015.6.4 Thu) いつまで置いてあるかわからない.

<span class="date">0508</span>

1. 正規言語
1. 帰納的言語
1. 帰納的可算言語

を考える.

これらは階層構造をしていて
$$(正規言語) \subseteq (帰納的言語) \subseteq (帰納的可算言語)$$
とある.
例えば、反復補題の格好の例として、
$\{a^n b^n : n\in\mathbb{N}\}$
は正規言語には含まれないが、帰納的言語である.

## 正規言語の定義
言語 $L$ が正規言語である $\iff$  
ある決定性有限オートマトン (DFA) によって受理できる文字列全体と$L$が一致すること.

## 帰納的言語の定義
言語 $L$ が帰納的言語である $\iff$  
文字列が与えられたとき、これが言語$L$に含まれるかの判定をある帰納関数 $\chi (: \Sigma^* \rightarrow \{0,1\})$ でできること.
$$\chi(w) \iff w \in L$$

## 帰納的可算言語の定義
言語 $L$ が帰納的可算である $\iff$
帰納関数 $e : \mathbb{N} \mapsto \Sigma^*$ を用いて
$$L = \{ e(n) : n \in \mathbb{N}\}$$ とできること.  
あと空な言語も特殊に帰納的可算とする.  
$e$ は列挙関数と呼ばれる.

### Prop. 帰納的言語の補言語は帰納的言語

$$\chi'(w) = 1 - \chi(w)$$

## 認識可能性

プラグラム $P$ がその言語を*認識*するとは、
言語が含む任意の文字列を入力すると停止すること.

次に見るように、認識可能であることと、帰納的可算言語であることとは、同値.

### Prop. 帰納的可算言語 $\Rightarrow$ 認識可能

```python
def P(w):
  e = enumerator for L
  for i in [0..]
    if w is e(i):
      return i
```

### Prop. 認識可能 $\Rightarrow$ 帰納的可算言語

まず、$\mathbb{(N, N)}$ と $\mathbb{N}$ とは準同型だから
$(i, j) = f(t)$ という準同型写像が存在する.  
具体的には、
$f^{-1}(n, m) = (n+m) (n+m+1)/2 + n$ の逆像である.

言語 $L$ について,

1. これを認識する $P$
1. $L$が空でないのなら、$w \in L$ な $w$ を持っておく
1. なんでもいいから $\Sigma^*$ についての列挙 $(w_i)_i$

$L$ の列挙 $e(t)$ は次のようにする.

1. let $(i, j) = f(t)$
1. $w_i$ を 時間 $j$ の制限つきで $L$ に認識させる
1. 制限時間未満に停止したなら $w_i \in L$ なので $e(t) = w_i$
1. さもなくば, よくわからないので $e(t) = w$

すべての $w_i$ についてすべての制限時間で認識するのでいつかは言語すべてを列挙できる

## 帰納的言語 $\subseteq$ 帰納的可算言語

帰納的言語は、帰納的可算言語である.

Proof.  
帰納的言語ならば、 membership 関数 $\chi$ があって、
それを用いて、停止するかしないか選ぶプログラムを書ける.

```python
def P(w):
  if chi(w):
    return
  else
    loop
```

## プログラムの表現

プログラムの文字列による表現を $p$ とする.  
$p$ が表現するプログラムによって認識される言語を $L(p)$ と書く.

帰納的可算言語 $B$ について、
これを認識するプログラムの表現 $p$ が存在する.

### 定理

$\Gamma^*$ をプログラム全体、$L^c$ を 言語 $L$ の補言語とするとき、
$$J = \{ p \in \Gamma^* : L^c(p) \ni p \}$$
は帰納的可算ではない.
$J$ とは自身を認識できないプログラム全体の集合.

### 補題

集合 $R$ からその
冪集合 $\mathcal{P}(R)$ への全射というものは存在しない

### 定理

自身を認識できるプログラムの集合:
$$K = \{ p \in \Gamma^* : L(p) \ni p \}$$
これは帰納的ではく、帰納的可算である
(もちろん $K$ は $J$ の補集合である).

$K$ を認識するプログラムは次を実行すればよい:
入力 $p$ を解釈することで、プログラム $P$ を得る.
$P(p)$ を実行したとき、
$p \in K$ ならば、これは停止する.
さもなくば、$P$ は停止しない.

```python
# K を認識するプログラム
def PK(p):
  P = eval(p)
  P(p)
```

<span class="date">0515</span>

# 推論機械

## 言語の完全提示

語と二値のペアの無限列
$$\sigma = (w_1, I_1), (w_2, I_2), ...$$
であって、次を満たすものを、
言語 $L$ の完全提示という.

1. $\{ w_1, w_2, ... \} = \Sigma^*$
1. $I_i \land w_i \in L$ or $\lnot I_i \land w_i \not\in L$

無限列 $\sigma$ に対して、その断片
$\sigma[i] = (w_1, I_1) ... (w_i, I_i)$
を入力として受け取ったときに、
推測 $g_i$ を出力するものを推論機械という.

### 極限同定の定義

$L$ の任意の完全提示 $\sigma$ についての推論 $g_i$ が極限で $g$ を定めて
$L(g) = L$ であること

言ってしまえば、
推論機械というのは、

1. 新しい例が提示されるたびに、
1. 過去に提示されたものに矛盾しない、
1. 表現クラスの枚挙の中で最初の表現を
1. 仮説として出力する

### 枚挙による学習機械
帰納的可算な表現(言語)クラス $R$ を持つ、  
添字付き帰納的言語クラス $C$ を $R$ の下で極限同定する  
($r \in R, L(r) = C_i$)

$r \in R$ は可算だからそれを列挙しておいて、  
提示に対して無矛盾なものの最初の一つを推測することをひたすらする

<span class="date">0522</span>

枚挙による学習機械は一般に効率的 (多項式時間) ではない  
正規言語については効率的な方法がある、という話

### 無矛盾

断片 $\sigma[i]$ を受け取ったときの推測 $g_i$ について、
いつも $\sigma[i] \subseteq L(g_i)$ が成立するように推測すること.

ここで、断片は本来列だけど、集合であるかのように書いた.

### 保守

推測の列 $g_1, g_2 ...$ について
$$L(g_1) \supseteq L(g_2) \supseteq ...$$
とあるように推測すること.

<span class="date">0529</span>

正規言語の学習とは即ち、言語から有限オートマトンを復元することにほかならない.
完全提示からは、無矛盾かつ保守的に推論が可能.
詳しくは、
"Regular Positive Negative Inference (RPNI) アルゴリズム"
でググること.

<span class="date">0605</span>

## 言語の正提示

言語 $L$ の正提示とは、  
語の無限列
$$\sigma = \sigma_1, \sigma_2, ...$$
であって、
$$\{\sigma_i:i\} = L$$
を満たすようなものを言う.

### 正提示の学習機械

完全提示を考えていたのを、
正提示の断片を入力にし、
極限において同定する問題に変形する

### 超有限

言語クラス $C$ が超有限であるとは、

1. $\exists \text{ infinite } L, L \in C$
1. $\forall \text{ finite } L', L' \in C$

こういうのは、簡単に言えば大きすぎるクラスである.

### Prop. 超有限な言語クラスは正提示から極限同定不能

無限な方の言語 $L$ を正提示から学習できない.
$L$ の任意の正提示の断片 $\sigma[i]$ について、
これを被覆する有限の言語が常に、言語クラスに持つからである.

### Prop. 正規言語全体は超有限である

有限な言語というのは常に正規言語であるから.

## 言語クラスの階層

1. 超有限は完全提示で学習可能
1. 正規言語全体のクラスは超有限
1. パターン言語全体のクラスは正提示から学習可能
1. ゼロリバーシブル言語は正提示から学習可能

もちろん、パターン言語と正規言語はオーバーラップ (正規パターン) があるがな.

# パターン

## パターンの定義

- $\Sigma$: 大きさ2以上
- $V$: 変数の無限集合

$\Sigma, V$ の元からなる空でない語をパターンという

代入とは変数をパターンで置き換える操作

普通、同時に置き換えを1つ以上行ってよいが、
変数は無限にあるんだから一旦別なものに置き換えることで一つずつ行っても同値だよなぁ

$\theta = \{ x \mapsto y, y \mapsto x \}$
によって
$p = xxyy \mapsto yyxx$
であるけど

1. $\theta_1 = \{x \mapsto z\}$
1. $\theta_2 = \{y \mapsto x\}$
1. $\theta_3 = \{z \mapsto y\}$

を順に適用してもいいよな

## 汎化関係 (Less-general-than relation) $\preceq$
$p \preceq q \iff \exists \theta .~ p = q\theta$

## パターン言語
パターン $p$ に対して、
言語 $L(p) = \{ w \in \Sigma^+ : w \preceq p\}$

- 長さについて $L(p)$ の最小値は $|p|$ と一致する
- 同じ変数が高々一回しか出現しないパターン言語は正規言語である

## $\{L(p):p\}$ は添字付き帰納的言語クラス

<span class="date">0612</span>

表現クラスをパターン全体とする言語クラスを
$\mathcal{PAT}$ (パターン言語全体) と書くことにする

これは帰納的言語クラスであって:  
任意のパターン $p$ について
次のようなプログラム $\chi$ が存在する
$$\chi(p, w) \iff L(p) \in w$$

じゃあこの $\chi$ を構成してみる

$a, b \in \Sigma, w \in \Sigma^*, x \in V$, パターン $p$

- $\chi(x, w) = w \ne \lambda$ ($\lambda$ は空列)
- $\chi(a, b) = a \equiv b$
- $\chi(xp, w) = \exists u, v .~ (uv \equiv w) \land (u \ne \lambda) \land \chi(p[x/u], v)$
- $\chi(ap, bw) = (a \equiv b \land \chi(p, w))$
- $\chi(\_, \_) = false$ otherwise

まあ当たり前のこと書いてるだけだ

## 標準形パターン

$p \preceq q \land p \succeq q \iff p \equiv q$ とすると、
変数のリネームは等価

パターン $p$ 中で出現する変数を左から
$x_1, x_2, ..., x_k$
としたものを標準形という

$k \leq |p|$ であって、言語は標準形にしても変わらないこと

## 極小学習戦略

正提示の断片 $\sigma[i]$ に対して
$$\{L(p) : \sigma[i] \subseteq L(p)\}$$
は有限であって空ではない

> $\top = x_1$ があるだからまぁ、な

というわけで 言語 $L(g_i)$ の中で $\subseteq$ に関して極小な
$g_i$
が存在する

これを計算する戦略を極小学習戦略と呼ぶ

- 最長のパターンが最小の言語を生成する

<span class="date">0619</span>

# KMP言語

## 部分列
アルファベット集合 $\Sigma$ の上の文字列の関係を次のように定義する

<center>
$u \lhd v \iff$ $u$ は $v$ の部分文字列である ($\exists x, y \in \Sigma^* .~ xuy \equiv v$)
</center>

- 反射律
- 推移律

## KMP言語

$w \in \Sigma^*$ の生成するKMP言語とは

$$L(w) = \{ v : w \lhd v \}$$

定義から 
$$u \lhd v \iff L(v) \subseteq L(u)$$
であることは明らか

## 極小学習

KMP言語は*有限の厚さ (finite thickness)* を持って、
極小言語学習の戦略で学習可能

有限証拠の最長共通部分文字列(連続列)をとればいいだけ

*有限の厚さ*
の定義を実のところ未だ知らない

<span class="date">0626</span>

1. 有限の厚さを持つ
1. 特徴例集合を持つ
1. 有限証拠を持つ

$1 \Rightarrow 2 \Rightarrow 3$ であって逆は成り立たない  
1.2. はMINLで正提示から学習が可能

## MINL

復習になるけど、言語クラス $C$ 中のある言語の有限部分証拠 $S$ があるときに

$L \in MINL(S, C)$
とは、
$S$を内包する$L' \in C$ のなかで極小なものの一つが$L$であること

言語クラスが何かを情報として使っていいことに注意

## 有限の厚さを持つ $\Rightarrow$ MINLは非空有限集合

$C$ が有限の厚さを持つとは、
<center>$\forall w .~ \{L:w\in L\in C\}$ が有限集合</center>

例えば今まで見てきたパターン言語やKMP言語といったクラスは有限の厚さを持つ

## 有限の厚さを持たない例

$L_i = \{ w : |w| \leq i \}$
($i < k \iff L_i \subset L_k$)

これは $w$ に対して $w \in L_i$ となる $i$ は可算無限個あって厚さは有限ではない.

しかしながら極小言語は簡単に考えられる:  
$MINL(\{w_1 .. w_n\}, C) = \{ L_k \}$
where $k = \max \{ |w_1| .. |w_n|\}$

## MINLが無限集合 $\Rightarrow$ 有限の厚さを持たない

これは自明.  
MINLが無限とはつまり有限証拠の任意の一つが属する言語が無限であることだから.

### MINLが無限集合となるような例

1. 言語 $L_i$ を $\{a^i\}$ の補集合として、この言語クラスを考える.
1. どの $L_i$ と $L_j$ も包含関係にそもそもないから任意の言語を持ってきて極小だと言える
1. $MINL(a^j, C) = \{ L_k : k \ne j \}$

## MINLが空の例

言語 $L_i$ は空文字列と長さが$i$より大きい語全体
$$L_i = \{\lambda\} \cup \{w:|w|>i\}$$
このとき
$L_0 \supset L_1 \supset ... \supset L_n \supset ... \supset \{\lambda\}$
という包含関係になる
$MINL(\{\lambda\}, C)$ を考えるとこれは空になる ($L_\infty$ というこの言語クラスにおけるボトムだ)

## ここまでのまとめ

- 有限の厚さ ならば MINLは非空有限
    - 有限の厚さでなくても MINLが無限でないこともある
- MINLが無限 ならば 有限の厚さではない

この二つは別に同値ではない  
有限の厚さはMINLを使うための十分条件でしかない

## 特徴例集合

言語クラス $C$ に関する言語 $L (\in C)$ の特徴例集合 $F$ とは

1. $F$ は有限集合
1. $F \subseteq L$
1. $\forall L' \in C .~ F \subseteq L' \Rightarrow L \subseteq L'$

*N.B.*
$L$が有限集合なら $F=L$ とすれば上は自明に満たされて、これは言語自身が特徴例集合だ

任意の $L$ が特徴例集合を持つとき、
「言語クラス $C$ は特徴例集合を持つ」という

## 例. 特徴例集合を持つが有限の厚さを持たない

先ほどの
$L_i = \{w:|w|\leq i\}$ を考える  
これは有限の厚さを持たなかった

さて $L_i$ は有限集合なので (アルファベットは有限集合) それ自身が特徴例集合だ

## Thm. 有限の厚さを持つならば、特徴例集合を持つ

厳密な証明ではないが...  
実際に特徴例集合を構成してみせればよい

$L$の特徴例集合 $F$ を構成することを考える

1. $F_0 = \{w_0\}$ s.t. $w_0 \in L$
1. for each $i$
    1. assert $F_i \subseteq L$
    1. $F_i \subseteq L'$ かつ not($L \subseteq L'$) となるような $L'$ は言語クラスの厚さゆえ有限である
    1. そのような $L'$ がないなら終了して $F = F_i$ とする
    1. not($L \subseteq L'$) と $L \cap L' \ne \emptyset$ から $L' \setminus L$ は非空
    1. $w \in L' \setminus L$ とする
    1. $F_{i+1} = F_i \cup \{w\}$

ループのたび 2-2 における $L'$ の数は必ず減っていくので有限ステップで終了する

## Thm. 特徴例集合をもつならば、MINLを使える

- 有限の厚さ $\Rightarrow$ MINL
- 有限の厚さ $\Rightarrow$ 特徴例集合
- 特徴例集合 $\Rightarrow$ MINL (`<- new!`)


証明は大体自明だと思う

言語 $L$ の正提示断片 $\sigma[i]$ からの推測 $L(g_i) (\supseteq L)$ は特徴例集合を持ってて、
その定義式ってまさしく極小を表してる

## 有限証拠の定義

言語 $L$ の有限部分集合 ($T$ とする) であって
$$\forall L' .~ T \subseteq L' \Rightarrow L' \not\subset L$$
とある $T$ を有限証拠という.

右辺は特徴例集合に似てるけど
"特徴例集合ならば有限証拠"
である.

### 例. 有限証拠であって特徴例集合ではないもの

言語クラス $C = \{L_1, L_2\}$;

- $L_1 = \{ a^n:n \} \cup \{b^n:n\}$
- $L_2 = \{ a^n:n \} \cup \{c^n:n\}$

一方は他方と異なる部分を持っている

$T = \{a^n:n\}$ は特徴例集合ではないが有限証拠としては問題ない

このような場合、提示として $\{a^n\}$
からなる列が来ても正しくMINLできない

<span class="date">0703</span>

1. 正提示から学習可能
2. (EC1) 有限証拠が*一様に帰納的列挙可能*
3. (C2) 特徴例集合を持つ
4. (C3) 有限の弾力性を持つ
5. (C4) 有限の厚さを持つ

$$5 \Rightarrow 4 \Rightarrow 3 \Rightarrow 2 \iff 1$$

これを見ていく

## EC1: 有限証拠の一様帰納的列挙

$i$ を入力として、$L_i$ の有限証拠 $T_i$ を列挙するような帰納的手続き.
即ち、マシーン $M$ は

$M(i) = \tau_1, \tau_2 ...$ where $\tau_k \subset L_i$ such that $\bigcup_k \tau_k = T_i$

というもの.

## 特徴例集合 $F$ が存在するならば、EC1 は満たされる.

## 有限の弾力性 (finite elasticity)

定義は以下通り:
$$\forall w, |\{ L : w \in L \}| < \infty$$

対義語は「無限の弾力性」.

<span class="date">0710</span>

## EC1 iff 極限同定可能

