<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>層の射、直積、冪、evaluation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">層の射、直積、冪、evaluation</h1>
<p><p class=date style='text-align: right'>2018-08-19 (Sun.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#層>層</a> <a class='tag is-red' href=index.html#圏論>圏論</a> </div></p>
\[
\require{amscd}
\def\ev{\mathrm{ev}}
\def\Hom{\mathrm{Hom}}
\]
<h2>層の定義</h2>
<p>ここでは次のものを層と呼ぶ.</p>
<p><div class=thm> 位相空間 \((X, \mathcal O_X)\) の上の層 \(A\) とは集合 \(A\) に</p>
<ul>
  <li>関数 \(E \colon A \to \mathcal O_X\)</li>
  <li>二項演算 \(\rceil \colon A \times \mathcal O_X \to A; a \rceil U \in A\)</li>
</ul>
<p>を加えたもののこと. ただし次の4つが要請される.</p>
<ol>
  <li>任意の \(a, b \in A\) に対して、 \(a \rceil \emptyset = b \rceil \emptyset\)</li>
  <li>\(a \rceil (Ea) = a\)</li>
  <li>\(E (a \rceil U) = Ea \cap U\)</li>
  <li>\((a \rceil U) \rceil V = a \rceil (U \cap V)\)</li>
</ol>
<p></div></p>
<p>ちなみに演算の優先度は, \(E\) への関数適用 \(&gt;\) \(\cap &gt; ~ \rceil\) .</p>
<h2>層の射</h2>
<p>層 \(A, B\) の間の射 \(A \to B\) とは, (2つを集合と見た時の) 写像 \(f \colon A \to B\) であって,</p>
<ol>
  <li>\(E(fa) = Ea\)</li>
  <li>\(f(a \rceil U) = f(a) \rceil U\)</li>
</ol>
<p>とあること. \(f\) が層 \(A\) から \(B\) への射であることを, 関数の時と全く同様に</p>
\[f \colon A \to B\]
<p>と書いて表す.</p>
<p>下は \(f\) が射になるため条件を可換図式に描き直したもの.</p>
\[
\begin{CD}
A       @&gt;E&gt;&gt;   O_X \\
@VfVV           @| \\
B       @&gt;E&gt;&gt;   O_X \\
\end{CD}
\]
\[
\begin{CD}
A       @&gt;f&gt;&gt;   B \\
@V\rceil UVV         @V\rceil UVV \\
A       @&gt;f&gt;&gt;   B \\
\end{CD}
\]
<h3>恒等射</h3>
<p>層 \(A\) から \(A\) 自身への射として自明なものとして恒等写像があり, これを \(1\) と書くことにする.</p>
\[1 \colon A \to A\]
\[1(a) = a\]
<h2>層の直積</h2>
<p>2つの層 \(A, B\) があるとき, 新しい層 \(A \times B\) を構成してこれを \(A\) と \(B\) との直積と呼ぶ. 集合の (カルテシアン) 直積とは異なる (寧ろその部分集合) ので注意.</p>
<ul>
  <li>
    \(A \times B = \{ (a, b) | a \in A, b \in B, Ea = Eb \}\)
    <ul>
      <li>\((a, b) \rceil U = (a \rceil U, b \rceil U)\)</li>
      <li>\(E(a, b) = Ea ~(= Eb)\)</li>
    </ul>
  </li>
</ul>
<blockquote>明らかに \(A \times A \simeq A\) である</blockquote>
<h3>射影</h3>
<p>層の直積 \(A \times B\) に対して次の2つが射としてある.</p>
<ul>
  <li>
    \(A \times B \to A\)
    <ul>
      <li>\(\pi_1 (a, b) = a\)</li>
    </ul>
  </li>
  <li>
    \(A \times B \to B\)
    <ul>
      <li>\(\pi_2 (a, b) = b\)</li>
    </ul>
  </li>
</ul>
<h3>射の積</h3>
<p>層 \(A,B,C,D\) とそれらの間の2つの射</p>
<ul>
  <li>\(f\colon A \to B\)</li>
  <li>\(g\colon C \to D\)</li>
</ul>
<p>があるとき自然に</p>
<ul>
  <li>\(f \times g \colon A \times C \to B \times D\)</li>
  <li>\((f \times g)(a, c) = (f a, g c)\)</li>
</ul>
<p>という射 \(f \times g\) を定義することができる.</p>
<p>念の為に確認すると,</p>
<p>\(f,g\) が射であることから \(E(f a) = Ea\) と \(E g(c) = Ec\) が従い, \((a,c) \in A \times C\) であることから \(Ea=Ec\) である. 従って \(E(f a)=E(g c)\) なので \((f a, g c) \in B \times D\) であることが分かって well-defined である.</p>
<h2>層の冪</h2>
<p>集合 \(A, B\) に対して集合 \(B^A\) を \(A\) から \(B\) への写像全体として定めたのと同様のことを層についても定める. 写像の代わりにちょうど層間の射 (のようなもの) を用いる.</p>
<p>層 \(A, B\) があるとき層 \(B^A\) を定めてこれを冪と呼ぶ.</p>
<ul>
  <li>
    \(B^A = \{ (f, V) | \text{関数}~f \colon A \to B, V \in \mathcal O_X \}\)
    <ul>
      <li>\(E(f,V) = V\)</li>
      <li>
        \((f,V) \rceil U = (f&#x27;, V \cap U)\)
        <ul>
          <li>\(f&#x27;\) は \(A \to B\) なる関数であって,</li>
          <li>\(f&#x27;(a) = f(a \rceil U)\)</li>
        </ul>
      </li>
      <li>
        ただし \((f, V) \in B^A\) について次の2つを要請する:
        <ul>
          <li>\(E(fa) = Ea \cap V\)</li>
          <li>\(f(a \rceil U) = f(a) \rceil U\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>さて, 元 \((f,V) \in B^A\) を, ただ単に \(f \in B^A\) と書くことにする. このとき \(f\) には \(Ef (=V) \in \mathcal O_X\) というデータが伴っているものとする. 単なる略記だと思えばよい. 例えば同じ一つの \(f\) について異なる2元 \((f, V_1), (f, V_2)\) が \(B^A\) に含まれることはありえるので, この2つを単に \(f\) と書いてしまうと区別ができないが, \(Ef\) というデータが暗に持たされているのであくまで異なるものと考える. (例えば一方を \(f_1\) と書いてもう一方を \(f_2\) と書くなど.)</p>
<p>この略記を用いて改めて \(B^A\) の定義を書くと次のようになる.</p>
<ul>
  <li>
    \(B^A = \{ f | \text{関数}~f \colon A \to B \}\)
    <ul>
      <li>
        \(Ef \in \mathcal O_X\)
        <ul>
          <li>(要請はあるがそれを満たすなら自由に定めてよい)</li>
        </ul>
      </li>
      <li>
        \(f \rceil U\) は次のような関数 \(f&#x27; \colon A \to B\)
        <ul>
          <li>\(f&#x27;(a) = f(a \rceil U)\)</li>
        </ul>
      </li>
      <li>
        ただし
        <ul>
          <li>\(E(fa) = Ea \cap Ef\)</li>
          <li>\(f(a \rceil U) = f(a) \rceil U\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<blockquote>\(f \in B^A\) は射そのものではない. 射の第二の要請は定義に含まれるため満たされるが, 第一の要請 \(E(fa)=Ea\) は一般には定義からは従わない.</blockquote>
<h2>evaluation</h2>
<p>\(f \in B^A\) は関数であるので \(a \in A\) を関数適用することができる. この関数適用という操作自体が射であることを見ていく.</p>
<p>関数 \(\ev\) を次のように定める.</p>
\[\ev \colon A \times B^A \to B\]
\[\ev \colon (a, f) \to f(a)\]
<p>ただしこの定義域の直積は <strong>層の直積</strong> であることに注意. すなわち, \((a,f) \in A \times B^A\) には \(E(a,f)=Ea=Ef\) という制約がある.</p>
<p>関数 \(\ev\) は射である. 射の定義に照らしあわせて確認できる.</p>
<h3>i)</h3>
\[\begin{align*}
E(\ev(a,f))
&amp; = E(f(a))     &amp; \cdots \text{関数evの評価} \\
&amp; = Ef \cap Ea  &amp; \cdots f \in B^A \text{ なので} \\
&amp; = E(a,f)      &amp; \cdots \text{層の直積}
\end{align*}\]
<h3>ii)</h3>
\[\begin{align*}
\ev((a,f) \rceil U)
&amp; = \ev (a \rceil U, f \rceil U) &amp; \cdots \text{直積の制限} \\
&amp; = (f \rceil U)(a \rceil U)    &amp; \cdots \text{関数evの評価} \\
&amp; = f((a \rceil U) \rceil U)    &amp; \cdots \text{冪の制限} \\
&amp; = f(a \rceil U)     &amp; \\
&amp; = fa \rceil U       &amp; \cdots \because f \in B^A \\
&amp; = \ev(a, f) \rceil U &amp; \cdots \text{関数evを逆に使った}
\end{align*}\]
<h3>冪の普遍性</h3>
<p>次の定理が成り立つ.</p>
<p>層 \(A, B, C\) と射 \(g \colon A \times C \to B\) があるとき, 次を可換にする射 \(h \colon C \to B^A\) が \(g\) に対して唯一存在する.</p>
\[
\begin{CD}
A \times C       @&gt;g&gt;&gt;    B  \\
@V1\times hVV             @| \\
A \times B^A     @&gt;\ev&gt;&gt;  B  \\
\end{CD}
\]
<p>このことは \(A\times C \to B\) という射全体と, \(C \to B^A\) という射全体とが一対一対応してることを言っている. このような性質を随伴という.</p>
<p>図式を可換にするような射 \(h\) が少なくとも1つは存在することと, そしてそれが2つ以上あるなら実は等しいので唯一であるという二工程で証明する.</p>
<h4>証明・存在性</h4>
<p>まず関数 \(h \colon C \to B^A\) を定義して, これが確かに射であることを確認する. 関数としては \(c \in C\) に対して \(f_c \in B^A\) とその \(Ef_c\) (あるいは \((f_c, Ef_c) \in B^A\) ) を, 先の図式が可換になるように割り当ててやればよい.</p>
<p>可換であるとはつまり, \((a, c) \in A \times C\) について次の2つ</p>
<ul>
  <li>\(g(a, c)\) ,</li>
  <li>\(\ev((1 \times h)(a, c)) = \ev(a, hc) = (hc)(a) = f_c(a)\)</li>
</ul>
<p>が等しいこと. そのようにしたいので, これをそのまま</p>
\[f_c(a) = g(a, c)\]
<p>として \(f_c\) を定めればよい (仮の定義).</p>
<p>ただし注意として, 今考えた \((a, c)\) は直積から取ってきた点であるので \(Ea=Ec\) という制約があり, 全ての点の \(a\) について \(f_c(a)\) の値が定まっているわけではない. しかしながら \(f_c\) は一般に \(A \to B\) なる関数である必要があるので, 先程の \(f_c\) の定義では未だ部分関数でしかない.</p>
<p>修正をします.</p>
\[f_c(a) = g(a \rceil Ec, c \rceil Ea)\]
<p>注意として \((a,c) \in A \times C (\iff Ea=Ec)\) については, 相変わらず \(f_c(a)=g(a,c)\) を満たしているので可換性は守られている.</p>
<p>というわけで \(c \in C\) に対して関数</p>
\[f_c \colon A \to B\]
<p>を定義することができた.</p>
<p>次に \(Ef_c \in \mathcal O_X\) という値を定める. これは \(f_c\) とは独立に決めて良よくて, ここでは</p>
\[Ef_c = Ec\]
<p>と定める. これは, 関数 \(h\) を \(h(c)=f_c\) という風に定めるつもりでいるのだが, \(h\) が射であるようにするために</p>
\[E(hc)=Ec\]
<p>となる必要があるので, そのために自動的に決まる.</p>
<p>次に, 関数 \(h \colon C \to B^A\) を定義する.</p>
\[h(c) = (f_c, Ef_c) = (f_c, Ec)\]
<p>とすればよい. ただしこれが well-defined であることを確認する必要がある. つまり \(f_c \in B^A\) であるかだが, これは下のように確かめられる.</p>
<p><div class=thm> \(f_c \in B^A\) の証明.</p>
<p>冪の定義に従って, 次の2つを確かめれば良い.</p>
<ol type=a>
  <li>\(E(f_c(a)) = Ea \cap Ef_c\)</li>
  <li>\(f_c(a \rceil U) = f_c(a) \rceil U\)</li>
</ol>
<p>1つ目は</p>
\[\begin{align*}
E(f_c(a))
&amp; = E(g(a \rceil Ec, c \rceil Ea))     &amp; \cdots f_c \text{ の定義} \\
&amp; = E(a \rceil Ec, c \rceil Ea)        &amp; \cdots g \text{ は射} \\
&amp; = E(a \rceil Ec)                     &amp; \cdots \text{ 直積の E の定義}\\
&amp; = Ea \cap Ef_c
\end{align*}\]
<p>なので.</p>
<p>2つ目は</p>
\[\begin{align*}
f_c(a \rceil U)
&amp; = g(a \rceil U \rceil Ec, c \rceil Ea \rceil U)     &amp; \cdots f_c \text{ の定義} \\
&amp; = g(a \rceil Ec, c \rceil Ea) \rceil U              &amp; \cdots \text{ 直積の制限} \\
&amp; = f_c(a) \rceil U
\end{align*}\]
<p>なので. </div></p>
<p>以上で関数</p>
\[h \colon C \to B^A\]
\[h(c) = (f_c, Ef_c)\]
<p>が定義された!</p>
<p>次に \(h\) が射であることを確認する.</p>
<ol type=a>
  <li>\(E(hc) = Ef_c=Ec\)</li>
  <li>
    \(h(c \rceil U) = (f_{c \rceil U}, Ef_{c \rceil U}) = (f_{c \rceil U}, E(c \rceil U))\)
    <ul>
      <li>
        \(f_{c \rceil U}(a) = g(a \rceil Ec \cap U, c \rceil U \rceil Ea) = f_c(a) \rceil U = (f_c \rceil U)(a)\)
        <ul>
          <li>よって (関数として) \(f_{c \rceil U} = f_c \rceil U\)</li>
        </ul>
      </li>
      <li>
        \(Ef_{c \rceil U} = E(c \rceil U) = Ec \cap U = E(f_c \rceil U)\)
        <ul>
          <li>以上2つより \(h(c \rceil U) = hc \rceil U\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
<p>であるので確かに, 可換にするような射 \(h \colon C \to B^A\) は少なくとも一つは存在する.</p>
<h4>証明・唯一性</h4>
<p>与えられた \(g\) に対してこのような \(h\) は唯一しか存在しない. これを示す常套的手段として次のような方法を取る. 今 \(h\) の他に \(h&#x27;\) があるとき, 実は \(h=h&#x27;\) であることを示す. これによって, 2つ以上存在することが言えなくなる. 先ほどの存在性と合わせることで, 唯一の存在であることが言えたことになる.</p>
<p>\(h&#x27;\) もまた上の図式を可換にするような射であるとする.</p>
\[\forall c \in C, h(c) = h&#x27;(c)\]
<p>を示すことで \(h=h&#x27;\) を言うことにする.</p>
<p>自由に取ってきた \(c \in C\) について, \(h(c) = h&#x27;(c)\) を言う. 注意として \(h(c) \in B^A\) であるので, この値の等価性を示すには \(h(c)=(f,Ef)\) とすると \(f\) の関数としての等価性と \(Ef\) の集合としての等価性を合わせて言う必要がある.</p>
<ol type=a>
  <li>2つは射であるので</li>
</ol>
\[E(hc)=Ec=E(h&#x27;c)\]
<ol type=a>
  <li>\(h(c)=h&#x27;(c)\) を示す.</li>
</ol>
<p>2つは \(A \to B\) な関数なので, 好きに取ってきた \(a \in A\) について \(h(c)(a) = h&#x27;(c)(a)\) を示せばよい.</p>
<p>今もし \(Ea=Ec \iff (a,c) \in A \times C\) ならば, 可換性より即座に \(h(c)(a) = \ev(a,hc)=g(a,c)=\cdots=h&#x27;(c)(a)\) が言える.</p>
<p>さて \(E(h(c)(a))=E(f_c(a))=Ef_c\cap Ea=Ec \cap Ea\) であるので \(h(c)(a) = h(c)(a) \rceil Ec \cap Ea ( \in B)\) であるが,</p>
\[\begin{align*}
h(c)(a) \rceil Ec \cap Ea
&amp; = h(c) (a \rceil Ec) \rceil Ea  &amp; \cdots h c \in B^A \text{ なので} \\
&amp; = (hc \rceil Ea) (a \rceil Ec)  &amp; \cdots h c \in B^A \text{ なので} \\
&amp; = (h(c \rceil Ea)) (a \rceil Ec)  &amp; \cdots h \text{ が射なので} \\
\end{align*}\]
<p>であるので結局 \((a&#x27;,c&#x27;)=(a \rceil Ec, c \rceil Ea)\) を \(h\) に適用した場合を考えればよくて, このとき \(Ea&#x27;=Ec&#x27;\) であるので先ほどの議論から \(h\) の値と \(h&#x27;\) の値は等しい.</p>
<p>以上から \(h=h&#x27;\) .</p>
<h3>メモ</h3>
<p>層 \(A\) から \(B\) への射全体を \(\Hom(A,B)\) と書くと, 今の定理はつまり</p>
\[\Hom(A \times C, B) \simeq \Hom(C, B^A)\]
<p>であることを主張していた.</p>
<p>この \(A\) の部分を隠してやると, 適当な \(F,G\) を用いて</p>
\[\Hom(F(C), B) \simeq \Hom(C, G(B))\]
<p>と書き直せる. これを <a href="https://ja.wikipedia.org/wiki/%E9%9A%8F%E4%BC%B4%E9%96%A2%E6%89%8B">随伴</a> という. \(F,G\) を随伴関手という.</p>
<h3>メモ</h3>
<p>今の定理はカリーハワード対応を書いてやると</p>
<ul>
  <li>
    論理
    <ul>
      <li>\(\left( (A \land C) \implies B \right) \iff \left( C \implies A \implies B \right)\)</li>
    </ul>
  </li>
  <li>
    プログラム (Haskell)
    <ul>
      <li><code>(a, c) -&gt; b</code> \(\iff\) <code>c -&gt; a -&gt; b</code></li>
      <li>左から右をカリー化という</li>
    </ul>
  </li>
</ul>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>