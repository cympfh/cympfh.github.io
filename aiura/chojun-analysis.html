<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>超準解析</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">超準解析</h1>
<p><p class=date style='text-align: right'>2017-02-12 (Sun.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#フィルタ>フィルタ</a> </div></p>
<h2>超準解析とは何か?</h2>
<p>1960年に Abraham Robinson が作った nonstandard analysis は無限の数を扱うなんか計算モデル？ standard analysis (epsilon-delta) の上位互換として作られる.</p>
<h2>定義</h2>
<p>以下を満たす \(U\) を集合 \(J\) 上のフィルタ (filter) と呼ぶ.</p>
<ol>
  <li>\(U \subseteq 2^J\)</li>
  <li>\(\emptyset \not\in U\)</li>
  <li>\(\forall A, B \in U, A \cap B \in U\) (intersection property)</li>
  <li>\(\forall A \in U, \forall B (A \subseteq B), B \in U\)</li>
</ol>
<p>以下の \(U\) を \(J\) 上の超ウィルタ (ultrafilter) と呼ぶ.</p>
<ol>
  <li>\(U\) は \(J\) 上のフィルタ</li>
  <li>
    \(\forall A \in J\) について次のどちらかちょうど一つが成立 (maximality)
    <ol>
      <li>\(\{A\} \in U\)</li>
      <li>\(J \setminus \{A\} \in U\)</li>
    </ol>
  </li>
</ol>
<p>以下の \(U\) を \(J\) 上の自由超フィルタ (free-ultrafilter) と呼ぶ.</p>
<ol>
  <li>\(U\) は \(J\) 上の超フィルタ</li>
  <li>\(\nexists A \in U, |A| &lt; \infty\) (freeness)</li>
</ol>
<h2>諸定理</h2>
<h3>定理</h3>
<p>\(A\) 上の超フィルタ \(U\) 及び \(A\) の有限個への分割 \(A_1, \ldots, A_n\) について</p>
\[\exists! i, A_i \in U\]
<p>が成立する.</p>
<h3>証明</h3>
<p>まず、 \(\exists i, A_i \in U\) を背理法によって示す.</p>
<p>\(\forall i, A_i \not\in U\) を仮定すると maximality 故に \(\forall i, A \setminus A_i \in U\) . 更に intersection property から \(\emptyset = \bigcap_i (A \setminus A_i) \in U\) . これは \(U\) の超フィルタの定義に反する.</p>
<p>従って \(\exists i, A_i \in U\) は成立する.</p>
<p>異なる \(i = i_1, i_2\) についてこれが成立するとき、同様に \(\emptyset = \cap_{i=i_1, i_2} A_i \in U\) となるので、そのような \(i_1, i_2\) は存在しない.</p>
<p>以上から唯一の \(i\) で成立する.</p>
<h3>定理</h3>
<p>\(A\) 上のフィルタ \(F&#x27;\) から超フィルタ \(F\) を導くことができる. \(\Phi\) を \(A\) 上のフィルタ全てからなる集合とする ( \(F&#x27; \in \Phi\) ).</p>
<p>\(\Phi\) の元に関して包含関係によって半順序を附けることができる. その最大限が欲しかった超フィルタ \(F\) である.</p>
<h3>証明</h3>
<p>(略)</p>
<h2>定義</h2>
<p>2つの \(n\) 次元実ベクトル \(a, b\) 、実数に関する二項演算 \(\circ\) に関して、 \(\{ i : 1 \leq i \leq n, a_i \circ b_i \}\) を</p>
\[[\![ a \circ b ]\!]\]
<p>と書くことにする. 例えば \([\![ a = b ]\!]\) は、成分の値が等しいインデックスの集合.</p>
<h3>超フィルタの法の下の等号性 (Equivalence Modulo an Ultrafilter)</h3>
<p>超フィルタ \(U\) 及び2つの \(n\) 次元実ベクトル \(a, b\) について</p>
\[a = b \mod{U} \iff [\![ a=b ]\!] \in U\]
<h3>超フィルタの法の下の順序</h3>
\[a \leq b \mod{U} \iff [\![ a \leq b ]\!] \in U\]
<p>この順序は全順序である.</p>
<h3>例</h3>
<ul>
  <li>\(\mathbb{a} = (0, 1, 0, 1, \ldots)\)</li>
  <li>\(\mathbb{b} = (1, 0, 1, 0, \ldots)\)</li>
  <li>\(\mathbb{0} = (0, 0, 0, 0, \ldots)\)</li>
  <li>\(\mathbb{1} = (1, 1, 1, 1, \ldots)\)</li>
</ul>
<p>について</p>
<ul>
  <li>\(\mathbb{a} \ne \mathbb{b} \mod{U}\)</li>
  <li>\(\mathbb{a} = 0 \mod{U}\) または \(\mathbb{a} = 1 \mod{U}\)</li>
  <li>\(\mathbb{b} = 0 \mod{U}\) または \(\mathbb{b} = 1 \mod{U}\)</li>
</ul>
<p>が \(U\) によって成立する. 例えば \(\{0,2,4,\ldots\} \in U\) なる超フィルタが作れる.</p>
<h2>Ultrapower</h2>
<p>ある超フィルタ \(U\) を法とする等号によって \(n\) 次元実ベクトル空間 \(R^n\) の同値類を取った空間を <strong>超実空間 (hyperreal)</strong> と呼び \({}^*R\) と書く. 次のように加算と乗算を定めることで体になる.</p>
<ul>
  <li>\(\mathbb{a} + \mathbb{b} = (a_1, a_2, \ldots) + (b_1, b_2, \ldots) = (a_1 + b_1, a_2 + b_2, \ldots)\)</li>
  <li>\(\mathbb{a} * \mathbb{b} = (a_1, a_2, \ldots) * (b_1, b_2, \ldots) = (a_1 * b_1, a_2 * b_2, \ldots)\)</li>
</ul>
<p>成り立ってほしい性質はだいたい成り立つ.</p>
<ul>
  <li>\(a_1=a_2 \land b_1=b_2 \mod U\)</li>
  <li>\(\iff [\![ a_1=a_2 ]\!] \in U \land [\![ b_1=b_2 ]\!] \in U\)</li>
  <li>\(\implies [\![ a_1=a_2 ]\!] \cap [\![ b_1=b_2 ]\!] \in U\)</li>
  <li>\(\iff [\![ a_1=a_2 \land b_1=b_2 ]\!] \in U\)</li>
  <li>\(\iff [\![ a_1+b_1=a_2+b_2 ]\!] \in U\)</li>
  <li>\(\iff a_1 + b_1 = a_2 + b_2 \mod U\)</li>
</ul>
<p>加算に関する単位元</p>
<ul>
  <li>\(a + zero = a \mod U\)</li>
  <li>\(\iff [\![a + zero = a]\!] \in U \iff [\![zero=0]\!] \in U\)</li>
  <li>\(\iff zero = 0 \mod U\)</li>
</ul>
<p>同様に乗算に関する単位元</p>
<ul>
  <li>\(a * one = a \mod U\)</li>
  <li>\(\iff one = 1 \mod U\)</li>
</ul>
<p>\(U\) の法の下で、それぞれ単位元は唯一に存在する.</p>
<p>逆元</p>
<ul>
  <li>\(a = (-a_1, -a_2, \ldots)\)</li>
  <li>\(\implies a + (-a) = 0 \mod U\)</li>
</ul>
<p>とすることで \(+\) に関する \(a\) の逆元 \((-a)\) を構成することができる. 唯一の存在であることも確認できる. 2つの逆元 \(m, n\) があるとする.</p>
<ul>
  <li>\(a + m = 0 \mod U\)</li>
  <li>\(a + n = 0 \mod U\)</li>
</ul>
<p>このとき</p>
<ul>
  <li>\(a + m + n = 0 + n = n \mod U\)</li>
  <li>\(a + m + n = 0 + m = m \mod U\)</li>
</ul>
<p>ということで自明に \(m = n \mod U\) . というわけで \(U\) の法の下で逆元は唯一.</p>
<p>乗算に関してもだいたい実数と同じ.</p>
<h2>無限小、無限大</h2>
<p>自然数の列の集合を \({}^*N\) と書く. \(a \in {}^*R\) と \(n \in {}^*N\) との大小を超フィルタ \(U\) の下で定める.</p>
<ol>
  <li>\(\forall n \in {}^*N, a \leq n\) を満たす \(a\) を無限小と呼ぶ.</li>
  <li>\(\forall n \in {}^*N, a \geq n\) を満たす \(a\) を無限大と呼ぶ.</li>
</ol>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>