<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>層</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon" style="position:absolute; left:0.4em; top:0.4em; width:1.3em;border-radius:0.8em;"></i></a>
</header>
<header>
<h1 class="title">層</h1>
</header>
<p class="date" style="text-align: right">
2017-11-12 (Sun.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#層>層</a></p>
</div>
<h2 id="index">index</h2>
<div id="toc">

</div>
<p><span class="math display">\[\def\O{\mathcal{O}}\]</span></p>
<h2 id="前層-preshaef">前層 (preshaef)</h2>
<p>二通りの定義を与える.</p>
<h3 id="定義1">定義1</h3>
<div class="thm">
<p>位相空間 <span class="math inline">\(X\)</span> の <strong>前層</strong> とは、 集合 <span class="math inline">\(A\)</span>, 関数 <span class="math inline">\(E: A \rightarrow \O(X)\)</span>, 関数 <span class="math inline">\(\rceil: A \times \O(X) \rightarrow A\)</span> (<span class="math inline">\((a, U) \mapsto a \rceil U\)</span>) からなる三組 <span class="math inline">\((A, E, \rceil)\)</span> であって次のようなもの.</p>
<ol start="0" type="1">
<li>任意の <span class="math inline">\(a, b \in A\)</span> に対して <span class="math inline">\(a \rceil \emptyset = b \rceil \emptyset\)</span></li>
<li><span class="math inline">\(a \rceil Ea = a\)</span> <span class="math inline">\(~~~\)</span>(註意: <span class="math inline">\(\rceil\)</span> の結合則は <span class="math inline">\(E\)</span> の適用より弱い)</li>
<li><span class="math inline">\(E (a \rceil U) = E a \cap U\)</span></li>
<li><span class="math inline">\((a \rceil U) \rceil V = a \rceil U \cap V\)</span> <span class="math inline">\(~~\)</span> (註意: <span class="math inline">\(\cap\)</span> の結合則のが <span class="math inline">\(\rceil\)</span> より強い)</li>
</ol>
</div>
<h4 id="例">例</h4>
<p>関数の集合 <span class="math inline">\(A\)</span>, 関数の定義域を与える手続き <span class="math inline">\(E\)</span>, 普通の意味で関数の(定義域の)制限 <span class="math inline">\(\rceil\)</span>.</p>
<p>註意すべき点として、層としての制限 <span class="math inline">\(\rceil\)</span> の右項には <span class="math inline">\(Ef\)</span> よりも広い集合を与えても構わないということ. 関数の制限 (これを区別する意味で <span class="math inline">\(\lceil\)</span> と書く) の右項には普通、ドメインより小さい領域を与えるだろう. そこで次のように <span class="math inline">\(\rceil\)</span> を定め直せばよい: <span class="math display">\[f \rceil U := f \lceil (Ef \cap U)\]</span></p>
<p>また、ドメインが空集合な関数は空集合ただ1つである. <span class="math display">\[f \rceil \emptyset = \emptyset = g \rceil \emptyset\]</span></p>
<p>ドメイン (定義域) が空集合であるような関数は <strong>存在しない</strong> しないのではなく, <strong>唯1つ</strong> 存在することに註意 (参考; <a href="https://ja.wikipedia.org/wiki/%E7%A9%BA%E9%96%A2%E6%95%B0">空関数</a>).</p>
<blockquote>
<p>明らかに前層とはこれを抽象化したものである</p>
</blockquote>
<h3 id="定義2">定義2</h3>
<div class="thm">
<p>位相空間 <span class="math inline">\(X\)</span> の <strong>前層</strong> とは、 <span class="math inline">\(X\)</span> の開集合を適当な集合の集合 <span class="math inline">\(\mathcal{A}\)</span> に写すような <span class="math display">\[F : \O(X) \to \mathcal{A}\]</span> 及び <span class="math inline">\(U,V \in \O(X)\)</span> について <span class="math inline">\(U \subseteq V\)</span> ならば <span class="math display">\[r_{UV} : F(V) \to F(U)\]</span> が定まっているようなもの. これらの <span class="math inline">\(\left(F, r = \{ r_{UV} : U, V \in \O(X) \}\right)\)</span> を前層だという. ただし次を要請する.</p>
<ol start="0" type="1">
<li><span class="math inline">\(F(\emptyset)\)</span> は単集合</li>
<li><span class="math inline">\(r_{UU}\)</span> は恒等写像</li>
<li><span class="math inline">\(U \subseteq V \subseteq W\)</span> のとき <span class="math inline">\(r_{UW} = r_{UV} \circ r_{VW}\)</span></li>
</ol>
</div>
<p>こちらは圏論的に <strong>関手</strong> として前層を定義している (参考; <a href="http://cympfh.cc/taglibro/2018/07/17.html">前層はモノイド(右)作用の一般化</a>).</p>
<p>これら2つの定義が等価であることを確認する.</p>
<h3 id="定義1-定義2">定義1 → 定義2</h3>
<div class="thm">
<p>前層が <span class="math inline">\((A,E,\rceil)\)</span> で与えられた時、次で定義2を構成できる.</p>
<ol type="1">
<li><span class="math inline">\(F(U) = \{ f \in A : Ef = U \}\)</span></li>
<li><span class="math inline">\(r_{UV}(f) = f \rceil U\)</span></li>
</ol>
</div>
<p>要請を満たすことを確認する.</p>
<ol start="0" type="1">
<li><span class="math inline">\(F(\emptyset) = \{ f : Ef = \emptyset \}\)</span> は単集合か?
<ul>
<li><span class="math inline">\(f = f \rceil (Ef)\)</span> より <span class="math inline">\(f \in F(\emptyset) \Rightarrow f = f \rceil \emptyset\)</span></li>
<li><span class="math inline">\(F(\emptyset)\)</span> が 2つ以上の要素をもって <span class="math inline">\(f,g\)</span> がそうであるとき、
<ul>
<li><span class="math inline">\(f = f\rceil \emptyset = g\rceil \emptyset = g\)</span></li>
<li>従って、<span class="math inline">\(F(\emptyset)\)</span> は要素を高々1つしか持たない</li>
</ul></li>
<li>また <span class="math inline">\(F(\emptyset)\)</span> は空集合でもない
<ul>
<li>任意の <span class="math inline">\(a\)</span> について
<ul>
<li><span class="math inline">\(E(a \rceil \emptyset) = Ea \cap \emptyset = \emptyset\)</span></li>
</ul></li>
<li>であるので、<span class="math inline">\((a \rceil \emptyset) \in F(\emptyset)\)</span></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(r_{UU}\)</span> は恒等写像か?
<ul>
<li>明らか</li>
</ul></li>
<li><span class="math inline">\(r_{UW} = r_{UV} \circ r_{VW}\)</span>
<ul>
<li><span class="math inline">\(r_{VW} : F(W) \to F(V)\)</span></li>
<li><span class="math inline">\(r_{UV} : F(V) \to F(U)\)</span></li>
<li><span class="math inline">\(f \in F(W) = \{ f : Ef = W \}\)</span> について
<ul>
<li><span class="math inline">\(r_{VW}(f) = f \rceil V\)</span></li>
<li><span class="math inline">\((r_{UV} \circ r_{VW}(f) = (f \rceil V) \rceil U = f \rceil (V \cap U) = f \rceil U = r_{UV}(f)\)</span></li>
</ul></li>
</ul></li>
</ol>
<p>というわけでok.</p>
<h3 id="定義2-定義1">定義2 → 定義1</h3>
<div class="thm">
<p>逆に前層が <span class="math inline">\((F, r)\)</span> で与えられたとき、 先ほどの全く逆によって構成できる.</p>
<ol type="1">
<li><span class="math inline">\(A = \bigcup_{U \in \O(X)} F(U)\)</span></li>
<li><span class="math inline">\(f \in F(U) \iff Ef = U\)</span></li>
<li><span class="math inline">\(f \rceil U = r_{VW}(f)\)</span>
<ul>
<li>where <span class="math inline">\(V = U \cap W, W=Ef\)</span></li>
</ul></li>
</ol>
</div>
<p>要請を満たすことを確認する.</p>
<ol start="0" type="1">
<li><span class="math inline">\(a,b \in A\)</span> について
<ul>
<li><span class="math inline">\(a \rceil \emptyset = r_{VW}(a)\)</span>
<ul>
<li>ここで <span class="math inline">\(V = \emptyset, W = Ef = U_a\)</span> で
<ul>
<li><span class="math inline">\(r_{VW} : F(W) \to F(V)\)</span></li>
<li><span class="math inline">\(F(V)\)</span> は単集合であるので、 <span class="math inline">\(r_{VW}\)</span> は一点に写す関数</li>
</ul></li>
<li>従って <span class="math inline">\(r_{VW}(a) = r_{VW&#39;}(b)\)</span></li>
</ul></li>
<li>よって <span class="math inline">\(a \rceil \emptyset = b \rceil \emptyset\)</span></li>
</ul></li>
<li><span class="math inline">\(f \rceil (Ef) = r_{VW} f\)</span>
<ul>
<li>ただし <span class="math inline">\(V = Ef \cap W, W = Ef\)</span></li>
<li>なので <span class="math inline">\(V=W\)</span> なんで <span class="math inline">\(r_{VW}\)</span> は恒等写像</li>
<li>というわけで、 <span class="math inline">\(f \rceil (Ef) = f\)</span></li>
</ul></li>
<li><span class="math inline">\(f \rceil U = r_{VW}(f) \in F(V)\)</span>
<ul>
<li>ここで <span class="math inline">\(V = U \cap Ef\)</span></li>
<li><span class="math inline">\(E(f \rceil U) = V = U \cap Ef\)</span></li>
</ul></li>
<li><span class="math inline">\((f \rceil U) \rceil V = f \rceil (U \cap V)\)</span>
<ul>
<li>大体同様に</li>
</ul></li>
</ol>
<p>ところでしかし、この定義1と2とが本当に対応してるかを見るには、 定義1の前層を定義2に(上の方法で)した後、再び(上の方法で)定義1に戻して得た前層が、元の前層と同じ (あるいは同型) であることを確かめないといけない.</p>
<h2 id="両立-compatible">両立 (compatible)</h2>
前層 <span class="math inline">\(A\)</span> の2つの元 <span class="math inline">\(f, g \in A\)</span> が <strong>両立</strong> するとは、
<div class="thm">
<p><span class="math display">\[f \rceil Eg = g \rceil Ef\]</span></p>
</div>
<p>とあること.</p>
<p>関数集合の例でいうと、 定義域の交わる部分で関数の値が一致することを表す.</p>
<h2 id="層-sheaf">層 (sheaf)</h2>
<p>やはり二通りの定義を与える.</p>
<h3 id="定義1-1">定義1</h3>
<p><span class="math inline">\(X\)</span> の上の前層 <span class="math inline">\(A\)</span> が次を満たすとき、<span class="math inline">\(A\)</span> を <span class="math inline">\(X\)</span> の上の <strong>層</strong> と呼ぶ.</p>
<div class="thm">
<ul>
<li><span class="math inline">\(\forall f,g \in F\)</span> が両立するような <span class="math inline">\(F \subset A\)</span> に対して、次の2つを成立させる <span class="math inline">\(g\)</span> が唯一つ存在すること
<ol type="1">
<li><span class="math inline">\(\forall f \in F, g \rceil Ef = f\)</span></li>
<li><span class="math inline">\(Eg = \bigcup_{f \in F} Ef\)</span>
<ul>
<li>このような <span class="math inline">\(g\)</span> を <span class="math inline">\(F\)</span> に対して <span class="math inline">\(\cup F\)</span> と書く</li>
</ul></li>
</ol></li>
</ul>
</div>
<h4 id="例-1">例</h4>
<p>前に述べた関数の例は層である</p>
<h3 id="定義2-1">定義2</h3>
<p>定義1と同値な定義を与える.</p>
<div class="thm">
<p>位相空間 <span class="math inline">\(X\)</span> に対して 位相空間 <span class="math inline">\(S\)</span> と局所同相写像 <span class="math inline">\(p: S \to X\)</span> があるとき、 <span class="math inline">\((S, p)\)</span> を <span class="math inline">\(X\)</span> の上の <strong>層</strong> という.</p>
</div>
<p>ここで <span class="math inline">\(p: S \to X\)</span> が局所同相写像とは、任意の点 <span class="math inline">\(s \in S\)</span> に対して、 定義域を <span class="math inline">\(s\)</span> を含むように適切に小さく制限して得た写像 <span class="math inline">\(p \lceil U\)</span> が同相写像であること.</p>
<h3 id="定義1-定義2-1">定義1 → 定義2</h3>
<p>層 <span class="math inline">\(A\)</span> が与えられた時、 <span class="math display">\[\tilde{S} = \{ (x, f) ~:~ f \in A, x \in Ef \}\]</span> <span class="math inline">\(\tilde{S}\)</span> の上の同値関係 <span class="math display">\[(x_1,f_1) \equiv (x_2, f_2) \iff
x_1=x_2
\land
\exists U (x \in U), U \subseteq Ef_1\cap Ef_2 \land
f_1 \rceil U = f_2 \rceil U\]</span> で割って <span class="math display">\[S = \tilde{S}\!\!\equiv\]</span> とする. 同値関係で明らかに <span class="math inline">\(x\)</span> については1つに定まるので <span class="math display">\[p : S \to X\]</span> <span class="math display">\[p (x, f) = x\]</span> という関数が定まる.</p>
<p><span class="math inline">\(S\)</span> に位相を入れる. <span class="math inline">\(x \in X\)</span> の近傍を <span class="math inline">\(V_x\)</span> とするとき <span class="math inline">\((x,f)\)</span> の近傍を <span class="math display">\[\{ (y, f) /\! \equiv ~:~ y \in V_x\}\]</span> と定める. これによって位相を入れる (<a href="neigh-to-topo.html">近傍によって位相を入れる</a> 参照).</p>
<p>以上の <span class="math inline">\((S,p)\)</span> が層 <span class="math inline">\(A\)</span> に対応する定義2の形の層である.</p>
<h3 id="定義2-定義1-1">定義2 → 定義1</h3>
<p><span class="math inline">\(X\)</span> 上の層 <span class="math inline">\((S,p)\)</span> から <span class="math inline">\((A,E,\rceil)\)</span> の形の層を次のようにして構成できる.</p>
<p><span class="math inline">\(U \in \O(X)\)</span> について <span class="math display">\[\Gamma(U) = \{ f : f:U \to S, p \circ f = i \}\]</span> として</p>
<ol type="1">
<li><span class="math inline">\(A = \bigcup \Gamma(U)\)</span></li>
<li><span class="math inline">\(Ef=U \iff f \in \Gamma(U)\)</span></li>
<li><span class="math inline">\(f \rceil V = f \lceil (V \cap Ef)\)</span>
<ul>
<li>右辺は単なる関数の制限</li>
</ul></li>
</ol>
<p>定義2 であっても前層でかつ定義1の層と一致することがわかる.</p>
<p>ここで <span class="math inline">\(\Gamma\)</span> の定義で出てくる <span class="math inline">\(i\)</span> は <span class="math inline">\(U \to X\)</span> の埋め込みである. <span class="math inline">\(\Gamma(U)\)</span> の要素は <span class="math inline">\(p\)</span> に対する <span class="math inline">\(U\)</span> 上の切断のこと. 以下のような可換図式が成り立つ.</p>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="254pt" height="74pt" viewBox="0.00 0.00 254.00 74.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 70)">
<title>
%3
</title>
<!-- U -->
<g id="node1" class="node">
<title>
U
</title>
<text text-anchor="middle" x="27" y="-14.3" font-family="Times,serif" font-size="14.00">U</text> </g> <!-- S --> <g id="node2" class="node">
<title>
S
</title>
<text text-anchor="middle" x="122" y="-44.3" font-family="Times,serif" font-size="14.00">S</text> </g> <!-- U&#45;&gt;S --> <g id="edge1" class="edge">
<title>
U-&gt;S
</title>
<path fill="none" stroke="black" d="M54.4013,-26.5166C64.0054,-29.6146 75.0259,-33.1696 85.3015,-36.4844"/> <polygon fill="black" stroke="black" points="84.2629,-39.8269 94.8546,-39.566 86.412,-33.1649 84.2629,-39.8269"/> <text text-anchor="middle" x="74.5" y="-36.8" font-family="Times,serif" font-size="14.00">f</text> </g> <!-- X --> <g id="node3" class="node">
<title>
X
</title>
<text text-anchor="middle" x="219" y="-14.3" font-family="Times,serif" font-size="14.00">X</text> </g> <!-- U&#45;&gt;X --> <g id="edge3" class="edge">
<title>
U-&gt;X
</title>
<path fill="none" stroke="black" d="M54.2669,-12.1836C66.5685,-9.74635 81.4637,-7.20264 95,-6 118.906,-3.87608 125.089,-3.93626 149,-6 159.721,-6.9253 171.275,-8.64497 181.806,-10.4992"/> <polygon fill="black" stroke="black" points="181.456,-13.9939 191.927,-12.3738 182.731,-7.11097 181.456,-13.9939"/> <text text-anchor="middle" x="122" y="-9.8" font-family="Times,serif" font-size="14.00">i</text> </g> <!-- S&#45;&gt;X --> <g id="edge2" class="edge">
<title>
S-&gt;X
</title>
<path fill="none" stroke="black" d="M149.211,-39.723C159.386,-36.5095 171.206,-32.7771 182.147,-29.3221"/> <polygon fill="black" stroke="black" points="183.393,-32.599 191.875,-26.25 181.285,-25.9239 183.393,-32.599"/> <text text-anchor="middle" x="170.5" y="-36.8" font-family="Times,serif" font-size="14.00">p</text> </g> </g>
</svg>
<!--

  HTML として pandoc -B で include する.

  <H2> を列挙してそれらにリンクを貼った toc を id='toc' に埋め込む.
  markdown で書いてるだろうから例として次のような段落を書けばよい.

```
## INDEX
<div id=toc></div>
```

  used in
  - /memo/gnuplot
  - /memo/linux
  - /memo/imagemagick

-->
<script>
(function() {
  var sections = document.getElementsByTagName('h2');
  var i;
  var OL = document.createElement('ol');
  for (i=0; i < sections.length; ++i) {
    var LI = document.createElement('li');
    var A = document.createElement('a');
    A.innerHTML = sections[i].innerHTML;
    if (A.innerHTML.toUpperCase() == 'INDEX') continue;
    A.href = '#' + i;
    LI.appendChild(A);
    OL.appendChild(LI);

    var PREF = document.createElement('a');
    PREF.name = i;
    sections[i].appendChild(PREF);
  }

  var done = false;
  function work() {
    if (done) return;
    if ( document.getElementById('toc') === null) return; // no toc element
    document.getElementById('toc').appendChild(OL);
    done = true;
  };

  window.onload = work;
  setTimeout(work,800);
}());
</script>
</body>
</html>
