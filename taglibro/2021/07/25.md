% Sun Jul 25 2021

## ここ3年で観て良かった映画

見た映画の記録をつけるみたいなことをしてこなかったが 2017 年頃から
[filmarks](https://filmarks.com/users/cympfh?page=3)
に記録してる.
良かった映画を列挙する.

私が思う良いというのは, 話が極端であること, 観て一年経ってもはっきり記憶に残っているもののこと.
極端というのはどうせ人が戦う話なら出来るだけ多くが死んだ方がいいし,
中途半端に記憶に残らないストーリーならいっそ画作りに極振りしてストーリーが無いほうが良いということ.
また, よく出来た映画は大抵見た直後には感動するものだが, 一年経っても時々ふっと思い出す映画だけが,
真に観たと言える映画だと思う.

### ナポレオン･ダイナマイト

私が見た時にはまだ邦題が「バス男」だった.
陰キャオタクが少しだけ努力する話.
主人公には本当の意味で何もない.
オタクだからといって例えばギーク趣味では才能があるだとかそんなものも何もない.
友達はようやく一人二人いる程度.
映画の中で成し得る達成と言えるものも, ようやく人前でダンスを披露する程度.
現実はこのくらいのドラマで十分だ.

{{https://www.youtube.com/watch?v=BiAwpYIkRmU}}

ストーリーも地味絵面も基本的には地味なんだが,
ダンスシーンが強烈すぎる.

### トレインスポッティング

続編の 2 も良かったね.
もちろん主人公も自業自得なんだが, 友人関係や環境がそうだと地獄から抜け出せない絶望を見せつけられる.

トリップした精神状態の映像化がきれい.

{{https://www.youtube.com/watch?v=6iKFn8dlxX8}}

### 帰ってきたヒトラー

現代に復活したヒトラーが初めはもちろん奇人として描かれるが,
ヒトラーの視点を通すと徐々に観客は, ヒトラーが真人間かのように見えてくるから恐ろしい.
後半でちゃんと, ヒトラー礼賛映画ではない描写があるので安心だね.

{{https://www.youtube.com/watch?v=ClOPoo_tQqs}}

一番のラストを見て, ちゃんと我に返って欲しい.

### 麻雀放浪記2020

安い安い映画だし, 「麻雀放浪記」という偉大な原案を元にしているが, それでも, その範囲を逸脱してSFをやっているのが好きだ.
原作を読み込み愛した上での原作レイプはお金を払って見る価値がある映画だ
（原作を忠実に映像化して音をつけただけのものを誰が褒めるんだろうか）.

{{https://www.youtube.com/watch?v=rNA4qWmFdCs}}

> 勝負しねえで生きる奴に出来ることはな、長生きだけだ

### サタンタンゴ

2019年末, 吉祥寺のパルコで一日限定で上映されると聞いて見てきた.
これは映画というより映像作品だし, 体験だと思う.
現実に「カット」はない.

{{https://www.youtube.com/watch?v=6YALvMVhT6k}}

### 花とアリス殺人事件

アニメの方.
いわゆる日常の謎ジャンル.
そして本物の百合とはこういうものを言う.
音楽がきれいだね.

{{https://www.youtube.com/watch?v=m_IQJkkoBvw}}

### ラブ&ポップ

いかにも90年代東京といったお話.
大抵の人間には非日常な出来事だが, 当事者たちには日常で些細な出来事なんだろうといった,
そういう意味では何も起きないお話.
監督が庵野なだけあって, 嫌でも目がちらつくカメラワークが重々しく見える.
が何も起きないのが面白いね.

{{https://www.youtube.com/watch?v=-xIHUhnS64k}}

### 地獄でなぜ悪い

まずコメディとして面白い.
喜劇として, 血が沢山ながれて人がたくさん死ぬので楽しい.
同時に質の低い自主制作映画批判になっているのが楽しい.

{{https://www.youtube.com/watch?v=VvHQsCgFokQ}}

### 秋刀魚の味

戦後の空気を味わうための映画.
敗戦して, 返って清々しくなれた庶民たちの話.

{{https://www.youtube.com/watch?v=kp2S77LARkg}}

> 「お葬式ですか」「ま、そんなものだよ」

### うる星やつら2 ビューティフル・ドリーマー

教養アニメ.
全員見ろ.
1984年に全てのエッセンスがすでに押井守によって具現化されていることに驚く.
これを見た後に他のアニメを見るとなんでも「ビューティフル・ドリーマーのパクリじゃないか」と思ってしまう.

{{https://www.youtube.com/watch?v=ooSNh9xn7cU}}

> 好きな人を好きでいる為に、その人から自由でいたいのさ

### 吉原炎上

まだ国に吉原遊廓が唯一認められていた時代に, ヒロインが娼婦として働き始めるところから始まるお話.
初め, 警察によって簡単に吉原について説明がなされ, 許可なしに外に出られないといったルールが挙げられる.
そこで分かることだが, これは現代でいう異世界ものである.
主人公が突然今までの常識が通用しない世界に放り出されるところから物語は始まる.
残念ながら前世の知識を使って無双したりはしないが.

{{https://www.youtube.com/watch?v=peKCq0a9xis}}

## ループで深さ優先探索

状態空間の探索を考える.

- 有限の状態空間 $S = \{ S_0, S_1, \ldots, S_M \}$
- 初期状態 $S_0 \in S$
- 状態遷移 $\sigma \colon S \to 2^S$

$S_0$ から始めて $\sigma$ によって到達可能な全ての状態を, 順次列挙することを考える.
実際にはこれによってDPをしたり, 所望の状態を探索したりするわけだが.
そして, 深さ優先探索 (以下DFS) は, $\sigma$ を適用できる限り適用する（深さ優先）ような順序で列挙する.

これは再帰関数を用いた次の擬似コードで表しやすい.

- Def $\mathrm{dfs}(S)$:
    - $S$ についてなにかする
    - For Each $S' \leftarrow \sigma(S)$
        - $\mathrm{dfs}(S')$
- $\mathrm{dfs}(S_0)$  -- 最初の関数呼び出し

さて, 再帰関数の本質はループと何も変わらないから, ただのループを使って書き下すことが出来る.
再帰呼び出しを無遠慮に使えないような言語ではこちらのほうが便利.
スタック構造を使うと上と全く同じことは次のように出来る.

- $F \leftarrow \mathrm{Stack} \{ S_0 \}$
- While $S \leftarrow \mathrm{pop}(F)$
    - $S$ についてなにかする
    - For Each $S' \leftarrow \sigma(S)$
        - $\mathrm{push}(F, S')$

ところで, ここまでは $\sigma$ によって新しい状態にたどり着いたらその時点で何か調べることを前提にしていた.
これを行きがけ順 (Pre-order) という.

これとは逆の帰りがけ順 (Post-order) が欲しいことがある.
これはつまり,

- 状態 $S$ について,
    - $S$ から $\sigma$ によってたどり着ける全ての状態について調べた **後**
    - $S$ について調べる

これは初めの再帰関数のバージョンだととてもシンプルに記述できる.

- Def $\mathrm{dfs}(S)$:
    - ここで $S$ を調べるのが **行きがけ**
    - For Each $S' \leftarrow \sigma(S)$
        - $\mathrm{dfs}(S')$
    - ここで $S$ を調べるのが **帰りがけ**
- $\mathrm{dfs}(S_0)$  -- 最初の関数呼び出し

これももちろんスタック構造を用いたループで記述できるのだが,
「調べ終わった」という状態を別個作って管理する必要がある.

- これから $S$ を調べる予定
    - $\mathrm{Pre}(S) = (S, 1)$
- $S$ 以降を調べ終わった
    - $\mathrm{Post}(S) = (S, 2)$

という **タグ付き** の状態をスタックに入れることにする.

- $F \leftarrow \mathrm{Stack} \{ \}$
- $\mathrm{push}(F, \mathrm{Post}(S_0))$ -- こちらを先に push
- $\mathrm{push}(F, \mathrm{Pre}(S_0))$
- While $T \leftarrow \mathrm{pop}(F)$
    - If $T = \mathrm{Pre}(S)$,
        - ここで $S$ について調べるのが行きがけ
        - For Each $S' \leftarrow \sigma(S)$
            - $\mathrm{push}(F, \mathrm{Post}(S'))$
            - $\mathrm{push}(F, \mathrm{Pre}(S'))$
    - Else If $T = \mathrm{Post}(S)$
        - ここで $S$ について調べるのが帰りがけ

これで実装できた.

## Rust で AtCoder に参戦する方法

### 1. 普通にブラウザで頑張る

コードの記述と実行は好きな環境（IDEとかターミナルとか）で行うとして,
サンプル入力はブラウザからコピペ,
提出も web ページのフォームにコピペする.

公式が提供する方法はこれであるが, コピペの手間がある.
特にサンプル入出力を使ってテストは良い成績のために重要であるが, 3つあると3回コピペして目視で正解してるかをチェックする作業は少々大変.

### 2. [tanakh/cargo-atcoder](https://github.com/tanakh/cargo-atcoder)

次がコマンドライン上で出来る

- 問題数に合わせてコードが用意された cargo プロジェクトの作成
    - 下地となるコードは自分でテンプレートを用意できる
- テスト実行
    - web ページにあるサンプル入出力をフェッチしてきてテストとして実行する
        - 手動でコピペする手間や目視チェックする手間が完全になくなる
- 提出
    - コマンド一つで提出できる
- 状態のフェッチ
    - コンテスト中に自分がサブミットしたものとその結果の一覧を表示する
- その他諸々

ブラウザで表示した web ページはただ問題を見ることだけに集中し,
それ以外は全てターミナルの上で操作が出来るようになる.
Rust で参戦してる人には必須のツールといっていい.

### 3. [cympfh/ac](https://github.com/cympfh/ac)

`cargo-atcoder` をさらにラップしただけのスクリプトコマンド.
ほんの少しだけ更に使いやすくなったつもり.

`cargo-atcoder` を使ってて少し苦労するのは次の点

- 毎回引数の問題番号を入れる必要がある
    - 単純に, 最後に触った問題を対象にして欲しい
        - （GNU Make も試したが, AC 済みのものを再び提出するような事故がよく起きてた）
    - `ac` では問題を指定して何か実行したときに, 「今触ってる問題はこれ」というのを上書きして管理してる
        - これを使って省略できそうな場合は省略できる
- サンプルをテストする場合は良いが, 自分で作った入力を試すためのコマンドが無い
    - `cargo atcoder test <PROBLEM_ID>` は与えられたサンプルを試すためのコマンド
    - `cargo run --bin a` で直接実行するしかない, が, コマンドが非対称になってて嫌だ
    - `ac test` コマンドはケース番号またはファイルパスまたは標準入力であるかを自由に指定できる
        - `"-"` なら標準入力
        - そうでなくてファイルパスとして有効ならファイルパス
        - いずれでもないときケース番号とする

例えば新規プロジェクトを作って A 問題を提出するまでの流れは次のようになる:

```bash
$ ac new abc200  # abc200 プロジェクトの新規作成
$ cd abc200      # abc200/ ができてるからそこで作業する
$ ac e a         # e は edit の略（全てのサブコマンドは略記可能）. A 問題を解き始めた
($EDITOR で編集する)
$ ac test        # A 問題のテストが走る
$ ac su          # submit の su. A問題の提出が行われる. 最後にジャッジ結果が出力される
$ ac st          # status の st. 今までの提出結果が表示される
```

コンテスト中は少しでもタイピングをサボりたいので.
