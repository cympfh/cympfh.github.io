<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Multi-Sentence Compression: Finding Shortest Paths in Word Graphs (Filippova, 2010)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="resources/index.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 style="font-size:1em; position:absolute; left:0; top:-0.8em; font-size:2.0em !important">
    <a href='index.html'>
    <img src="../resources/img/identicon.png" style="position:relative; top:0.4em; width:1.3em;border-radius:0.8em;" /> paper/
    </a>
</h1>
<header>
<h1 class="title">Multi-Sentence Compression: Finding Shortest Paths in Word Graphs (Filippova, 2010)</h1>
</header>
<ul>
<li>
url: <a href=http://dl.acm.org/citation.cfm?id=1873818>http://dl.acm.org/citation.cfm?id=1873818</a>
</li>
<li>
tags: <span class="tag"><a href=index.html#自然言語処理>自然言語処理</a></span> <span class="tag"><a href=index.html#自動要約>自動要約</a></span>
</li>
</ul>
<h2 id="概要">概要</h2>
<p>同じ内容を言っている複数の文から、より短く圧縮された一文を生成したい. 自動要約の中の一つのテクニックで文圧縮と呼ばれる.</p>
<p>論文の例を借りると</p>
<ol style="list-style-type: decimal">
<li>Hilary Clinton wanted to visit China last month but ...</li>
<li>Hilary Clinton paid a visit to the People Republic of China on ...</li>
<li>Last week ...</li>
<li>The wife of a former U.S. president Bill Clinton Hilary Clinton visited ...</li>
</ol>
<p>という4つの文から</p>
<ul>
<li>Hilary Clinton visited China last Monday.</li>
</ul>
<p>という文を作り上げる.</p>
<p>このためにこの論文は Word Graph という新しい概念を導入する. Word Graph とはノードが単語であるようなグラフで、その上のパスがちょうど新しい文となる. エッジに重みを与えるｋとおで、短さと有用な単語を拾うことを保証する.</p>
<h2 id="word-graph">Word graph</h2>
<p>文を単語の列 <span class="math inline">\(\{ w_i \}_{i=1}^n\)</span> とする. ただし <code>BOS</code> と <code>EOS</code> を列の最初と最後に付ける. <span class="math inline">\(w_i\)</span> をノードとし、 文の隣り合った2単語 <span class="math inline">\(w_i \rightarrow w_{i+1}\)</span> を有向枝だとすることで一つの有向グラフを得る.</p>
<p>ただし表層的に同じ単語は同じノードであるとする.</p>
<p>複数の文から、ノードをマージしながら、このような一つのグラフを得る. これを Word Graph という.</p>
<h2 id="パスの選択">パスの選択</h2>
<p>構成した Word graph の <code>EOS</code> から <code>BOS</code> へのパスを一つ選んだとき, それはまぁ大体ほとんど文法的に正当な文である<br />
(どんなパスでも正当であるのかなぁ？)</p>
<ol style="list-style-type: decimal">
<li>This dog is a dog.</li>
<li>This is a dog.</li>
</ol>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="514pt" height="105pt" viewBox="0.00 0.00 514.49 105.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 101)">
<title>
%3
</title>
<!-- BOS -->
<g id="node1" class="node">
<title>
BOS
</title>
<ellipse fill="none" stroke="black" cx="27.9475" cy="-18" rx="27.8951" ry="18"/> <text text-anchor="middle" x="27.9475" y="-14.3" font-family="Times,serif" font-size="14.00">BOS</text> </g> <!-- This --> <g id="node2" class="node">
<title>
This
</title>
<ellipse fill="none" stroke="black" cx="118.895" cy="-18" rx="27" ry="18"/> <text text-anchor="middle" x="118.895" y="-14.3" font-family="Times,serif" font-size="14.00">This</text> </g> <!-- BOS&#45;&gt;This --> <g id="edge1" class="edge">
<title>
BOS-&gt;This
</title>
<path fill="none" stroke="black" d="M56.118,-18C64.1814,-18 73.1438,-18 81.6848,-18"/> <polygon fill="black" stroke="black" points="81.8051,-21.5001 91.8051,-18 81.8051,-14.5001 81.8051,-21.5001"/> </g> <!-- is --> <g id="node3" class="node">
<title>
is
</title>
<ellipse fill="none" stroke="black" cx="208.895" cy="-41" rx="27" ry="18"/> <text text-anchor="middle" x="208.895" y="-37.3" font-family="Times,serif" font-size="14.00">is</text> </g> <!-- This&#45;&gt;is --> <g id="edge2" class="edge">
<title>
This-&gt;is
</title>
<path fill="none" stroke="black" d="M144.408,-24.4068C153.467,-26.7744 163.907,-29.503 173.67,-32.0548"/> <polygon fill="black" stroke="black" points="172.954,-35.4851 183.514,-34.6276 174.724,-28.7126 172.954,-35.4851"/> </g> <!-- dog --> <g id="node5" class="node">
<title>
dog
</title>
<ellipse fill="none" stroke="black" cx="388.895" cy="-33" rx="27" ry="18"/> <text text-anchor="middle" x="388.895" y="-29.3" font-family="Times,serif" font-size="14.00">dog</text> </g> <!-- This&#45;&gt;dog --> <g id="edge6" class="edge">
<title>
This-&gt;dog
</title>
<path fill="none" stroke="black" d="M145.82,-15.9538C156.922,-15.1744 170.036,-14.3821 181.895,-14 205.883,-13.227 211.941,-12.5087 235.895,-14 275.903,-16.4908 321.492,-22.6352 352.221,-27.2673"/> <polygon fill="black" stroke="black" points="352.022,-30.7776 362.437,-28.8342 353.083,-23.8585 352.022,-30.7776"/> </g> <!-- a --> <g id="node4" class="node">
<title>
a
</title>
<ellipse fill="none" stroke="black" cx="298.895" cy="-79" rx="27" ry="18"/> <text text-anchor="middle" x="298.895" y="-75.3" font-family="Times,serif" font-size="14.00">a</text> </g> <!-- is&#45;&gt;a --> <g id="edge3" class="edge">
<title>
is-&gt;a
</title>
<path fill="none" stroke="black" d="M232.101,-50.589C242.523,-55.0894 255.128,-60.5322 266.504,-65.4447"/> <polygon fill="black" stroke="black" points="265.128,-68.6629 275.696,-69.4141 267.903,-62.2364 265.128,-68.6629"/> </g> <!-- a&#45;&gt;dog --> <g id="edge4" class="edge">
<title>
a-&gt;dog
</title>
<path fill="none" stroke="black" d="M320.75,-68.0986C331.928,-62.2553 345.893,-54.9556 358.188,-48.5289"/> <polygon fill="black" stroke="black" points="359.949,-51.5575 367.19,-43.8231 356.706,-45.3539 359.949,-51.5575"/> </g> <!-- dog&#45;&gt;is --> <g id="edge7" class="edge">
<title>
dog-&gt;is
</title>
<path fill="none" stroke="black" d="M361.813,-34.1722C331.306,-35.5433 280.614,-37.8216 246.257,-39.3657"/> <polygon fill="black" stroke="black" points="245.992,-35.874 236.16,-39.8196 246.307,-42.867 245.992,-35.874"/> </g> <!-- EOS --> <g id="node6" class="node">
<title>
EOS
</title>
<ellipse fill="none" stroke="black" cx="479.193" cy="-33" rx="27.0966" ry="18"/> <text text-anchor="middle" x="479.193" y="-29.3" font-family="Times,serif" font-size="14.00">EOS</text> </g> <!-- dog&#45;&gt;EOS --> <g id="edge5" class="edge">
<title>
dog-&gt;EOS
</title>
<path fill="none" stroke="black" d="M415.91,-33C423.938,-33 432.936,-33 441.541,-33"/> <polygon fill="black" stroke="black" points="441.753,-36.5001 451.753,-33 441.753,-29.5001 441.753,-36.5001"/> </g> </g>
</svg>
<p>重要なワードをできるだけ拾うパスが必要である<br />
次のようにパスを重みを考えて, 小さなパスを良いとする<br />
実際には, 短さで <span class="math inline">\(K\)</span> 本のパスを列挙して, エッジの重さでフィルタリングをする<br />
動詞を含むかとか、そういう最低限のフィルタリングもするみたい</p>
<h3 id="エッジの重み">エッジの重み</h3>
<p>エッジ <span class="math inline">\(e_{ij}: w_i \rightarrow w_j\)</span> の重みを</p>
<p><span class="math display">\[
\frac{1}{\texttt{freq}(w_i) \texttt{freq}(w_j)}
\frac{\texttt{freq}(w_i) + \texttt{freq}(w_j)}{\sum_s \texttt{diff}(s, w_i, w_j)^{-1}}
\]</span></p>
<p>元の文章における一単語の頻度を freq,<br />
文章 <span class="math inline">\(s\)</span> における 単語 <span class="math inline">\(w_i\)</span>, <span class="math inline">\(w_j\)</span> が順に出現したときにその単語の離れてる単語数 を pos とする.<br />
ちょうど隣り合っているとき, pos を 1 とする.<br />
出現しないとき pos を 0 とする<br />
分母がにゼロの逆数だから、重みはゼロになるよね<br />
(つまり出現しない2単語をいくら含んでても問題ないとしてる)</p>
<h3 id="パスの重み">パスの重み</h3>
<p>エッジの重みの平均とする</p>
<p>パスは短い方がいいだろうけど、それが考慮されてない気がする.<br />
足して <span class="math inline">\(n\)</span> で割る代わりに <span class="math inline">\(\sqrt{n}\)</span> くらいで割るとかさぁ</p>
<!--

  HTML として pandoc -B で include する.

  <H2> を列挙してそれらにリンクを貼った toc を id='toc' に埋め込む.
  markdown で書いてるだろうから例として次のような段落を書けばよい.

```
## INDEX
<div id=toc></div>
```

  used in
  - /memo/gnuplot
  - /memo/linux
  - /memo/imagemagick

-->
<script>
(function() {
  var sections = document.getElementsByTagName('h2');
  var i;
  var OL = document.createElement('ol');
  for (i=0; i < sections.length; ++i) {
    var LI = document.createElement('li');
    var A = document.createElement('a');
    A.innerHTML = sections[i].innerHTML;
    if (A.innerHTML.toUpperCase() == 'INDEX') continue;
    A.href = '#' + i;
    LI.appendChild(A);
    OL.appendChild(LI);

    var PREF = document.createElement('a');
    PREF.name = i;
    sections[i].appendChild(PREF);
  }

  var done = false;
  function work() {
    if (done) return;
    if ( document.getElementById('toc') === null) return; // no toc element
    document.getElementById('toc').appendChild(OL);
    done = true;
  };

  window.onload = work;
  setTimeout(work,800);
}());
</script>
</body>
</html>
