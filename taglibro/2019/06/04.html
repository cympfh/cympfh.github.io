<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Tue Jun 04 2019</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../../../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='../../index.html'><i class="fa fa-save" style="position:absolute; left:0.4em; top:0.4em; width:1.3em;border-radius:0.8em;"></i></a>
</header>
<header>
<h1 class="title">Tue Jun 04 2019</h1>
</header>
<pre><code>      6月 2019
日 月 火 水 木 金 土
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30</code></pre>
<h2 id="section">06/01</h2>
<p>ボドゲカフェに行っておよそ6時間ぶっ続けでボドゲを遊んだ.</p>
<h3 id="quibbit">Quibbit!</h3>
<p>円上をぐるぐるスゴロクをしてって、脱落してくか、トップがビリを追い抜くかしたら終わり.</p>
<p>マスには安全か危険かの2種類があるが、プレイヤーによってどれが安全かは変わる. サイコロではなく進みたい数字のカードをみんなが一斉に出して処理をする. 相手のコマは飛び越えて数えるので、みんなが出す数字を予想しないと自分の行きたいマスには止まれない. 止まったマスが安全圏なら出した数字カードは再び手札に戻るが、危険圏だと出した数字カードは没収されて二度と使えない. 即ち出せる数字がどんどん狭まっていき、最終的に手札がゼロになった者は脱落する.</p>
<p>一周は案外狭いので、誰かが脱落するよりは、トップがビリを追い抜くことで決着が付く場合が多かった. 序盤の3ターンくらいはとにかく安全マスを踏むことを狙うが、一手目からとにかく悩む. 確実に決められるような場面はなかなか無い. 全ての予想が上手く決まると大変気持ち良いが、寿命が減ることの方が多い. 全員の予想が全て正しければ全員が安全マスに止まり、ほっとするのだが、それではゲームは進まないのでいけない. 誰か一人の予想が大外れすれば、それによって他の誰かの予想もズレてしまう、などあり寿命がいくらあっても足りない. 後半は危険マスに止まるのを覚悟してでも追いぬくことを目指すような場面もあり面白い. 没収のカードは裏向きで真ん中に重ねていくが、誰がどのカードを捨てたかは覚えておく必要がある.</p>
<h3 id="domemo">Domemo</h3>
<p>1から7の数字が書かれたパネルを均等に配り（ただし全ては使わず何枚かは裏向きで除外する）、パネルを自分からは見えないで他の全員からは見えるように立てた状態で、自分のパネルを当てるゲーム. 数字ごとに枚数は違っていて、1は1枚、2は2枚、という風になっている.</p>
<p>ブラフなど戦略はあるが、基本的には運ゲーだと思う. 見えてる中で残りを数えて確率の高いものを言う、他の人が言った数字は少し避ける、くらいしかやることがなさそう. 例えば他人の手に見えてる 1 を宣言することで、その人に 1 を言わせない、などの戦略も考えられそう. 二人戦ならそういうのも有効かもしれない.</p>
<h3 id="marrakech">Marrakech</h3>
<p>盤面のマス目上に自分の色の 1x2 の形をした絨毯を重ねて置いていって自分の陣地を増やしていく. 1つだけあるコマを盤面の上で皆で交互に動かしていき、相手の絨毯を踏んだらその人にお金を払う必要がある. お金はそのマスから連結した絨毯の面積の分だけ払う. 従って自分の絨毯は出来るだけつなげて拡大していくのが良い. また自分が置く絨毯はどこにでも良いわけではなく、コマを動かしてそのすぐ隣に動かす必要がある. 出来れば他人の絨毯に重ねて自分の絨毯を置きたいが、そのためには相手の絨毯の近くに行く必要があり、お金を払うリスクを負う.</p>
<p>1ターンにプレイヤーはちょうど面積 2 だけ増えるわけだが、その際に他の人の絨毯を覆うことでプレイヤー間の絨毯面積に差が付く. というわけで、如何に相手に自分の絨毯を覆わせないかが重要になる. 相手は自分の絨毯を踏みたくはないが、隣には来たくない. 一度十分大きく育てば、サイコロが何の目を出しても踏んでしまう、という状態になり、そうすれば二度と踏まれない. 従って安全である. いやしかし、一度は踏んでくれないと収入が得られない. というジレンマがある.</p>
<p>あまり大きく育ち過ぎると当然目立ち、自分以外の皆が結託をして集中攻撃をしてくるので、目立たない、という戦略が重要だと思った.</p>
<h3 id="the-mind">The Mind</h3>
<p>これは非常に面白かった.</p>
<p>1から100までの数字が書かれたカードがある. その中から数枚ずつをプレイヤーに配る. ゲームは全部で8ラウンドあり、第1ラウンドでは手札は1枚、第2ラウンドでは手札は2枚、と1枚ずつ増やしていく. 多い方が難しいので、簡単なものから徐々に慣れてゆけ、という意図である.</p>
<p>各ラウンドですべきことはとてもシンプルで、プレイヤーは一枚ずつカードを場に出してく. 順番などは無い. 各プレイヤーが自分のタイミングで出していけば良い. 出すカードはUNOのように、場の真ん中に重ねていく. このとき、出す数字は前の数字より大きく無ければならない.</p>
<p>つまり、最初に出されるカードは最も小さく、そこから次に大きなカードを誰かが出し、その次に大きなカードを誰かが出していく. そうして全員が持ってるカードを全て出し尽くした時、そのラウンドは成功となる.</p>
<p>プレイヤー全員が協力して8ラウンドを達成せよ、というゲームだ.</p>
<p>もちろん制約があり、すなわち、相談はいけない. 発声してはいけない. アイコンタクト等の音声以外であってもコミュニケーションをしていはいけない. ラウンドが始まる合図を誰かが「せーの」と言ったらそこからラウンドが終わるまでの間は喋ったりしたらいけない. もちろん持ってるカードを人に見せたりしてもいけない.</p>
<p>他人の持ってるカードが全くわからない状態で、この中で最小の数字を持ってるのは自分だと思ったら、そのカードを出すのだ. 他に throwing star カードというヒントのためのカードがあるのだが、説明省略.</p>
<h4 id="ネタバレ">ネタバレ</h4>
<p>初回プレイではこのネタバレは読まずに、というかルールブックの最後に書いてあるものなのだが、そこは読まずにプレイして欲しい. もちろん最初のラウンドの時点で無理だろう.</p>
<p>どうするか. sleep sort を行う.</p>
<p>すなわち、ラウンドスタートの合図から皆心の中で秒数を数える. 時計を見てしまうのはさすがにゲームが簡単になって興ざめなのでやめよう. そしてもし自分が50という数字を持ってるなら50秒後に出す. もしまだ49秒のはずなのに誰かが50を出したら、体内時計の精度の問題なので、あわてて同期する. これはそういうゲームである. ラウンド4の時点でもう成功しなくて断念した.</p>
<footer>
    <p class="is-pulled-right">
    @cympfh / cympfh@gmail.com
    </p>
</footer>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
