<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="index/位相の定義/連続写像の定義/部分位相/商位相/コンパクト/補題 0/補題 1/補題 2/補題 3/定理/" />
  <meta property="og:url" content="http://cympfh.cc/taglibro">
  <meta property="og:type" content="article">
  <meta property="og:title" content="位相" />
  <meta property="og:description" content="index/位相の定義/連続写像の定義/部分位相/商位相/コンパクト/補題 0/補題 1/補題 2/補題 3/定理/" />
  <meta property="og:image" content="http://cympfh.cc/resources/img/identicon.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@cympfh" />
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>位相</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>
<header>
<h1 class="title">位相</h1>
</header>
<p class="date" style="text-align: right">
2017-03-11 (Sat.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#位相空間>位相空間</a></p>
</div>
<h2 id="index">index</h2>
<div id="toc">

</div>
<h2 id="位相の定義">位相の定義</h2>
<p>位相空間 <span class="math inline">\(X\)</span> とは、集合 <span class="math inline">\(X\)</span> に <strong>位相 (開集合系)</strong> <span class="math inline">\(\mathcal O_X\)</span> を与えたもののことである. ただし、位相 <span class="math inline">\(\mathcal O_X\)</span> とは <span class="math inline">\(\mathcal O_X \subseteq P(X)\)</span> (冪集合) であって、次の3つを要請するもの</p>
<ol type="1">
<li><span class="math inline">\(\emptyset, X \in \mathcal O_X\)</span></li>
<li><strong>有限</strong> の添字族 <span class="math inline">\(\Lambda\)</span> について <span class="math inline">\(\forall \lambda \in \Lambda, U_\lambda \in \mathcal O_X \implies \bigcap_{\lambda \in \Lambda} U_\lambda \in \mathcal O_X\)</span></li>
<li>(無限を許す) 添字族 <span class="math inline">\(\Lambda\)</span> について <span class="math inline">\(\forall \lambda \in \Lambda, U_\lambda \in \mathcal O_X \implies \bigcup_{\lambda \in \Lambda} U_\lambda \in \mathcal O_X\)</span></li>
</ol>
<p><span class="math inline">\(\mathcal O_X\)</span> の元のことを <span class="math inline">\(X\)</span> の開集合 (open set) と言う. また補集合が開集合であるもののことを閉集合 (closed set) と言う.</p>
<ul>
<li><span class="math inline">\(U \in O_X \iff U\)</span> is open</li>
<li><span class="math inline">\(X \setminus U \in O_X \iff U\)</span> is closed</li>
</ul>
<p>注意として、開集合でかつ閉集合であるということがある. その自明なものとして <span class="math inline">\(\emptyset, X\)</span>.</p>
<h3 id="註-無限個の積について">(註) 無限個の積について</h3>
<p>有限個の開集合の積は開集合とし、 無限 (以下) 個の開集合の和を開集合とする.</p>
<p>直感的に、開集合とは、実数空間で言うと (例えば) 開区間 <span class="math inline">\((a, b)\)</span> のようなものである. <span class="math inline">\(U_n = (-1/n, 1/n)\)</span> それぞれは開集合であるが、これの可算無限個の積 <span class="math display">\[\bigcap_{n=1}^\infty U_n = \{0\}\]</span> を開集合として認めたくない.</p>
<h2 id="連続写像の定義">連続写像の定義</h2>
<p>集合 <span class="math inline">\(X, Y\)</span> 間の写像 <span class="math display">\[f: X \to Y\]</span> に対して、逆像 <span class="math display">\[f^{-1}(V) = \{ x \in X : f(x) \in V \}\]</span> を定義する. これは点を点に写すような <span class="math inline">\(f^{-1}: Y \to X\)</span> なる逆写像とは異なることに註意.</p>
<p>このような <span class="math inline">\(f^{-1}\)</span> が、<span class="math inline">\(Y\)</span> における開集合を<span class="math inline">\(X\)</span> における開集合に写すとき、 すなわち、 <span class="math display">\[\forall V \in \mathcal O_Y, f^{-1}(V) \in \mathcal O_X\]</span> となるとき、<span class="math inline">\(f\)</span> を <strong>連続写像</strong> という.</p>
<h2 id="部分位相">部分位相</h2>
<h3 id="補題">補題</h3>
<div class="thm">
<p>集合 <span class="math inline">\(X\)</span> に関して2つの位相 <span class="math inline">\(\mathcal O_X, \mathcal O_X&#39;\)</span> があるとき、この積 <span class="math inline">\(\mathcal O_X \cap \mathcal O_X&#39;\)</span> もまた位相である.</p>
</div>
<ol type="1">
<li><span class="math inline">\((\emptyset, X \in \mathcal O_X) \land (\emptyset, X \in \mathcal O_X&#39;)\)</span> より <span class="math inline">\(\emptyset, X \in \mathcal O_X \cap \mathcal O_X&#39;\)</span></li>
<li><span class="math inline">\(\forall i \in I, (U_i \in \mathcal O_X) \land (U_i \in \mathcal O_X&#39;)\)</span> のとき、
<ul>
<li><span class="math inline">\(\bigcap_i U_i \in \mathcal O_X \land \bigcap_i U_i \in \mathcal O_X&#39;\)</span></li>
<li>したがって、 <span class="math inline">\(\bigcap_i U_i \in \mathcal O_X \cap \mathcal O_X&#39;\)</span></li>
</ul></li>
<li><span class="math inline">\(\bigcup\)</span> も同様</li>
</ol>
<h3 id="部分位相の定義">部分位相の定義</h3>
<p>位相空間 <span class="math inline">\(X\)</span> とその部分集合 <span class="math inline">\(Y\)</span> があるとき、 <span class="math inline">\(Y\)</span> に <strong>自然に</strong> 位相を導入することができる. これを <strong>部分位相</strong> という. すなわち、</p>
<p><span class="math display">\[\mathcal O_Y = \{ U \cap Y : U \in \mathcal O_X \}\]</span></p>
<p>と定める. これが位相であることは確認できる.</p>
<h2 id="商位相">商位相</h2>
<p>位相空間 <span class="math inline">\(X\)</span> と集合 <span class="math inline">\(Y\)</span> との間に全射</p>
<p><span class="math display">\[p : X \to Y\]</span></p>
<p>があるとき、次のように <span class="math inline">\(Y\)</span> に位相を導入することが出来る.</p>
<p><span class="math display">\[\mathcal O_Y = \{ p(U) : U \in \mathcal O_X \}\]</span></p>
<p>これが位相であることは確認でき、この位相のとき <span class="math inline">\(p\)</span> は連続写像になる. この位相は、<span class="math inline">\(p\)</span> を連続たらしめる位相の中に (包含に関して) 最大の位相である (小さいほど連続になりやすいことに註意).</p>
<h2 id="コンパクト">コンパクト</h2>
<h3 id="被覆">被覆</h3>
<p>位相空間 <span class="math inline">\(X\)</span> の被覆とは、 <span class="math inline">\(X\)</span> の開集合の族 <span class="math inline">\(\{U_i\}_{i \in I}\)</span> であって、</p>
<p><span class="math display">\[\bigcup_i U_i = X\]</span></p>
<p>なるもののこと.</p>
<h3 id="コンパクトの定義">コンパクトの定義</h3>
<p>位相空間 <span class="math inline">\(X\)</span> がコンパクトであるとは、 <span class="math inline">\(X\)</span> の任意の被覆 <span class="math inline">\(\{U_i\}_{i \in I}\)</span> について、有限個の <span class="math inline">\(\{U_i\}_{i \in J}\)</span> を適切に選べば、これが尚も <span class="math inline">\(X\)</span> の被覆と出来ること. すなわち、有限集合 <span class="math inline">\(J\)</span> がって、</p>
<p><span class="math display">\[\bigcup_{j \in J} U_j = X\]</span></p>
<p>と出来ること.</p>
<h3 id="例">例</h3>
<ol type="1">
<li><span class="math inline">\(\mathbb{R}\)</span> はコンパクトではない</li>
<li><span class="math inline">\((0, 1) \subseteq \mathbb{R}\)</span> はコンパクトではない
<ul>
<li><span class="math inline">\(\mathbb{R}\)</span> から部分位相を導入してることに註意</li>
</ul></li>
<li><span class="math inline">\([0, 1] \subseteq \mathbb{R}\)</span> はコンパクトである</li>
<li><span class="math inline">\([0, 1] \cap \mathbb{Q} \subseteq \mathbb{R}\)</span> はコンパクトでない</li>
</ol>
<h4 id="証明">証明</h4>
<p>コンパクトでないことの証明は、実際に反例を一つ与えればよい. すなわち、その中の有限個では被覆できない点があるような被覆を与えれば良い.</p>
<ul>
<li><span class="math inline">\(\mathbb{R} = \bigcup_{i \in \mathbb{Z}} U_i\)</span>
<ul>
<li>where <span class="math inline">\(U_i = (i-1/2-\epsilon, i+1/2+\epsilon)\)</span></li>
</ul></li>
<li><span class="math inline">\((0, 1) = \bigcup_{i \in \mathbb{N}} U_i\)</span>
<ul>
<li>where <span class="math inline">\(U_i = (1/n, 1)\)</span></li>
</ul></li>
<li><span class="math inline">\([0, 1] \cap \mathbb{Q} = \bigcup_{i \in \mathbb{N}} U_i\)</span>
<ul>
<li>where
<ul>
<li><span class="math inline">\(U_i = ([0, r - 1/n) \cap (r + 1/n, 1]) \cap \mathbb{Q}\)</span></li>
<li><span class="math inline">\(r\)</span> は無理数で <span class="math inline">\(0 &lt; r &lt; 1\)</span></li>
</ul></li>
</ul></li>
</ul>
<p>コンパクトであることの証明は辛い.</p>
<p><span class="math inline">\([0,1]\)</span> がコンパクトであることの証明を行う. <span class="math inline">\([0,1]\)</span> の被覆 <span class="math inline">\(\{U_i\}_i\)</span> が与えられたとする. <span class="math inline">\(0 \leq x \leq 1\)</span> について、 命題「閉区間 <span class="math inline">\([0,x]\)</span> が有限個で被覆できる」を <span class="math inline">\(P(x)\)</span> とする. <span class="math inline">\(X = \{x : 0\leq x \leq 1, P(x) \}\)</span> について、これは実数の部分集合であるので、 <span class="math inline">\(\sup X\)</span> が存在する (これは有理数については言えない).</p>
<p><span class="math inline">\(\sup X = r &lt; 1\)</span> とする. <span class="math inline">\(r \in [0,1]\)</span> を被覆する <span class="math inline">\(U_i\)</span> が存在するので、 <span class="math inline">\(P(r + \epsilon)\)</span> が成立し、 <span class="math inline">\(\sup X = r\)</span> に矛盾する. 従って <span class="math inline">\(\sup X=1\)</span> が言える.</p>
<h2 id="補題-0">補題 0</h2>
<div class="thm">
<p><span class="math inline">\(X\)</span> が開集合であることと、 <span class="math inline">\(\forall x \in X, \exists U \text{ is open }, x \in U \subseteq X\)</span> とは同値.</p>
</div>
<p><span class="math inline">\((\Rightarrow)\)</span> の証明: 任意の点 <span class="math inline">\(x \in X\)</span> について <span class="math inline">\(U=X\)</span> とすれば、<span class="math inline">\(x \in X \subseteq X\)</span> が自明に成立する.</p>
<p><span class="math inline">\((\Leftarrow)\)</span> の証明: 点 <span class="math inline">\(x\)</span> に対して <span class="math inline">\(x \in U \subseteq X\)</span> なる <span class="math inline">\(U\)</span> を <span class="math inline">\(U_x\)</span> と名付けると、 開集合の公理から <span class="math inline">\(\bigcup_{x \in X} U_x\)</span> は開集合であるが、これがちょうど <span class="math inline">\(X\)</span> と一致する. 従って <span class="math inline">\(X\)</span> は開集合である.</p>
<h2 id="補題-1">補題 1</h2>
<div class="thm">
<p>ハウスドルフ空間 <span class="math inline">\(X\)</span> の部分集合 <span class="math inline">\(Z\)</span> がコンパクトなとき、<span class="math inline">\(Z\)</span> は閉集合.</p>
</div>
<p><span class="math inline">\(X \setminus Z\)</span> が開集合であることを示す. 開集合であることを示すのに先の補題 0 を用いる. すなわち、 任意の点 <span class="math inline">\(x \in X \setminus Z\)</span> に対して、</p>
<p><span class="math display">\[\exists U \text{ is open }, x \in U \subseteq X \setminus Z\]</span></p>
<p>を示せば良い.</p>
<p><span class="math inline">\(X\)</span> がハウスドルフ空間であることから、 点 <span class="math inline">\(x \in X\)</span> と 点 <span class="math inline">\(z \in X \setminus Z\)</span> に対して それらを分離するような</p>
<ul>
<li><span class="math inline">\(z \in U_z\)</span></li>
<li><span class="math inline">\(x \in V_z\)</span></li>
<li><span class="math inline">\(U_z \cap V_z = \emptyset\)</span></li>
</ul>
<p>がある. さて、 <span class="math inline">\(Z\)</span> の全ての点 <span class="math inline">\(z\)</span> に対して</p>
<p><span class="math display">\[\{ U_z \cap Z \}_{z \in Z}\]</span></p>
<p>は (<span class="math inline">\(Z\)</span> の部分位相に於いて) <span class="math inline">\(Z\)</span> の被覆であるが、<span class="math inline">\(Z\)</span> のコンパクト性より、ある有限の点集合<span class="math inline">\(Z&#39;\)</span> を以って</p>
<p><span class="math display">\[\{ U_z \cap Z \}_{z \in Z&#39;}\]</span></p>
<p>が <span class="math inline">\(Z\)</span> の被覆である. これに対応して</p>
<p><span class="math display">\[V = \cap_{z \in Z&#39;} V_z\]</span></p>
<p>を作れて、これは <span class="math inline">\(Z\)</span> と積を持たない. また、有限個の積であるから、<span class="math inline">\(V\)</span> は開集合.</p>
<p>したがって、任意の <span class="math inline">\(x \in X \setminus Z\)</span> に対して、 <span class="math display">\[x \in V \subseteq X \setminus Z\]</span> なる開集合 <span class="math inline">\(V\)</span> が得られた.</p>
<p>従って、<span class="math inline">\(X \setminus Z\)</span> は開集合である.</p>
<h2 id="補題-2">補題 2</h2>
<div class="thm">
<p>コンパクト集合の部分閉集合はコンパクトである.</p>
</div>
<p>コンパクト集合 <span class="math inline">\(X\)</span> についてその部分集合 <span class="math inline">\(Z \subseteq X\)</span> には部分位相を入れていることに註意. <span class="math inline">\(Z\)</span> に任意の被覆 <span class="math inline">\(\{U_i\}_i\)</span> を与えた時、 ちょうど</p>
<p><span class="math display">\[\{ U_i \}_i \cap \{ X \setminus Z \}\]</span></p>
<p>は、<span class="math inline">\(X\)</span> の被覆になっている. ここで、<span class="math inline">\(Z\)</span> が閉集合 (補題 1) であるから、<span class="math inline">\(X \setminus Z\)</span> は開集合であることを用いてる. <span class="math inline">\(X\)</span> のコンパクト性故、</p>
<p><span class="math display">\[\exists J, \{ U_i \}_{i \in J} \cap \{ X \setminus Z \}\]</span></p>
<p>によって、<span class="math inline">\(X\)</span> を被覆する. このときに</p>
<p><span class="math display">\[\exists J, \{ U_i \}_{i \in J}\]</span></p>
<p>によって <span class="math inline">\(Z\)</span> が被覆できる. 従って、<span class="math inline">\(Z\)</span> はコンパクト.</p>
<h2 id="補題-3">補題 3</h2>
<div class="thm">
<p>コンパクト集合の連続写像による像はコンパクト.</p>
</div>
<p>2つの位相集合 <span class="math inline">\(X, Y\)</span> の間に連続写像 <span class="math inline">\(f : X \to Y\)</span> があるとき、 <span class="math inline">\(f(X)\)</span> は <span class="math inline">\(Y\)</span> の部分集合であるが、 部分位相を入れる時、<span class="math inline">\(f(X)\)</span> はコンパクト集合である.</p>
<p>証明は 補題 2 とほぼほぼ同様.</p>
<h2 id="定理">定理</h2>
<div class="thm">
コンパクト集合からハウスドルフ空間への全単射な連続写像は同相を与える
</div>
<p>コンパクト集合 <span class="math inline">\(X\)</span> からハウスドルフ空間 <span class="math inline">\(Y\)</span> への写像 <span class="math display">\[f : X \to Y\]</span> を考える. これが連続写像であることから、自然に</p>
<p><span class="math display">\[f^{-1} : \mathcal O_Y \to \mathcal O_X\]</span></p>
<p>が定まる. 同相であることを示すには逆写像も連続であることを示せばよい. そのためには、</p>
<p><span class="math display">\[f : P(X) \to P(Y)\]</span> <span class="math display">\[f(U) = \{ f(x) : x \in U \}\]</span></p>
<p>これが開集合を保つ、つまり、</p>
<p><span class="math display">\[f : \mathcal O_X \to \mathcal O_Y\]</span> <span class="math display">\[\forall U \in \mathcal O_X, f(U) \in \mathcal O_Y\]</span></p>
<p>と、開集合を開集合に写していればよい.</p>
<p>今の場合、 開集合を開集合に写すことは、閉集合を閉集合に写すことと等しい. なぜなら、<span class="math inline">\(f\)</span> は全単射なので.</p>
<ul>
<li>閉集合 <span class="math inline">\(Z \subseteq X\)</span> に対して、<span class="math inline">\(f(Z)\)</span> が閉集合であることを示す.
<ol type="1">
<li>補題 2 より、<span class="math inline">\(Z\)</span> はコンパクトである.</li>
<li>補題 3 より、<span class="math inline">\(f(Z)\)</span> はコンパクト</li>
<li>補題 1 より、<span class="math inline">\(f(Z) \subseteq Y\)</span> は閉集合</li>
</ol></li>
</ul>
<p>以上より示された.</p>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
