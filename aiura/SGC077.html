<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>[SGC-077] ジョルダン標準形</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">[SGC-077] ジョルダン標準形</h1>
</header>
<p class="date" style="text-align: right">
2017-08-27 (Sun.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#線形代数>線形代数</a></p>
</div>
<p>&quot;SGC ライブラリ 77: ジョルダン標準形&quot; の勉強ノートです. 線形代数自体の導入が割と長いっぽいのでそこらへんは駆け足で.</p>
<h2 id="index">INDEX</h2>
<div id="toc">

</div>
<h2 id="ベクトル空間の基底">1.1 ベクトル空間の基底</h2>
<p>ベクトル空間の定義の復習など.</p>
<h3 id="数ベクトル空間">数ベクトル空間</h3>
<p>体 <span class="math inline">\(K\)</span> の <span class="math inline">\(n\)</span> 個の直積空間でベクトル空間を作ったものを特に <strong>数ベクトル空間</strong> という. その元を <strong>数ベクトル</strong> という. いわゆる列ベクトルとか行ベクトルがそう.</p>
<p><span class="math display">\[K^n \ni \left[
\begin{array}{c}
k_1 \\ k_2 \\ \vdots \\ k_n
\end{array}
\right]\]</span></p>
<h3 id="演習-1.1">演習 1.1</h3>
<div class="thm">
<p>ベクトル空間 <span class="math inline">\(V\)</span> の部分ベクトル空間として <span class="math inline">\(U_1, U_2, \ldots\)</span> があるとする. このとき <span class="math inline">\(X = \bigcap_{k=0}^\infty U_k\)</span> は部分ベクトル空間であるかどうか調べよ. また <span class="math inline">\(Y = \bigcup_{k=0}^\infty U_k\)</span> はどうか.</p>
</div>
<p><span class="math inline">\(X\)</span> は部分ベクトル空間である. なぜなら、 2つの元 <span class="math inline">\(u, v\)</span> の一次結合 <span class="math inline">\(\alpha u + \beta v\)</span> (<span class="math inline">\(\alpha,\beta \in K\)</span>) はどの <span class="math inline">\(U_k\)</span> においても閉じているのだから、その積である <span class="math inline">\(X\)</span> でも閉じている.</p>
<p>同様の理由から <span class="math inline">\(Y\)</span> は閉じておらず、部分ベクトル空間ではない. 反例を挙げる.</p>
<ul>
<li><span class="math inline">\(V = \mathbb{R}^2 = \{ (x,y) : x, y \in \mathbb{R} \}\)</span></li>
<li><span class="math inline">\(U_{2n} = \mathbb{R} \times 0 = \{ (x,0) \}\)</span></li>
<li><span class="math inline">\(U_{2n+1} = 0 \times \mathbb{R} = \{ (0, y) \}\)</span></li>
</ul>
<p>について <span class="math inline">\(Y = \{(x,0)\} \cup \{(0,y)\}\)</span> だが、 <span class="math inline">\((1,0), (0,1) \in Y\)</span> の和は <span class="math inline">\((1,1) \not\in Y\)</span> である.</p>
<h2 id="行列と数ベクトル空間">1.2 行列と数ベクトル空間</h2>
<p>体 <span class="math inline">\(K\)</span> の上の数ベクトル空間 <span class="math inline">\(K^n\)</span> の元を <span class="math inline">\(n \times 1\)</span> の行列と同一視する. <span class="math inline">\(K\)</span> 上のサイズ <span class="math inline">\(m\times n\)</span> の行列 <span class="math inline">\(A\)</span> と <span class="math inline">\(v \in K^n\)</span> は行列の積で <span class="math inline">\(K^m\)</span> に移すことができる. <span class="math display">\[A: K^n \to K^m\]</span> <span class="math display">\[A: v \mapsto Av\]</span></p>
<p>(行列としての <span class="math inline">\(A\)</span> と写像 <span class="math inline">\(K^n\to K^m\)</span> としての <span class="math inline">\(A\)</span> を同一視している.)</p>
<div class="thm">
<p>この像 <span class="math inline">\(\mathrm{Im}(A) = \{ Av : v \in K^n \}\)</span> は <span class="math inline">\(K^m\)</span> の部分ベクトル空間である. しかも、 <span class="math inline">\(A\)</span> の第 <span class="math inline">\(i\)</span> 列を <span class="math inline">\(a_i\)</span> とすると <span class="math inline">\(\langle a_1, a_2, \ldots, a_n \rangle\)</span> によって張られるベクトル空間と一致する.</p>
</div>
<h4 id="証明">証明</h4>
<p>像がベクトル空間であるのは行列を掛ける操作が線形変換であるから. つまり、<span class="math inline">\(u \in \mathrm{Im}\)</span> ならば対応する <span class="math inline">\(v\)</span> があって <span class="math inline">\(u=Av\)</span>. スカラー倍 <span class="math inline">\(ku \in K^m\)</span> は <span class="math inline">\(ku=k(Av)=A(kv)\)</span> (<span class="math inline">\(kv \in K^n\)</span>) なので、たしかに <span class="math inline">\(ku \in \mathrm{Im}\)</span> であり、閉じていることがわかる. 和も同様.</p>
<p>2つめの主張は、任意の <span class="math inline">\(u \in \mathrm{Im}\)</span> が、適当な係数列を掛けて <span class="math inline">\(u = k_1a_1 + \cdots + k_na_n\)</span> と出来ることを言っている.</p>
<p>列ベクトル <span class="math inline">\(a_i\)</span> というのは実は、 <span class="math inline">\(K^n\)</span> の基底として <span class="math display">\[e_i = \left[ 0,\ldots,0,1,0,\ldots,0 \right]^t\]</span> を採用した場合に基底が移る先 <span class="math display">\[a_i = Ae_i\]</span> である.</p>
<p><span class="math inline">\(u\)</span> に対して <span class="math inline">\(u=Av\)</span> となる <span class="math inline">\(v\)</span> があるわけだが、この <span class="math inline">\(v\)</span> は基底の一次結合 <span class="math display">\[v = \sum k_i e_i\]</span> と掛けるので、 <span class="math display">\[u = \sum k_i a_i\]</span> となる. というわけで、<span class="math inline">\(\langle a_i \rangle\)</span> によって表現できる (もちろん一般に一次独立ではないので <span class="math inline">\(a_i\)</span> が基底とまでは主張していない).</p>
<div class="thm">
<p><span class="math inline">\(A\)</span> の核とは <span class="math display">\[\mathrm{Ker}(A) = \{ v : Kv=0, v \in K^n \}\]</span> のことであるが、これは <span class="math inline">\(K^n\)</span> の部分ベクトル空間である.</p>
</div>
<h4 id="証明-1">証明</h4>
<p><span class="math inline">\(u,v\in\mathrm{Ker}\)</span> ならば、 <span class="math inline">\(A(u+v) = Au+Av=0+0=0\)</span> なので、 <span class="math inline">\(u+v\in\mathrm{Ker}\)</span> です. スカラー倍も <span class="math inline">\(A(ku)=k(Au)=0\)</span> なので <span class="math inline">\(ku\in\mathrm{Ker}\)</span> です.</p>
<p>ゼロベクトル <span class="math inline">\(0\)</span> についてはいつも <span class="math inline">\(A0=0\)</span> なので、 <span class="math inline">\(0 \in \mathrm{Ker}\)</span> であるが、 <span class="math inline">\(\mathrm{Ker}=\{0\}\)</span> (単に <span class="math inline">\(=0\)</span> と書く) のときとは、 <span class="math display">\[Av=0 \iff v=0\]</span> のことである. 先程の列ベクトル <span class="math inline">\(a_i\)</span> を用いるとこれは <span class="math display">\[\sum k_i a_i = 0 \iff \forall i, k_i=0\]</span> と書き換えられる. 従って、 <span class="math inline">\(\mathrm{Ker}(A)=0\)</span> とは、その列ベクトル <span class="math inline">\(\langle a_i \rangle\)</span> が一次独立であることと等しい.</p>
<p>先程示したように <span class="math inline">\(\mathrm{Im}(A)\)</span> はその列ベクトルによって張られる空間と等しい. かつ列ベクトルが一次独立ならば、それは基底であることに他ならない.</p>
<div class="thm">
サイズ <span class="math inline">\(n \times n\)</span> の行列 <span class="math inline">\(A\)</span> が正則であることと、 その列ベクトル <span class="math inline">\(\langle a_i \rangle\)</span> が <span class="math inline">\(K^n\)</span> の基底となることは等しい.
</div>
<h2 id="線形写像とその行列表示">1.3 線形写像とその行列表示</h2>
<h3 id="定義-1.2">定義 1.2</h3>
<p>ベクトル空間 <span class="math inline">\(V, W\)</span> について 線形写像 <span class="math inline">\(V \to W\)</span> とは次を満たす関数 <span class="math inline">\(f\)</span> のこと <span class="math display">\[f(\alpha u + \beta v) = \alpha f(u) + \beta f(v)\]</span></p>
<p>このような写像全体を <span class="math inline">\(\mathrm{Hom}(V,W)\)</span> と書く.</p>
<p>線形写像 <span class="math inline">\(f : V \to W\)</span> があるとする. <span class="math inline">\(V, W\)</span> の基底として <span class="math inline">\(\langle v_1, v_2, \ldots, v_n \rangle\)</span> <span class="math inline">\(\langle w_1, w_2, \ldots, w_m \rangle\)</span> を取る.</p>
<blockquote>
<p>数ベクトルとは限らないベクトルは基底を定めれば数ベクトル (列ベクトル) で表示できる.</p>
</blockquote>
<p>この基底を用いると、 任意の <span class="math inline">\(u\in V\)</span> は <span class="math inline">\(u = \sum \alpha_i v_i\)</span> と表現できるし、 <span class="math inline">\(f\)</span> で写った先のベクトルも <span class="math inline">\(f(u) = \sum_j \beta_j w_j\)</span> と表現できる.</p>
<p><span class="math inline">\(f\)</span> の線形性故、 <span class="math display">\[f(u) = \sum_i \alpha_i f(v_i).\]</span> さらに <span class="math display">\[f(v_i) = \sum_j a_{ij} w_j\]</span> とすると、 <span class="math display">\[f(u) = \sum_i \alpha_i \sum_j a_{ij} w_j.\]</span></p>
<p>従って <span class="math display">\[\beta_j = \sum_i \alpha_i a_{ij}\]</span> がわかる.</p>
<p>係数 <span class="math inline">\(a_{ij}\)</span> を各成分にもつ行列 <span class="math inline">\(A = (a_{ij})\)</span> を考えると、 <span class="math display">\[\left[\begin{array}{c}
\beta_1 \\ \vdots \\ \beta_m
\end{array}\right]
= A
\left[\begin{array}{c}
\alpha_1 \\ \vdots \\ \alpha_n
\end{array}\right]\]</span></p>
<p>というわけで、 <span class="math inline">\(A\)</span> を <span class="math inline">\(f\)</span> の <strong>行列表示</strong> という. <span class="math inline">\(f\)</span> が線形写像ならいつもこのように行列で表示できる. (右辺と左辺にある数 (列) ベクトルは、それぞれ基底を定めたときに得られるベクトル表示.)</p>
<h2 id="基底の取り換え-1">1.4 基底の取り換え 1</h2>
<p>線形写像 <span class="math inline">\(f: V \to W\)</span> について、 <span class="math inline">\(V, W\)</span> にある基底を取ると、<span class="math inline">\(f\)</span> の行列表示 <span class="math inline">\(A\)</span> が得られるのであった.</p>
<p>基底のとり方は一通りではない故、別な基底にすることが考えられる. 基底 <span class="math inline">\(\langle v_1,\ldots,v_n \rangle\)</span> から <span class="math inline">\(\langle u_1,\ldots,u_n \rangle\)</span> に取り替えることは、 それぞれが基底であることから <span class="math display">\[u_i = \sum_j p_{ij} v_j\]</span> とできるので、 行列 <span class="math inline">\(P\)</span> を掛け算することに相当する.</p>
<p>従って、別な基底を取ったときの <span class="math inline">\(f\)</span> の行列表示 <span class="math inline">\(B\)</span> は、ある行列 <span class="math inline">\(P, Q\)</span> を用いて、 <span class="math display">\[B = Q^{-1} A P\]</span> <span class="math display">\[A = Q B P^{-1}\]</span> とできる.</p>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: %3 Pages: 1 -->
<svg width="442pt" height="116pt" viewBox="0.00 0.00 442.00 116.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 112)">
<title>
%3
</title>
<!-- Kn -->
<g id="node1" class="node">
<title>
Kn
</title>
<text text-anchor="middle" x="27" y="-14.3" font-family="Times,serif" font-size="14.00">K^n</text> </g> <!-- V --> <g id="node2" class="node">
<title>
V
</title>
<text text-anchor="middle" x="167" y="-51.3" font-family="Times,serif" font-size="14.00">V</text> </g> <!-- Kn&#45;&gt;V --> <g id="edge1" class="edge">
<title>
Kn-&gt;V
</title>
<path fill="none" stroke="black" d="M64.0011,-27.6525C87.7645,-34.0238 118.358,-42.2264 139.816,-47.9797"/> <polygon fill="black" stroke="black" points="64.8468,-24.2557 54.2816,-25.0465 63.034,-31.0169 64.8468,-24.2557"/> <text text-anchor="middle" x="97" y="-47.8" font-family="Times,serif" font-size="14.00">vectorize</text> </g> <!-- Km --> <g id="node4" class="node">
<title>
Km
</title>
<text text-anchor="middle" x="407" y="-14.3" font-family="Times,serif" font-size="14.00">K^m</text> </g> <!-- Kn&#45;&gt;Km --> <g id="edge6" class="edge">
<title>
Kn-&gt;Km
</title>
<path fill="none" stroke="black" d="M54.2801,-18C120.481,-18 294.198,-18 369.886,-18"/> <polygon fill="black" stroke="black" points="369.894,-21.5001 379.894,-18 369.894,-14.5001 369.894,-21.5001"/> <text text-anchor="middle" x="217" y="-21.8" font-family="Times,serif" font-size="14.00">A</text> </g> <!-- Kn2 --> <g id="node3" class="node">
<title>
Kn2
</title>
<text text-anchor="middle" x="27" y="-86.3" font-family="Times,serif" font-size="14.00">K^n</text> </g> <!-- V&#45;&gt;Kn2 --> <g id="edge2" class="edge">
<title>
V-&gt;Kn2
</title>
<path fill="none" stroke="black" d="M139.915,-60.1823C120.965,-64.1034 94.7612,-69.8493 72,-76 69.4051,-76.7012 66.7351,-77.4589 64.0542,-78.2463"/> <polygon fill="black" stroke="black" points="62.961,-74.9204 54.4127,-81.1796 64.9985,-81.6173 62.961,-74.9204"/> <text text-anchor="middle" x="97" y="-79.8" font-family="Times,serif" font-size="14.00">vectorize</text> </g> <!-- W --> <g id="node5" class="node">
<title>
W
</title>
<text text-anchor="middle" x="267" y="-51.3" font-family="Times,serif" font-size="14.00">W</text> </g> <!-- V&#45;&gt;W --> <g id="edge5" class="edge">
<title>
V-&gt;W
</title>
<path fill="none" stroke="black" d="M194.005,-55C204.969,-55 217.92,-55 229.794,-55"/> <polygon fill="black" stroke="black" points="229.874,-58.5001 239.874,-55 229.874,-51.5001 229.874,-58.5001"/> <text text-anchor="middle" x="217" y="-58.8" font-family="Times,serif" font-size="14.00">f</text> </g> <!-- Kn2&#45;&gt;Kn --> <g id="edge8" class="edge">
<title>
Kn2-&gt;Kn
</title>
<path fill="none" stroke="black" d="M27,-71.5867C27,-63.9407 27,-54.8916 27,-46.4274"/> <polygon fill="black" stroke="black" points="30.5001,-46.1686 27,-36.1686 23.5001,-46.1687 30.5001,-46.1686"/> <text text-anchor="middle" x="16.5" y="-50.3" font-family="Times,serif" font-size="14.00">P</text> </g> <!-- Km2 --> <g id="node6" class="node">
<title>
Km2
</title>
<text text-anchor="middle" x="407" y="-86.3" font-family="Times,serif" font-size="14.00">K^m</text> </g> <!-- Kn2&#45;&gt;Km2 --> <g id="edge7" class="edge">
<title>
Kn2-&gt;Km2
</title>
<path fill="none" stroke="black" d="M54.0565,-90.6901C59.9564,-90.8191 66.1933,-90.934 72,-91 200.881,-92.4644 233.119,-92.4644 362,-91 364.54,-90.9711 367.163,-90.9329 369.804,-90.8882"/> <polygon fill="black" stroke="black" points="370.014,-94.3849 379.943,-90.6901 369.877,-87.3862 370.014,-94.3849"/> <text text-anchor="middle" x="217" y="-96.8" font-family="Times,serif" font-size="14.00">B</text> </g> <!-- Km&#45;&gt;W --> <g id="edge3" class="edge">
<title>
Km-&gt;W
</title>
<path fill="none" stroke="black" d="M370.107,-27.6235C346.365,-33.9892 315.768,-42.1928 294.282,-47.9535"/> <polygon fill="black" stroke="black" points="371.064,-30.9906 379.816,-25.0203 369.251,-24.2294 371.064,-30.9906"/> <text text-anchor="middle" x="337" y="-47.8" font-family="Times,serif" font-size="14.00">vectorize</text> </g> <!-- W&#45;&gt;Km2 --> <g id="edge4" class="edge">
<title>
W-&gt;Km2
</title>
<path fill="none" stroke="black" d="M294.085,-60.1823C313.035,-64.1034 339.239,-69.8493 362,-76 364.595,-76.7012 367.265,-77.4589 369.946,-78.2463"/> <polygon fill="black" stroke="black" points="369.002,-81.6173 379.587,-81.1796 371.039,-74.9204 369.002,-81.6173"/> <text text-anchor="middle" x="337" y="-79.8" font-family="Times,serif" font-size="14.00">vectorize</text> </g> <!-- Km2&#45;&gt;Km --> <g id="edge9" class="edge">
<title>
Km2-&gt;Km
</title>
<path fill="none" stroke="black" d="M407,-71.5867C407,-63.9407 407,-54.8916 407,-46.4274"/> <polygon fill="black" stroke="black" points="410.5,-46.1686 407,-36.1686 403.5,-46.1687 410.5,-46.1686"/> <text text-anchor="middle" x="396.5" y="-50.3" font-family="Times,serif" font-size="14.00">Q</text> </g> </g>
</svg>
<p>&quot;vectorize&quot; はベクトル空間に基底を一つ与えたときの数ベクトル表示のこと. 射 <span class="math inline">\(A,B\)</span> は行列 <span class="math inline">\(A,B\)</span> を左から掛けること. <span class="math inline">\(P,Q\)</span> も同様.</p>
<p>こうなると基底のとり方によって <span class="math inline">\(f\)</span> の行列表示の方法は無限にあることがわかる.</p>
<div class="thm">
<p><span class="math inline">\(f\)</span> の行列表示の一つが <span class="math inline">\(A\)</span> であるとき、行列表示全体は <span class="math display">\[\{ gAh : g \in \mathrm{GL}_m, h \in \mathrm{GL}_n \}\]</span> で表される. ここで <span class="math inline">\(\mathrm{GL}_n\)</span> は <span class="math inline">\(n\)</span> 次の正則正方行列全体.</p>
</div>
<div class="thm">
<p><span class="math inline">\(f\)</span> の行列表示の一つが <span class="math inline">\(A\)</span> であるとき、行列表示全体は <span class="math display">\[\{ B : \mathrm{rank}(B) = \mathrm{rank}(A) \}\]</span> で表される.</p>
</div>
<h2 id="基底の取り換え-2">1.5 基底の取り換え 2</h2>
<p>この本では、あるベクトル空間から自分自身への線形写像 (<span class="math inline">\(V \to V\)</span>) のことを、 <strong>線形変換</strong> といい、 <span class="math inline">\(\mathrm{End} V\)</span> と書く.</p>
<p>線形変換 <span class="math inline">\(f: V \to V\)</span> の行列表示の一つを <span class="math inline">\(A\)</span> とする. ここで登場する基底は <span class="math inline">\(V\)</span> の基底のみ (定義域の <span class="math inline">\(A\)</span> と値域の <span class="math inline">\(A\)</span> で別の基底を使う必要もないので). これを先ほどと同様に別の基底に置き換えることを考えると、 <span class="math display">\[A \mapsto P^{-1}AP\]</span> となる.</p>
<h3 id="定義-1.24">定義 1.24</h3>
<p><span class="math inline">\(\mathrm{GL}_n\)</span> の、<span class="math inline">\(n\)</span> 次正方行列への作用として次を定義する. <span class="math display">\[\mathrm{Ad}(g)(X) = gXg^{-1}\]</span> これを随伴作用とか <strong>共役作用</strong> だとか言う.</p>
<p><span class="math inline">\(\exists g, B = \mathrm{Ad}(g)(A)\)</span> のとき、「<span class="math inline">\(A\)</span> と <span class="math inline">\(B\)</span> は共役である」という.</p>
<p><span class="math inline">\(\mathrm{Ad}\)</span> は共変関手であって、 <span class="math display">\[\mathrm{Ad}(g) \circ \mathrm{Ad}(h) = \mathrm{Ad}(gh)\]</span> が成立している.</p>
<h2 id="章末問題-1">章末問題 1</h2>
<h3 id="section">1.1 (1)</h3>
<div class="thm">
<p><span class="math inline">\(n\)</span> 次正方行列全体 <span class="math inline">\(M_n\)</span> に対して <span class="math inline">\(n\)</span> 次の対称行列全体 <span class="math display">\[\mathrm{Sym}_n = \{X \in M_n : X^t = X\}\]</span> は部分ベクトル空間である.</p>
</div>
<p>対称行列は足してもスカラー倍してもなお対称行列であるから.</p>
<h3 id="section-1">1.1 (2)</h3>
<div class="thm">
<p>交代行列とは <span class="math display">\[\mathrm{Alt}_n = \{ X \in M_n : X^t = -X \}\]</span> のことであるが、これもやはり <span class="math inline">\(M_n\)</span> の部分ベクトル空間である.</p>
</div>
<p>対称行列と全く同様である. <span class="math inline">\(X,Y \in \mathrm{Alt}_n\)</span> に対して、 <span class="math inline">\((X+Y)^t = X^t+Y^t=-X-Y=-(X+Y)\)</span> だから.</p>
<h3 id="section-2">1.1 (3)</h3>
<div class="thm">
<p>任意の正方行列 <span class="math inline">\(X \in M_n\)</span> はただ一通りで対称行列と交代行列の和で表される.</p>
</div>
<p>まず <span class="math inline">\(S \in \mathrm{Sym}_n\)</span>, <span class="math inline">\(A \in \mathrm{Alt}_n\)</span> によって <span class="math display">\[X = S + A\]</span> と表されているとすると、 <span class="math display">\[X^t = S^t + A^t = S - A\]</span> なので、 <span class="math display">\[S = (X + X^t) / 2\]</span> <span class="math display">\[A = (X - X^t) / 2\]</span> と出来るので、<span class="math inline">\(S,A\)</span> の組の一意性が言える.</p>
<p>逆に、任意の行列 <span class="math inline">\(X\)</span> に対して、 <span class="math display">\[S = (X + X^t) / 2\]</span> <span class="math display">\[A = (X - X^t) / 2\]</span> で <span class="math inline">\(S,A\)</span> を構成する. このとき <span class="math display">\[S + A = X\]</span> は構成から明らか. <span class="math inline">\(S,A\)</span> がそれぞれ対称行列と交代行列であることが言えれば、主張が証明される.</p>
<p>でもそれも構成からほぼ明らかで、 <span class="math display">\[S^t = (X^t + (X^t)^t)/2 = (X^t+X)/2=S\]</span> <span class="math display">\[A^t = (X^t - (X^t)^t)/2 = (X^t-X)/2=-A\]</span> なので <span class="math display">\[S \in \mathrm{Sym}\]</span> <span class="math display">\[A \in \mathrm{Alt}\]</span> である.</p>
<div class="thm">
<p><span class="math display">\[M_n = \mathrm{Sym}_n \oplus \mathrm{Alt}_n\]</span></p>
</div>
<h3 id="section-3">1.2</h3>
<p>次の線形写像 <span class="math display">\[T(X) = X - X^t\]</span> について <span class="math display">\[\mathrm{Ker} T = \mathrm{Sym}\]</span> <span class="math display">\[\mathrm{Im}  T = \mathrm{Alt}\]</span></p>
<h2 id="固有値と固有ベクトル">2.1 固有値と固有ベクトル</h2>
<p>ここらへんから今まで体 <span class="math inline">\(K\)</span> としていたのを <span class="math inline">\(\mathbb{C}\)</span> に限定する.</p>
<h3 id="定義-2.1">定義 2.1</h3>
<div class="thm">
<p>線形変換 <span class="math inline">\(f \in \mathrm{End} V\)</span> の固有値及び固有ベクトルとは、 <span class="math display">\[f(v) = \lambda v ~~(\lambda \in \mathbb{C}, v \ne 0)\]</span> となるような <span class="math inline">\(\lambda\)</span> 及び <span class="math inline">\(v\)</span> のこと.</p>
</div>
<p><span class="math inline">\(f\)</span> を行列表示 <span class="math inline">\(A\)</span> にすれば <span class="math display">\[f(v) = \lambda v \iff Av=\lambda v \iff (A-\lambda E)v=0\]</span> <span class="math inline">\(v\ne 0\)</span> より <span class="math display">\[|A - \lambda E|=0\]</span> ここで <span class="math inline">\(E\)</span> は単位行列、 <span class="math inline">\(|A|\)</span> は <span class="math inline">\(A\)</span> の行列式.</p>
<h3 id="定理-2.3">定理 2.3</h3>
<div class="thm">
<p><span class="math inline">\(A \in M_n\)</span> に対して <span class="math display">\[p_A(t) = |tE - A|\]</span> を <strong>固有多項式</strong> という. 固有値は <span class="math inline">\(p_A(t)\)</span> の根であるので、高々 <span class="math inline">\(n\)</span> 個存在する.</p>
</div>
<p>ところで行列表示 <span class="math inline">\(A\)</span> は基底を取り替えることで自由に <span class="math inline">\(P^{-1}AP\)</span> と出来るが、 <span class="math display">\[|tE-P^{-1}AP| = |P^{-1} (tE-A) P| = |P^{-1}| |tE-A| |P| = |tE-A|\]</span> より、 <span class="math display">\[p_{P^{-1}AP}(t) = p_A(t)\]</span> が確認できる.</p>
<p>なので、固有多項式は基底によらずに定義でき、一般に、線形変換 <span class="math inline">\(f\)</span> の固有多項式を、 ある一つの行列表示 <span class="math inline">\(A\)</span> を用いて <span class="math display">\[p_f(t) = p_A(t)\]</span> を定義する.</p>
<h3 id="定理-2.4-ケイリーハミルトンの定理">定理 2.4 (ケイリー・ハミルトンの定理)</h3>
<div class="thm">
<p>線形変換 <span class="math inline">\(f\)</span> の固有多項式 <span class="math inline">\(p_f(t)\)</span> の引数に線形変換を代入した <span class="math display">\[p_f(f)\]</span> はゼロ写像である. すなわち <span class="math display">\[p_f(f)(v) = 0\]</span> である.</p>
</div>
<p>例えば二次正方行列 <span class="math inline">\(A=\left[ \begin{array}{cc} a&amp;b\\c&amp;d\end{array}\right]\)</span> の固有多項式は <span class="math display">\[p_A(t) = (t-a)(t-d)-bc\]</span> であるが、この引数に <span class="math inline">\(A\)</span> (行列を掛ける操作) を代入したものは <span class="math display">\[p_A(A) = (A-aE)(A-dE)-bcE\]</span> 展開すると <span class="math display">\[p_A(A) = A^2-(a+d)A+(ad-bc)\]</span> これはゼロ写像である.</p>
<p>このことが一般の線形変換について成り立つ. 証明は行列表示した行列のサイズ (すなわち <span class="math inline">\(\mathrm{dim}V\)</span>) に関する帰納法で行う.</p>
<h4 id="証明-2">証明</h4>
<p>線形変換 <span class="math inline">\(f \in \mathrm{End} V\)</span> の固有ベクトルの一つを <span class="math inline">\(v_1 \ne 0\)</span> とし、 それに <span class="math inline">\(n-1\)</span> 個のベクトル <span class="math inline">\(v_2,\ldots,v_n\)</span> を加えて基底とする.</p>
<p><span class="math inline">\(f\)</span> の行列表示を考える. <span class="math inline">\(f(v_1)=\lambda v_1\)</span> であるとしたので、 行列表示を <span class="math inline">\(A\)</span> とすると、 <span class="math inline">\(v_1\)</span> 相当の数ベクトル <span class="math inline">\(e_1=[1,0,\ldots,0]^t\)</span> を掛けると <span class="math display">\[A e_1 = \lambda e_1\]</span> である必要があるので、 <span class="math inline">\(A\)</span> の第一列目は <span class="math inline">\(\lambda e_1\)</span> である.</p>
<p>つまり <span class="math display">\[A = \left[
\begin{array}{cccc}
\lambda &amp; a     &amp; \cdots &amp; b \\
0       &amp; \vdots &amp; \cdot &amp; \vdots \\
0       &amp; c &amp; \cdots &amp; d \\
\end{array}\right]\]</span> みたいな感じ.</p>
<p>こうなると、<span class="math inline">\(|A|\)</span> は <span class="math inline">\(\lambda\)</span> と、2,2成分より右下だけからなる行列 <span class="math inline">\(\tilde{A}\)</span> の行列式の積になるので、 <span class="math display">\[p_A(t) = (t-\lambda) p_{\tilde{A}}(t)\]</span> となる.</p>
<p>さて <span class="math inline">\(\tilde{A}\)</span> は何を表現してる行列か. 第一成分すなわち <span class="math inline">\(v_1\)</span> を無視した変換である.</p>
<p>ベクトル空間 <span class="math inline">\(V\)</span> を <span class="math inline">\(v_1\)</span> で割った <span class="math display">\[U=V/v_1\]</span> に <span class="math inline">\(f\)</span> を自然に誘導できる. <span class="math display">\[\tilde{f}(u) = f(u+av_1) \sim f(u)\]</span> (一次独立だから <span class="math inline">\(V\)</span> 上で <span class="math inline">\(f(u)\)</span> と <span class="math inline">\(f(v_1)\)</span> も一次独立.) この <span class="math inline">\(\tilde{f}\)</span> の行列表示が <span class="math inline">\(\tilde{A}\)</span> である.</p>
<p>多項式 <span class="math inline">\(p_A(t)\)</span> に諸々代入して、 <span class="math display">\[p_f(f) = (f - \lambda) p_{\tilde{f}}(f)\]</span></p>
<p>ここで帰納法の仮定として <span class="math display">\[p_{\tilde{f}}(\tilde{f}) = 0\]</span> とする. <span class="math inline">\(p_{\tilde{f}}(f) \sim p_{\tilde{f}}(\tilde{f}) = 0\)</span> より <span class="math inline">\(p_{\tilde{f}}(f) = a v_1\)</span>. これを代入して <span class="math display">\[p_f(f) = (f - \lambda) a v_1 = a (f(v_1)-\lambda v_1)=0\]</span></p>
<!--

  HTML として pandoc -B で include する.

  <H2> を列挙してそれらにリンクを貼った toc を id='toc' に埋め込む.
  markdown で書いてるだろうから例として次のような段落を書けばよい.

```
## INDEX
<div id=toc></div>
```

  used in
  - /memo/gnuplot
  - /memo/linux
  - /memo/imagemagick

-->
<script>
(function() {
  var sections = document.getElementsByTagName('h2');
  var i;
  var OL = document.createElement('ol');
  for (i=0; i < sections.length; ++i) {
    var LI = document.createElement('li');
    var A = document.createElement('a');
    A.innerHTML = sections[i].innerHTML;
    if (A.innerHTML.toUpperCase() == 'INDEX') continue;
    A.href = '#' + i;
    LI.appendChild(A);
    OL.appendChild(LI);

    var PREF = document.createElement('a');
    PREF.name = i;
    sections[i].appendChild(PREF);
  }

  var done = false;
  function work() {
    if (done) return;
    if ( document.getElementById('toc') === null) return; // no toc element
    document.getElementById('toc').appendChild(OL);
    done = true;
  };

  window.onload = work;
  setTimeout(work,800);
}());
</script>
</body>
</html>
