<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>坪井 多様体 &amp;sect;4 - 接空間</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">坪井 多様体 &sect;4 - 接空間</h1>
<p><p class=date style='text-align: right'>2017-02-21 (Tue.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#幾何学>幾何学</a> <a class='tag is-red' href=index.html#微分幾何>微分幾何</a> <a class='tag is-red' href=index.html#接空間>接空間</a> <a class='tag is-red' href=index.html#接写像>接写像</a> </div></p>
<h2>INDEX</h2>
<p><div id=toc></div></p>
<h2>曲線</h2>
<p>\(n\) 次元多様体 \(M\) の上に貼られた曲線を考える. とりあえず曲線 \(c\) は次のように記述できるだろう. 写像の像ではなく写像そのものを曲線としていることに註意.</p>
<ul>
  <li>線分から \(M\) への連続写像 \(c: (a, b) \to M\)</li>
</ul>
<p>座標の時と同様に、 \(c\) を微分することは出来ない. 曲線 \(c\) が通るある点 \(c(t_0) = x_0 \in M\) を含む近傍 \(U\) とその近傍座標 \(\phi\) を用いれば \(\frac{d(\phi \circ c)}{dt}(t_0)\) という微分値を考えることは出来る.</p>
<p>\(x_0 \in M\) を通る曲線 \(c\) について、適当な \((U, \phi)\) を取って</p>
\[\phi^* : c \mapsto \frac{d(\phi \circ c)}{dt}(t_0) (\in \mathbb{R}^n)\]
<p>を定める.</p>
<p>またここでは、曲線は \(\phi \circ c\) が \(C^\infty\) 級なものに限ることにする.</p>
<h3>目論見</h3>
<ul>
  <li>
    \(x_0\) における <strong>「接ベクトル」</strong> を、 \(x_0\) を通る曲線で表現しようと考えている.
    <ul>
      <li>接ベクトルとはその点を通る曲線のこと</li>
      <li>文字通り \(M\) の上にベクトルを作ることはできないのでこうする</li>
    </ul>
  </li>
  <li>その接ベクトルを分類する方法として \(\phi^*\) を用いようと考えている.</li>
</ul>
<h3>座標のとり方について</h3>
<p>今 \(x_0\) に対して適当な一つの近傍座標 \((U, \phi)\) を取ったが、 別な近傍座標 \((V, \psi)\) もまた取れるとする \((x_0 \in U \cap V)\) .</p>
<p>異なる2曲線 \(c_1, c_2\) で、 \(\phi^*(c_1) = \phi^*(c_2)\) が成り立っているとする.</p>
<p>座標を \(\phi\) から \(\psi\) に取り直した時、この関係は実は保存される. なぜなら</p>
\[\frac{d(\psi \circ c)}{dt}(t_0) = D(\psi \circ \phi^{-1})_{(\phi(x_0))} \frac{d(\phi \circ c)}{dt}(t_0)\]
<p>である. 定数 (行列) 倍されるだけなので、イコール関係は保存される.</p>
\[\begin{align*}
\phi^*(c_1) =&amp; \phi^*(c_2) \\
\iff&amp; \\
\psi^*(c_1) =&amp; \psi^*(c_2) \\
\end{align*}\]
<h2>接ベクトル・接空間</h2>
<p>\(x_0 \in M\) での <strong>接ベクトル</strong> とは \(x_0\) を通る曲線 \(c: [a,b] \to M; c(t_0) = x_0\) のこと. \(x_0\) を通る ( \(C^\infty\) 級の) 曲線全体を \(C_{x_0}\) と書く.</p>
<p>ただし接ベクトルには \(\phi^*(c_1) = \phi^*(c_2)\) による同値関係を入れる. この同値関係は局所座標のとり方に依らないことは先に確認した.</p>
<p>今同値関係を入れたので接ベクトル全体とは \(C_{x_0}&#x2F;\sim\) である. 先の \(\phi^*\) をこの商集合に導くと自明に単射 (その値で同値を定めてるので).</p>
\[\phi^* : C_{x_0}&#x2F;\!\sim \; \to \mathbb{R}^n\]
\[c \mapsto \frac{d(\phi \circ c)}{dt}(t_0)\]
<p>と制限すると、同値関係から明らかに単射. しかも次の事実から全射でもある.</p>
<p>任意のベクトル \(v \in \mathbb{R}^n\) について 曲線 \(c^v(t) = \phi^{-1}(tv + \phi(x_0))\) を構成すると \(\phi^*(c^v) = v\) . というわけで \(\phi^*\) は全単射. 従って \(C_{x_0}&#x2F;\!\sim\) と \(\mathbb{R}^n\) は同型である.</p>
<blockquote>ただし曲線 \(c^v\) は近傍 \(U\) の範囲を超えない範囲である必要がある. なので厳密には十分に小さな区間を定義域として定義する必要がある.</blockquote>
<p>同型故に \(\mathbb{R}^n\) におけるベクトル空間として構成を \(C_{x_0}&#x2F;\sim\) に導くことで、これをベクトル空間とすることができる. ベクトル空間としての \(C_{x_0}&#x2F;\sim\) を</p>
\[T_{x_0}M\]
<p>と書き、我々はこれを <strong>接空間 (接ベクトル空間)</strong> という.</p>
<blockquote>つまり \(\phi^*(\alpha_1 c_1 + \alpha_2 c_2) := \alpha_1 \phi^*(c_1) + \alpha_2 \phi^*(c_2)\) と定める.</blockquote>
<p>座標系を取り直しても値は定数 (行列) 倍にしかならないので、ベクトル空間としての構造は変わらない.</p>
<h3>座標変換</h3>
<p>先の \(c^v = \phi^{-1}(tv + \phi(x))\) という曲線は有用で、 \(\mathbb{R}^n\) における標準基底 \(e_1, e_2, \ldots, e_n\) に対して \(c^{e_1}, c^{e_2}, \ldots, c^{e_n}\) は \(T_xM\) における基底である. これは \(\phi^*: T_xM \to \mathbb{R}^n\) が同型を与えることを思い出せば明らか.</p>
<ul>
  <li>
    点 \(x \in M\) を
    <ul>
      <li>\(\phi\) で与える座標を \(\phi(x) = (x_1, x_2, \ldots, x_n)\) ,</li>
      <li>\(\psi\) で与える座標を \(\psi(x) = (y_1, y_2, \ldots, y_n)\) とする.</li>
    </ul>
  </li>
  <li>
    \(T_xM\) の基底
    <ul>
      <li>\(c_\phi^i = \phi^{-1}(te_i + \phi(x)) ~~ (i=1,2,\ldots,n)\)</li>
      <li>\(c_\psi^j = \psi^{-1}(te_j + \psi(x)) ~~ (j=1,2,\ldots,n)\)</li>
    </ul>
  </li>
</ul>
<ul>
  <li>\(\psi^* (c_\psi^j) = e_j\)</li>
  <li>\(\psi^* (c_\phi^i) = \frac{\partial (\psi \circ \phi^{-1})}{\partial x_i} e_i\)</li>
</ul>
<p>この \(x_i\) とは、 \(t e_i\) のこと. 或いは \(\phi \circ c^i_\phi : t \mapsto (x_1, x_2, \ldots, x_n)\) の値の第 \(i\) 成分.</p>
<p>また \(\psi \circ \phi^{-1}\) とは \((x_1, x_2, \ldots, x_n) \mapsto (y_1, y_2, \ldots, y_n)\) という座標変換のことで、 \(\mathbb{R}^n\) から \(\mathbb{R}^n\) への変換. 従ってこの変換に関するヤコブ行列を考えられる.</p>
\[\left(
\frac{\partial y_i}{\partial x_j}
\right)_{i,j}\]
<p>を使うと</p>
<ul>
  <li>\(\psi^* (c_\phi^i) = \sum_j \frac{\partial y_j}{\partial x_i} ~ \psi^*(c_\psi^j)\)</li>
  <li>\(\therefore c_\phi^i = \sum_j \frac{\partial y_j}{\partial x_i} ~ c_\psi^j\)</li>
</ul>
<p>\(c_\phi^i\) のことを \(\frac{\partial}{\partial x_i}\) , \(c_\psi^j\) のことを \(\frac{\partial}{\partial y_j}\) と書くことにすると</p>
<ul>
  <li>\(\frac{\partial}{\partial x_i} = \sum_j \frac{\partial y_j}{\partial x_i} ~ \frac{\partial}{\partial y_j}\)</li>
</ul>
<p>となって形式的に辻褄が合う. \(c_\phi^i\) は、 \(x_i\) 方向の微分ベクトルのことだから、解釈としても問題ない.</p>
<h2>\(T\) の作用</h2>
<p>\(T\) は多様体 \(M\) 及びその上の点 \(x \in M\) から \(T_xM\) というベクトル空間を導いた.</p>
<p>多様体 \(M\) から \(N\) への連続写像</p>
<ul>
  <li>\(f: M \to N\)</li>
</ul>
<p>について \(T\) を作用させることを考える.</p>
<p>まず定義域の多様体 \(M\) を \(T_xM\) に写す. \(f\) は \(M\) 上の点に関する写像であるが、 \(c\) は区間 \((a, b)\) から \(M\) 上の点への写像であったから、 \(f\) との関数合成をすることで、 \(N\) 上の点に写すことが出来る.</p>
\[\begin{CD}
(a,b) @&gt;c&gt;&gt; M @&gt;f&gt;&gt; N
\end{CD}\]
<p>すなわち、 \(M\) 上の曲線 \(c\) から \(N\) 上の曲線 \(f \circ c\) を導いた. この定義域は \(T_xM\) である. 値域を考えると、これは \(T_{f(x)}N\) である. これは、 \(T\) が \(N\) を \(T_{f(x)}N\) に写したと考えると分かり良い.</p>
<p>曲線 \(f \circ c\) のことを 写像 \(Tf\) と書くことにする. すると、 \(T\) は</p>
<ul>
  <li>
    \(f: M \to N\)
    <ul>
      <li>\(x \mapsto y\)</li>
    </ul>
  </li>
</ul>
<p>を</p>
<ul>
  <li>
    \(Tf: T_xM \to T_{f(x)}N\)
    <ul>
      <li>\(c \mapsto f \circ c\)</li>
    </ul>
  </li>
</ul>
<p>に写したと考えられる.</p>
\[\begin{CD}
M @&gt;f&gt;&gt; N \\
@. @. \\
TM @&gt;Tf&gt;&gt; TN \\
\end{CD}\]
<p>実はこの \(T\) は圏論の言葉で言うところの (共変) 関手である.</p>
<h2>接写像 (tangent map)</h2>
<p>連続写像 \(f: M \to N\) とある基点 \(x \in M\) から \(Tf\) を構成できることを先に示した. この \(Tf\) を <strong>接写像</strong> という. \(Tf\) は線形写像である. これはほぼ自明. 線形写像ということは行列表示ができるし、rank を計算することもできる.</p>
<p>先の座標変換の時と同様に基底が \(Tf\) でどう写るかを考えると、</p>
\[\begin{align*}
\frac{\partial}{\partial x_i} \in T_xM
&amp; ~ \sim ~
\frac{d}{dt} (\phi \circ \phi^{-1}(te_i + \phi(x))) \in \mathbb{R}^n \\
&amp; \xrightarrow{Tf}
\frac{d}{dt} (\psi \circ f \circ \phi^{-1}(te_i + \phi(x))) \in \mathbb{R}^n \\
&amp; ~ \sim ~
\frac{\partial f^*}{\partial x_i} \frac{\partial}{\partial x_i} \in M_{f(x)}N
\end{align*}\]
<p>すなわち、線形写像 \(Tf\) は \(f^* = \psi \circ f \circ \phi^{-1}\) のヤコブ行列に相当して、 特にその rank が一致する.</p>
\[\text{rank} (Tf) = \text{rank} (Df^*)\]
<h3>例</h3>
<p>\(\mathbb{R}&#x2F;\mathbb{Z}\) は \(S^1\) と同型なハウスドルフ空間である. これ同士の直積もほぼ自明に (或いは先のファイバー束と見なして) ハウスドルフ空間である. というわけで</p>
\[(\mathbb{R}&#x2F;\mathbb{Z})^2 \cong \mathbb{R}^2&#x2F;\mathbb{Z}^2\]
<p>は2次元の微分可能多様体である (詳細略).</p>
<p>整数の \(2\times 2\) 行列 \(A\) が定める線形写像</p>
\[f_A : \mathbb{R}^2 \to \mathbb{R}^2\]
<p>を \(&#x2F;\mathbb{Z}^2\) で割った</p>
\[f_A : \mathbb{R}^2&#x2F;\mathbb{Z}^2 \to \mathbb{R}^2&#x2F;\mathbb{Z}^2\]
<p>を定める. これは、次のように、同値な点を同値な点に写すので well-defined に定義できる. ( \(A\) の成分を整数としているので.)</p>
<ul>
  <li>\(f_A \left(\begin{array}\\x\\y\end{array}\right) = A  \left(\begin{array}\\x\\y\end{array}\right)\)</li>
  <li>\(f_A \left(\begin{array}\\x+m\\y+n\end{array}\right)
= A  \left(\begin{array}\\x+m\\y+n\end{array}\right)
= A  \left(\begin{array}\\x\\y\end{array}\right) + A  \left(\begin{array}\\m\\n\end{array}\right)
= A  \left(\begin{array}\\x\\y\end{array}\right)\)</li>
</ul>
<p>\(f_A\) は微分可能な写像である. というのは、商集合から商集合への写像とすると微分は定義できないが、今、定義域と値域は多様体だとしたので、</p>
\[\begin{CD}
\mathbb R^2&#x2F;\mathbb Z^2    @&gt;fA&gt;&gt;  \mathbb R^2&#x2F;\mathbb Z^2 \\
@V\varphi VV  @V\psi VV \\
\mathbb R^2    @&gt;fA^\ast&gt;&gt;  \mathbb R^2 \\
\end{CD}\]
<p>\(f_A\) の代わりに \(f_A^* = \psi \circ f_A \circ \phi^{-1}\) が微分可能であるかを考えればよい. これはほぼ自明な局所座標 \(\phi, \psi\) を取ることで、</p>
\[f_A^* \left(\begin{array}\\x\\y\end{array}\right) = A \left(\begin{array}\\x\\y\end{array}\right)\]
<p>とできる. これは \(C^\infty\) 級なので、「 \(f\) は \(C^\infty\) 級である」と言える.</p>
<p>さてではこれらに \(T\) を作用させることを考える.</p>
<ul>
  <li>\(Tf_A : T_x \mathbb{R}^2&#x2F;\mathbb{Z}^2 \to T_y \mathbb{R}^2&#x2F;\mathbb{Z}^2\)</li>
</ul>
<p>この rank は</p>
<ul>
  <li>\(\text{rank} (Tf_A) = \text{rank} (Df_A^*) = \text{rank} A\)</li>
</ul>
<p>と、行列 \(A\) の rank と一致することが分かる.</p>
<h3>例. Lie 群</h3>
<p>\(G\) が Lie 群であるとは、 \(G\) が \(n\) 次元多様体だと見做せ、 群の積演算 \(* : G \times G \to G\) が \(C^\infty\) 級写像であるもののこと.</p>
<p>\(L_h(g) = gh\) なる右から定数を掛ける関数は定義から \(C^\infty\) 級であるし、 \(L_{h^{-1}}\) が明らかに \(C^\infty\) 級の逆写像であるので、結局 \(L_h\) は同相写像である.</p>
\[x \xrightarrow{(g, L_h)} (g, hx) \xrightarrow{~*~} ghx \xrightarrow{L_{(gh)^{-1}}} x\]
<p>ただしここで左の \((g, L_h)\) は第一成分を定数 \(g\) に、第二成分を \(L_h\) を適用する関数. 一番左から右までの合成射は恒等射.</p>
<p>\(x=1\) における接 \(T\) を取ると、</p>
\[T_1G \xrightarrow{T(g, L_h)} T_{(g,h)}(G\times G) \xrightarrow{T~*~} T_{gh}G \xrightarrow{TL_{(gh)^{-1}}} T_1G\]
<p>一番左から右までの合成は、恒等射を \(T\) で写したものなので、これも恒等射 (関手は恒等射を恒等射に写す).</p>
<p>一番右の \(TL_{(gh)^{-1}}\) は同相写像 \(L_{(gh)^{-1}}\) を写したものだから、やはりこれも同型を与える. 従って、左2本の射の合成も全射.</p>
<p>" \(f \circ g\) が全射ならば \(g\) は全射" であることに註意すれば、 \(T~*\) は全射. また、これは \(\mathbb{R}^{n \times n}\) から \(\mathbb{R}^n\) への写像であるから</p>
\[\text{rank} (T~*~) = n\]
<p>と、群の積の接写像の rank を調べることができた.</p>
\[* : (g, h) \to gh\]
<p>が \(C^\infty\) 級の全射であることから、ここに陰関数定理を適用することで、 \(g, gh\) が与えられた時に、 \(h\) を求める関数も \(C^\infty\) 級写像であることが分かる.</p>
<p>ただしここで陰関数定理を適用するために、 \(*\) のヤコビアンが full-rank であること、すなわち</p>
\[\text{rank}(D*) = \text{rank}(T*) = n\]
<p>であることを用いた.</p>
<p>特に \(gh=1\) とすることで、逆元を取る操作</p>
\[g \mapsto g^{-1}\]
<p>が \(C^\infty\) 級であることも分かる.</p>
<h2>部分多様体</h2>
<p>\(n\) 次元多様体 \(M\) に就いて、 \(p\) 次元多様体 \(N\) が \(M\) の <strong>部分</strong> 多様体であるとは、 \(N \subseteq M\) であって、</p>
<p>任意の \(\forall x \in M\) を含む \(M\) の局所座標 \(\exists (U, \phi)\) について</p>
\[N \cap U = \phi^{-1}( \{ x_{p+1} = \cdots = x_n = 0 \} \cap \phi(U) )\]
<p>となること.</p>
<h3>例</h3>
<p>\(m&gt;n\) のとき、 \(m\) 次元多様体 \(M\) から \(n\) 次元多様体 \(N\) への \(C^\infty\) 級写像 \(F\) の 接写像 \(TF\) の rank が \(n\) のとき、 任意の \(x_0 \in N\) に対して \(F^{-1}(x_0)\) は \(M\) の部分多様体である.</p>
<p>例えば</p>
\[F : \mathbb{R}^2 \to \mathbb{R}\]
\[F : (x, y) \mapsto x^2 + y^2\]
\[TF : T\mathbb{R}^2 \to T\mathbb{R}\]
\[TF : a \frac{\partial}{\partial x} + b \frac{\partial}{\partial y} \mapsto (2ax+2by) \frac{\partial}{\partial t}\]
<h3>はめ込み (immertion)</h3>
<p>\(m&lt;n\) のときに \(F: M \to N\) であって \(\forall x, T_xF\) が単射のとき、 そのような写像 \(F\) をはめ込みという.</p>
<p>\(F\) 自体が単射である必要はない. 局所的に単射であれば良い.</p>
<h3>埋め込み (embedding)</h3>
<p>写像 \(F: M \to N\) が単射であるようなものを埋め込みという.</p>
<h3>沈め込み (submertion)</h3>
<p>\(m \geq n\) のときの写像 \(F: M \to N\) であって \(\forall x, T_xF\) が全射であるようなものを、沈め込みという.</p>
<h2>接束</h2>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>