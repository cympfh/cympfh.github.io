<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>表現関手, 普遍射</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-svg-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">表現関手, 普遍射</h1>
<p><p class=date style='text-align: right'>2021-11-28 (Sun.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#圏論>圏論</a> </div></p>
<p>\(\def\C{\mathcal C}\def\Set{\mathrm{\mathcal{Set}}}\) \(\def\D{\mathcal D}\) \(\def\op#1{{#1}^{\mathrm{op}}}\) \(\require{amscd}\)</p>
<h2>INDEX</h2>
<p><div id=toc-level-2></div></p>
<h2>表現関手</h2>
<h3>（共変）表現関手 \(h_Z\)</h3>
<p>圏 \(\C\) とその対象 \(Z \in \C\) があるとき, 関手</p>
\[h_Z \colon \C \to \Set\]
\[X \mapsto \C(Z, X)\]
<p>がある. ここで \(\C(Z,X)\) は \(\C\) における \(Z\) から \(X\) への射を集めた集合を表す. 一般にこれが集合であるとは限らないが, ここではいつも集合になるような都合の良い圏だけを考える.</p>
<p>また \(h_Z\) が関手であるためには上記の対象の写し方だけでなく, 射の写し方も決める必要があるが, これは射の合成とすればよい.</p>
\[\begin{CD}
\C @&gt;h_Z&gt;&gt; \Set \\
@. @. \\
X @. \C(Z,X) \\
@VfVV @Vh_ZfVV \\
Y @. \C(Z,Y) \\
\end{CD}\]
<p>\(\C\) の射 \(f \colon X \to Y\) があるときに, \(Ef\) は \(\C(Z,X)\) から \(\C(Z,Y)\) への写像. すなわち, \(g \colon Z \to X\) なる射を, なにか \(Z \to Y\) な射に写す関数. 今あるのは</p>
<ul>
  <li>\(f \colon X \to Y\)</li>
  <li>\(g \colon Z \to X\)</li>
</ul>
<p>という2つで, \(Z \to Y\) なる射を作るにはこの2つを合成するしかない. （先に「合成すればよい」と言ったが, 逆にそれくらいしか方法がない.）</p>
\[h_Zf := (g \mapsto f \circ g)\]
<p>以上のような関手 \(h_Z\) のことを対象 \(Z\) による表現関手と呼ぶ. 「 \(Z\) が表現する」といった言い方をする.</p>
<h3>（反変）表現関手 \(h^Z\)</h3>
<p>\(h_Z\) の双対を取ることが出来る. すなわち, 対象 \(Z \in C\) から次の関手が同様に作れるはずだ.</p>
\[h^Z \colon X \mapsto \C(X, Z)\]
<p>とする. 射の写し方もやはり同様に合成で定義するのだが, その向きを考えると, こちらは反変関手になっている.</p>
\[\begin{CD}
\C @&gt;h^Z&gt;&gt; \Set \\
@. @. \\
X @. \C(X,Z) \\
@VfVV @Ah^ZfAA \\
Y @. \C(Y,Z) \\
\end{CD}\]
<p>ここで,</p>
\[h^Zf := (g \mapsto g \circ f).\]
<p>この \(h^Z\) のことを反変の表現関手と呼ぶ. 単に「表現関手」とだけ言う場合, \(h_Z\) のことも \(h^Z\) のことも指す.</p>
<h3>表現可能性</h3>
<p>ある関手 \(F \colon \C \to \Set\) が \(h_Z\) または \(h^Z\) と同値なとき, この \(F\) のことも表現関手だと見なして, 「 \(Z\) が \(F\) を表現する」という. あるいは「 \(F\) は \(Z\) によって表現可能である」とかいう.</p>
<h3>例. 始対象は \(X \mapsto 1\) を表現する</h3>
<p>いくつかの普遍性で定義される概念は表現可能性によって再定義可能である. （頑張れば全部これで定義しなおすことができる？）</p>
<p>（共変）関手を次のように定義する.</p>
\[F \colon \C \to \Set\]
\[X \mapsto 1\]
<p>ここで \(1\) は単集合 \(1 = \{ \ast \}\) . 射はすべて恒等射に潰してしまうような関手.</p>
<p>この関手を表現する対象は一般にあるとは限らないが仮に \(Z\) とする. すなわち</p>
\[F \simeq h_Z\]
<p>であるとする. この等式に試しに適当な対象 \(X \in \C\) を右から適用させると,</p>
\[\begin{align*}
&amp; FX \simeq h_Z(X) \\
\iff &amp; 1 \simeq \C(Z, X) \\
\end{align*}\]
<p>これが任意の対象 \(X\) について成り立つから, このことは「 \(Z\) から任意の対象 \(X\) への射は唯一存在する」と言える. このような \(Z\) のことはまさに <strong>始対象</strong> であることを言っている.</p>
<p>\(F\) が関手であることは適当な射 \(f \colon X \to Y\) について次の可換性も言うことができる.</p>
\[\begin{CD}
1  @&gt;\sim&gt;&gt; \C(Z, X) \\
@| @Vh_ZfVV \\
1 @&gt;\sim&gt;&gt; \C(Z, Y) \\
\end{CD}\]
<p>今 \(C(Z,X)\) は単集合だからここに含まれる唯一の射のことを \(!_X\) と呼ぶことにすれば, 上の可換式から</p>
\[h_Zf \circ !_X = !_Y\]
\[\iff f \circ !_X = !_Y\]
<p>が言える. これは始対象の普遍性を言っている.</p>
<h3>例. 終対象は反変関手 \(X \mapsto 1\) を表現する</h3>
<p>始対象の場合の双対をとって, すべて反変にすれば終対象になる.</p>
<h3>例. 直積は射のペアを表現する</h3>
<p>2つの対象 \(A,B\) について, 反変関手</p>
\[F \colon \C \to \Set\]
\[X \mapsto \C(X, A) \times \C(X, B)\]
<p>を考える. ただしここで右辺にある \(\times\) は集合の直積（デカルト積）のこと. すなわち射のペアを表す.</p>
<p>これを表現する対象があるなら, それを \(P\) だということにする. 反変なので反変表現関手 \(h^P\) と同値ということ.</p>
\[F \simeq h^P\]
<p>任意の対象 \(Z\) について,</p>
\[FZ \simeq h^P(Z)\]
\[\iff \C(Z,A) \times \C(Z,B) \simeq \C(Z,P)\]
<p>このことは非形式的に言い換えれば, 「射のペア \((u_1 \colon Z \to A, u_2 \colon Z \to B)\) は射 \(k \colon Z \to P\) と一対一対応している」ということ.</p>
<p>試しに \(Z=P\) を代入すると,</p>
\[\C(P,A) \times \C(P,B) \simeq \C(P,P)\]
<p>であるが, 恒等射 \(1 \in \C(P,P)\) が必ず存在し, それに一対一対応する射のペアが必ずあることになる. これを,</p>
\[(\pi_1, \pi_2) \in \C(P,A) \times \C(P,B)\]
<p>と呼ぶことにする.</p>
<p>さて, 今 \((Z, u_1, u_2)\) が次のようにあるとき,</p>
\[\begin{CD}
A    @&lt;u_1&lt;&lt;   Z   @&gt;u_2&gt;&gt;   B \\
\end{CD}\]
<p>先の一対一対応から, ペア \((u_1,u_2)\) に対応する射 \(k \colon Z \to P\) が存在する. この射自体を \(F\) 及び \(h^P\) は次のように写して可換図式を成す.</p>
\[\begin{CD}
FZ  @&lt;\sim&lt;&lt; h^PZ \\
@AAA         @AAA \\
FP  @&lt;\sim&lt;&lt; h^PP \\
\end{CD}\]
<p>中身を展開すると,</p>
\[\begin{CD}
\C(Z,A)\times\C(Z,B)  @&lt;\sim&lt;&lt; \C(Z, P) \\
@AFfAA                           @Ah^PfAA      \\
\C(P,A)\times\C(P,B)  @&lt;\sim&lt;&lt; \C(P, P) \\
\end{CD}\]
<p>という可換図式が得られる. \(1 \in \C(P,P)\) を右下から取ってきて可換図式を回すと次が得られる.</p>
\[(u_1, u_2) = (\pi_1 k, \pi_2 k)\]
<p>以上は \(P\) が \(A\) と \(B\) との直積であることを言っていて,</p>
<h3>例. 直和は射のペアを共変に表現する</h3>
<p>直和は直積の双対であるが, 反変で議論してたものをすべて共変に言い換えると直和が得られる.</p>
<h2>普遍射</h2>
<p>圏 \(\C\) とその対象 \(C \in \C\) 及び, 圏 \(\D\) から \(\C\) への関手 \(F \colon \D \to \C\) があるとする. このとき</p>
\[u \colon C \to FD\]
<p>なる対象 \(D \in \D\) と射 \(u\) のペア \((D,u)\) を考える.</p>
\[\begin{CD}
C @&gt;u&gt;&gt; FD
\end{CD}\]
<p>また同様のペア \((D&#x27;, u&#x27;)\) があるとする ( \(u&#x27; \colon C \to FD&#x27;\) ). そのようなときに必ず, ある \(v \colon D \to D&#x27;\) なる射が唯一存在して次が可換になること.</p>
\[\begin{CD}
C  @&gt;u&gt;&gt;  FD \\
@|        @VFvVV \\
C  @&gt;u&#x27;&gt;&gt; FD&#x27; \\
\end{CD}\]
<p>このとき, \((D,u)\) のことを <strong>\(C\) から \(F\) への普遍射</strong> という.</p>
<h3>普遍射の表現</h3>
<p>今述べた \((D&#x27;,u&#x27;)\) に対して \(v\) が唯一存在するというのはすなわち,</p>
\[\forall D&#x27; ,~~ \C(C, F(D&#x27;)) \simeq \D(D, D&#x27;)\]
<p>に他ならない. \(D&#x27;\) のところをプレースホルダーにすれば, 左辺は \(\C(C, F(-)) = h_C \circ F\) なる合成関手で, 右辺は \(h_D\) という表現関手である.</p>
\[h_C \circ F \simeq h_D\]
<p>というわけで, 普遍射の \(D\) とは \(h_C \circ F\) を表現する対象のこと. また, \(u\) とは例によって \(1 \in \D(D,D)\) に対応する \(u \in \C(C,FD)\) のことに他ならない.</p>
<h3>普遍元</h3>
<p>集合論乃至は \(\Set\) 圏においては, 単集合 \(1=\{\ast\}\) からの射とは元を表す.</p>
\[\begin{CD}
1 @&gt;e&gt;&gt; E
\end{CD}\]
<p>これを普通</p>
\[e \in E\]
<p>と書く.</p>
<p>普遍射の定義に使った \(C \in \C\) のところを \(1 \in \Set\) にして得られる普遍射 \((D,u)\) のことを, <strong>\(F\) の普遍元</strong> と呼ぶ.</p>
<h3>反変の普遍射, 普遍元</h3>
<p>矢印の向きをすべて逆にすると双対の普遍射, 普遍元が得られる. これらも単に普遍射とか普遍元と呼ぶ.</p>
\[\begin{CD}
C  @&lt;u&lt;&lt;  FD \\
@|        @AA{\exists!~Fv}A \\
C  @&lt;u&#x27;&lt;&lt; FD&#x27; \\
\end{CD}\]
<p>上記の \((D,u)\) を \(F\) から \(C\) への（反変）普遍射と呼ぶ.</p>
<h3>普遍射は随伴を作る</h3>
<p>普遍射は関手と固定の対象に対して与えられていた. 今, すべての各対象に普遍射が与えられるような場合を考える. 反変関手 \(F \colon \D \to \C\) と各 \(X \in \C\) に対して, 反変の普遍射</p>
\[(D_X, u_X)\]
\[\begin{CD}
X @&lt;u_X&lt;&lt; FD_X   \\
\end{CD}\]
<p>があるとする.</p>
<p>このときに, \(X \mapsto D_X\) という割当は \(\C\) から \(\D\) への（共変）関手になる. 対象の写し方はこれで良いが, 射の写し方はというと, 次のように自然なものがある.</p>
<p>\(\C\) での射 \(f \colon X \to Y\) があるときに, \(D_X \to D_Y\) なる射がほしいわけだが, 一旦 \(X,Y\) に対する \(u_X,u_Y\) を図示すると次の通り.</p>
\[\begin{CD}
X @&lt;u_X&lt;&lt; FD_X   \\
@VfVV @VV?V \\
Y @&lt;u_Y&lt;&lt; FD_Y \\
\end{CD}\]
<p>この \(?\) の射が存在するかどうかが問題なわけだが, ぐっとよく睨むと, 上の図には,</p>
<ul>
  <li>\(u_Y \colon FD_Y \to Y\)</li>
  <li>\(fu_X \colon FD_X \to Y\)</li>
</ul>
<p>という2つの射が分かる. そこで \((D_Y, u_Y)\) が（反変の）普遍射であることから,</p>
\[\exists v \colon D_X \to D_Y, Fv \text{ によって可換 }\]
\[\begin{CD}
X @&lt;u_X&lt;&lt; FD_X   \\
@VfVV @VVFvV \\
Y @&lt;u_Y&lt;&lt; FD_Y \\
\end{CD}\]
<p>この \(v\) を \(G(f)\) だと定義すればよい.</p>
\[\begin{CD}
X @. D_X   \\
@VfVV @VVvV \\
Y @. D_Y \\
\end{CD}\]
<p>以上によって関手 \(G \colon \C \to \D\) が構成できた.</p>
<p>このとき, 自由に持ってきた \(D \in \D\) と \(C \in \C\) について,</p>
\[\C(FD, C) \simeq \D(D, GC)\]
<p>なる自然同型を満たす. ところでこれを満たす \(F,G\) の関係を随伴と呼ぶのだった.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
