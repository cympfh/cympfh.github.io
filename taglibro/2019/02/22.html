<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Fri Feb 22 2019</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../../../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='../../index.html'><i class="fa fa-save" style="position:absolute; left:0.4em; top:0.4em; width:1.3em;border-radius:0.8em;"></i></a>
</header>
<header>
<h1 class="title">Fri Feb 22 2019</h1>
</header>
<h2 id="最近こんなものを貰った">最近こんなものを貰った</h2>
<p>ルンバ (Roomba 890) と 睡眠パッド (Withings/Nokia WSM02-ALL-JP) を貰った.</p>
<h2 id="ルンバについて">ルンバについて</h2>
<p>ルンバを貰った. これは何だかんだ言っても掃除機なので、それなりに動作音がする. その音を使って朝の目覚ましにもしようかとも思ったけど、床の上のものを片付けてあるかチェックするかなどの手間が必要なので、結局、平日の15時に自動で動かす運用にした. 平日なら昼くらいには家を出てるので、出る前に床にルンバの敵がいないか（特に紐類とビニール袋の類が大敵だ）をチェックし、そうして家が留守の間に掃除をしてもらう. 部屋と部屋の間のドアは全開にしておいて、一台でできるだけ家全体を掃き掃除してもらう. 基本的にはくまなくやってくれるので、家に帰ってくれば床には髪の毛一本落ちてないのは精神にも衛生的で良い. しかし丸い体をしてるでせいで、四隅は掃ききれずに見事にホコリが溜まる. たまに気づいたら手で掃除する必要がある.</p>
<p>床に大敵をうっかり放置していると、いろんなルンバは死ぬ. 裏のローラーのところに紐をがっつり絡ませて死んでいたりする. この間はうっかりお風呂場に入ってしまって、そうして帰れないで電池切れで死んでいた. 死ぬ要因は少しずつ取り除いているが、それでも時々は新しい死に方を見せてくれる.</p>
<p>ルンバが他の掃除機ロボットと違う点として、ルンバは掃除が終わったら自分でホームベースに帰ってくる. ホームベースとは要するに充電器のことだ. ルンバの電池は結構すぐ切れて、二時間持たないくらいの容量しかない. だからこそ自ら充電する仕組みが取り入れられたのだと思う. 自分でホームベースに帰ってくるというと、ホームベースの場所をいつも把握してくれて、帰ろうと思ったら一直線に向かってくるというイメージかもしれないが、別にそんなことはない. ホームベース自体が何かしらのビームを放射しており（弱い赤外線だと思う）、ルンバはホームベースに帰りたいモードのときは基本的には掃除をし、ホームベースからのビームをキャッチすると、つまりホームベースの目の前をたまたま偶然通ると、ホームに向かって誘導される、というのが正しい. 従って帰ってこれるかどうかは本質的に運である. 帰ってくるより前に二時間が経てば電気切れで死んでしまう.</p>
<h2 id="睡眠パッドについて">睡眠パッドについて</h2>
<p>睡眠パッドを貰った. ベッドのマットの下に入れておくと、睡眠時間や質を測ってくれるやつ. アプリで記録が見られるし、IFTTTと連携することが出来る.</p>
<p>ベッドで使うのが前提だと思う. というのも電源を取るのにコンセントを挿しておく必要がある（充電が出来るわけではない）. 布団を毎朝畳んでる私としては邪魔な感がある. また設置するたびにキャリブレーションの必要があるが、これは時々勝手にしているようで気にしなくていい. とにかく、寝る前にマットの下に敷いてあって電源が取れているようにしてあれば、あとは勝手にやってくれる.</p>
<p>Health Mate とかいうアプリに接続しておくと IFTTT にも連携できるようになる. &quot;Bed in&quot;, &quot;Bed out&quot; をトリガーにして何かをさせることができる. これは要はパッドの上に体重を乗せれば Bed in で、逆になくなれば Bed out というだけであって、 本当の意味で眠りについたか目が覚めたか、ではない. 布団の上でごろごろして本を読んでるだけで反応してしまう.</p>
<p>それを承知で &quot;If *'s sleep sensor detects you get into bed, then Make a web request&quot; を作って、自分の鯖に受け口を作って、寝起きの時間のログをとるのをやってみている.</p>
<p>ログはここで見られる: http://s.cympfh.cc/cympfh/sleep</p>
<p>大変ノイジーで寝た五分後にまた寝たりしている.</p>
<script src="https://gist.github.com/cympfh/b239cc550b10b12693632a5d6a715df1.js"></script>
<footer>
    <p class="is-pulled-right">
    @cympfh / mail@cympfh.cc
    </p>
</footer>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
