<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>現代意味論入門の読書メモ</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="resources/index.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 style="font-size:1em; position:absolute; left:0; top:-0.8em; font-size:2.0em !important">
    <a href='index.html'>
    <img src="../resources/img/identicon.png" style="position:relative; top:0.4em; width:1.3em;border-radius:0.8em;" /> aiura/
    </a>
</h1>
<header>
<h1 class="title">現代意味論入門の読書メモ</h1>
</header>
<p class="date" style="text-align: right">
2016-11-11 (Sun.)
</p>
<div class="tags" style="text-align: right">
<p><a class=tag href=index.html#言語>言語</a> <a class=tag href=index.html#意味論>意味論</a></p>
</div>
<h2 id="index">INDEX</h2>
<div id="toc">

</div>
<h2 id="テキスト">テキスト</h2>
<ul>
<li>吉本啓, 中村裕昭: &quot;現代意味論入門&quot;
<ul>
<li>&quot;現代意味論入門&quot; では、人間がコミュニケーションの目的に用いる自然言語を、一回述語論理といった形式言語に翻訳し、意味を与える一連の手続きを解説している. というかまあ意味ありきの形式言語だけど. 論理のための形式言語はシンタックス (統辞論) と解釈 (意味論) から成る. 翻訳とは自然言語からシンタックスへの変換であり、これは人間が手作業で行う. シンタックスから意味への解釈は機械的にも可能なよう形式的に定義がなされる.</li>
</ul></li>
</ul>
<h2 id="可能世界意味論">可能世界意味論</h2>
<p>&quot;雪が降っている&quot; には真偽が与えられるのに対して &quot;雪が降っているかもしれない&quot; には普通の述語論理の枠組みでは真偽が与えにくい. &quot;可能世界 (possible world)&quot; という概念によってこれが可能となる. ここで言う世界とは変数への真偽割当のことであり、普通の述語論理では世界がただ一通りしかないのに対して、複数あり得るとする. &quot;かもしれない&quot; は、真となるような世界が少なくとも一つはある、と言っていると解釈する.</p>
<h3 id="様相論理">様相論理</h3>
<p>述語論理に <strong>到達 (accessible)</strong> 可能世界及び2つの演算子</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\Box\)</span>: 必然性, necessity</li>
<li><span class="math inline">\(\Diamond\)</span>: 可能性, possibility</li>
</ol>
<p>を導入する.</p>
<p>話している今の世界 <span class="math inline">\(w\)</span> から到達可能な (唯一つとは限らない) 世界 <span class="math inline">\(w_1, w_2, \ldots w_n\)</span> を到達可能世界といい、 この関係を <span class="math inline">\(R\)</span> とし、 <strong>フレーム</strong> と呼ぶ. 即ち <span class="math inline">\(R\)</span> とは、 あり得る世界全体を <span class="math inline">\(\mathcal{W}\)</span> としたとき、<span class="math inline">\(\mathcal{W} \times \mathcal{W}\)</span> の部分集合である. 例えば <span class="math inline">\(w\)</span> から <span class="math inline">\(w&#39;\)</span> に到達可能であることを <span class="math inline">\(w R w&#39;\)</span> と書く.</p>
<p>そして演算子の定義は次のようである.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\Box \phi\)</span> は到達可能な全ての世界で <span class="math inline">\(\phi\)</span> が真となること</li>
<li><span class="math inline">\(\Diamond \phi\)</span> は到達可能な少なくとも一つの世界で <span class="math inline">\(\phi\)</span> が真となること</li>
</ol>
<h3 id="フレームに関する諸性質">フレームに関する諸性質</h3>
<p>フレームに関して次のような性質が考えられる. これは、こういうバリエーションが考えられるというだけであって、別に制限を与えるわけではない.</p>
<ol style="list-style-type: decimal">
<li>再帰性 (reflexivity)
<ul>
<li><span class="math inline">\(\forall w, wRw\)</span> であること. この性質と <span class="math inline">\(\Box p \rightarrow p\)</span> とは同値.</li>
</ul></li>
<li>対称性 (symmetry)
<ul>
<li><span class="math inline">\(w_1 R w_2\)</span> ならば <span class="math inline">\(w_2 R w_1\)</span> であるような性質で、<span class="math inline">\(\Diamond \Box \phi \rightarrow \phi\)</span> と同値.</li>
</ul></li>
<li>推移性 (transivity)
<ul>
<li><span class="math inline">\(w_1 R w_2 \land w_2 R w_3 \rightarrow w_1 R w_3\)</span> であることで、<span class="math inline">\(\Box \phi \rightarrow \Box \Box \phi\)</span> と同値.</li>
<li><em>N.B.</em> &quot;到達可能&quot; という言葉からついついこの性質を暗黙に仮定しがちだが、これが成り立たないフレームも考えられるということ</li>
</ul></li>
</ol>
<p>ところで我々が日常会話をする際に、そんな難しいことを考えることは滅多にない. これは、任意の世界から任意の世界へ到達可能 (普遍的到達関係) なフレームを前提にしているから.</p>
<h2 id="内包的文脈">内包的文脈</h2>
<p>動詞について内包的/外延的の区別がある. 「信じる」や「探す」は内包性を伴う目的語や補文をとるので内包的である. 「知る」や「見る」は外延的である.</p>
<blockquote>
<p>その肝心の「内包性」ってなんやねんという感じだが、それは下の意味論を読んで理解すればいいことである.</p>
</blockquote>
<p>&quot;神の存在を信じる&quot; は &quot;神の存在&quot; を目的語にとっているが、それの真偽に関わらず &quot;を信じる&quot; をつければ真になり得る. 一方で、&quot;を見る&quot; だと、神の存在が偽のとき、&quot;を見る&quot; も偽に成る.</p>
<p>この内包を表現するのに可能世界の概念を利用する.</p>
<h2 id="内包論理-内包タイプ理論">内包論理 (内包タイプ理論)</h2>
<p>内包の概念を導入した内包論理はいくつかバリエーションがあるが、 ここではモンタギュー意味論にも使われるバージョンを説明する. これはモンタギュー自身が &quot;The Proper Treatment of Quantifinication in Ordinary English&quot; (PTQ in short) [Montague, 1973] の中で提案したもので、 このテキストの中ではこの論理体系のことを PTQ と呼ぶ.</p>
<p>この論理においてシンタックスの正しい一つの式を <span class="math inline">\(\text{ME}\)</span> (meaning expression) と呼ぶ. これはいわゆる整式 (well-formed formulae) に相当する. 型がついている. <span class="math inline">\(\text{ME}\)</span> 一つにはタイプ <span class="math inline">\(a\)</span> が対応づいている. タイプ <span class="math inline">\(a\)</span> 全体を <span class="math inline">\(\text{ME}_a\)</span> と書く. 例えば <span class="math inline">\(\text{ME}\)</span> <span class="math inline">\(\phi\)</span> がタイプ <span class="math inline">\(a\)</span> を持つことを <span class="math inline">\(\phi \in \text{ME}_a\)</span> で表す.</p>
<p>あと<span class="math inline">\(\text{ME}\)</span> であるものとして、変数および定数がある. 変数全体を <span class="math inline">\(\text{VAR}\)</span>、定数全体を <span class="math inline">\(\text{CON}\)</span> で表す. <span class="math inline">\(\text{ME}\)</span> 同様に、型を右下に添えて <span class="math inline">\(\text{VAR}_a, \text{CON}_a\)</span> などと書く.</p>
<h3 id="シンタックス">シンタックス</h3>
<p><span class="math inline">\(\text{ME}\)</span> のシンタックスを定義する前に簡単にタイプを定義する.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(s, t\)</span> はタイプである</li>
<li><span class="math inline">\(a, b\)</span> がタイプならば <span class="math inline">\((a,b)\)</span> もタイプである</li>
<li>この2つで定められるもののみがタイプである</li>
</ol>
<p>では <span class="math inline">\(\text{ME}\)</span> の型付規則と共にシンタックスを定義する.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\alpha \in \text{VAR}_a \cup \text{CON}_a\)</span> ならば <span class="math inline">\(\alpha \in \text{ME}_a\)</span></li>
<li><span class="math inline">\(\alpha \in \text{ME}_a, u \in \text{VAR}_b\)</span> ならば <span class="math inline">\(\lambda u. \alpha \in \text{ME}_{(b,a)}\)</span></li>
<li><span class="math inline">\(\alpha \in \text{ME}_{(b, a)}, \beta \in \text{VAR}_b\)</span> ならば <span class="math inline">\(\alpha(\beta) \in \text{ME}_a\)</span></li>
<li><span class="math inline">\(\alpha, \beta \in \text{ME}_a\)</span> なら <span class="math inline">\((\alpha = \beta) \in \text{ME}_t\)</span> (<span class="math inline">\(t\)</span> は真偽値を表すタイプ)</li>
<li><span class="math inline">\(\phi, \psi \in \text{ME}_t, u \in \text{VAR}_b\)</span> なら次は全て <span class="math inline">\(\text{ME}_t\)</span>
<ul>
<li><span class="math inline">\(\lnot \phi\)</span></li>
<li><span class="math inline">\(\phi \land \psi\)</span></li>
<li><span class="math inline">\(\phi \lor \psi\)</span></li>
<li><span class="math inline">\(\phi \rightarrow \psi\)</span></li>
<li><span class="math inline">\(\phi \leftrightarrow \psi\)</span></li>
<li><span class="math inline">\(\exists u, \phi\)</span></li>
<li><span class="math inline">\(\forall u, \phi\)</span></li>
<li><span class="math inline">\(\Box u, \phi\)</span></li>
<li><span class="math inline">\(\Diamond u, \phi\)</span></li>
</ul></li>
<li><span class="math inline">\(\alpha \in \text{ME}_a\)</span> なら <span class="math inline">\(\uparrow \alpha \in \text{ME}_{(s, a)}\)</span></li>
<li><span class="math inline">\(\alpha \in \text{ME}_{(s, a)}\)</span> なら <span class="math inline">\(\downarrow \alpha \in \text{ME}_a\)</span></li>
</ol>
<p><span class="math inline">\(\uparrow \alpha\)</span> であるがこれはタイプを見ると分かるように <span class="math inline">\(s\)</span> を受け取る関数である. <span class="math inline">\(s\)</span> は可能世界のタイプで、上に出てくるいずれにも付かないタイプである.</p>
<h3 id="意味論">意味論</h3>
<p><span class="math inline">\(\text{ME}\)</span> <span class="math inline">\(\phi\)</span> の解釈を <span class="math inline">\([\![\phi]\!]\)</span> と書く. <span class="math inline">\([\![ \_ ]\!]\)</span> は解釈関数. 特に世界 <span class="math inline">\(w\)</span> における解釈を <span class="math inline">\([\![\phi]\!]_w\)</span> と書いたり、変数割当 <span class="math inline">\(u=a\)</span> における解釈を <span class="math inline">\([\![\phi]\!]_{u=a}\)</span> などと書くことにします. あとタイプ <span class="math inline">\(a\)</span> の <span class="math inline">\(\text{ME}\)</span> を解釈して得られる値全体を解釈領域 <span class="math inline">\(D_a\)</span> と書く.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\alpha \in \text{CON}_a\)</span> (定数) のとき <span class="math inline">\([\![\alpha]\!]_w\)</span> は<span class="math inline">\(w\)</span> に基づいて解釈する (これは世界に依存)</li>
<li><span class="math inline">\(\alpha \in \text{VAR}_a\)</span> (変数) のとき <span class="math inline">\([\![\alpha]\!]\)</span> は適当にその文脈に基づいて解釈する (これは世界から切り離されてる)</li>
<li><span class="math inline">\(\alpha \in \text{ME}_a, u \in \text{ME}_b\)</span> のとき <span class="math inline">\([\![\lambda u. \alpha]\!]_w\)</span> は
<ul>
<li><span class="math inline">\(d \in D_b\)</span> を <span class="math inline">\([\![\alpha]\!]_{w, u=d}\)</span> に写す関数</li>
<li>簡単に <span class="math inline">\(\lambda d. [\![ \alpha]\!]_{w, u=d}\)</span> と書く</li>
</ul></li>
<li><span class="math inline">\(\alpha \in \text{ME}_{(a,b)}, \beta \in \text{ME}_a\)</span> のとき <span class="math inline">\([\![\alpha(\beta)]\!] = [\![\alpha]\!]([\![\beta]\!])\)</span></li>
<li><span class="math inline">\(\alpha \in \text{ME}_a\)</span> のとき <span class="math inline">\([\![\alpha=\beta]\!]\)</span> は
<ul>
<li><span class="math inline">\([\![\alpha]\!] = [\![\beta]\!]\)</span> のとき <span class="math inline">\(1\)</span></li>
<li>さもなくば <span class="math inline">\(0\)</span></li>
</ul></li>
<li><span class="math inline">\([\![\lnot \phi]\!]\)</span>
<ul>
<li>同様</li>
</ul></li>
<li><span class="math inline">\([\![\phi \land \psi]\!]\)</span></li>
<li><span class="math inline">\([\![\phi \lor \psi]\!]\)</span></li>
<li><span class="math inline">\([\![\phi \rightarrow \psi]\!]\)</span></li>
<li><span class="math inline">\([\![\phi \leftrightarrow \psi]\!]\)</span></li>
<li><span class="math inline">\([\![\exists u, \phi]\!]\)</span></li>
<li><span class="math inline">\([\![\forall u, \phi]\!]\)</span></li>
<li><span class="math inline">\(\phi \in \text{ME}_t\)</span> のとき <span class="math inline">\([\![\Box \phi]\!]\)</span> は
<ul>
<li>全ての <span class="math inline">\(w \in \mathcal{W}\)</span> について <span class="math inline">\([\![\phi]\!]_w\)</span> が <span class="math inline">\(1\)</span> ならば <span class="math inline">\(1\)</span></li>
<li>さもなくば <span class="math inline">\(0\)</span></li>
</ul></li>
<li><span class="math inline">\(\phi \in \text{ME}_t\)</span> のとき <span class="math inline">\([\![\Diamond \phi]\!]\)</span> は
<ul>
<li>ある <span class="math inline">\(w\)</span> で <span class="math inline">\([\![\phi]\!]_w = 1\)</span> ならば <span class="math inline">\(1\)</span></li>
<li>さもなくば <span class="math inline">\(0\)</span></li>
</ul></li>
<li><span class="math inline">\([\![\uparrow \alpha]\!]\)</span> は次のような関数
<ul>
<li>世界 <span class="math inline">\(w \in \mathcal{W}\)</span> を <span class="math inline">\([\![\alpha]\!]_w\)</span> に写す関数</li>
</ul></li>
<li><span class="math inline">\([\![\downarrow \alpha]\!]_w = ([\![\alpha]\!])(w)\)</span></li>
</ol>
<p>また解釈領域はある程度、具体的に書けて</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(D_t = \{0, 1\}\)</span></li>
<li><span class="math inline">\(D_{(a,b)} = D_b^{D_a} = \{(x,y): x \in D_a, y \in D_b\}\)</span></li>
</ol>
<p>注意事項としては、<span class="math inline">\(s\)</span> という型は世界 <span class="math inline">\(w\)</span> に特別に与えたものであるが、<span class="math inline">\(s\)</span> を基本型として与えたわけではない. すなわち <span class="math inline">\(s\)</span> という型を持つ  は定められていない.</p>
<h3 id="諸性質">諸性質</h3>
<p><span class="math inline">\(\phi\)</span> という述語についてこれの内包 <span class="math inline">\(\uparrow \phi\)</span> を、内包論理では <strong>属性 (property)</strong> という.</p>
<p>属性のある世界への適用は <span class="math inline">\(\downarrow \uparrow \phi\)</span> であるが、一般に <span class="math inline">\([\![ \downarrow \uparrow \phi ]\!] = [\![\phi]\!]\)</span> である. これを down-up cancellation という.</p>
<p><span class="math inline">\([\![ \uparrow \downarrow \phi ]\!] = [\![\phi]\!]\)</span> は一般には <strong>成り立たない</strong>.</p>
<p>反例として、</p>
<ul>
<li><span class="math inline">\(\alpha = \lambda w. A\)</span></li>
<li><span class="math inline">\(A\)</span> は定数
<ul>
<li>世界 <span class="math inline">\(u\)</span> では <span class="math inline">\(A=0\)</span></li>
<li>世界 <span class="math inline">\(v\)</span> では <span class="math inline">\(A=1\)</span></li>
</ul></li>
</ul>
<p>とする. イコールを仮定する.</p>
<ul>
<li><span class="math inline">\([\![\alpha]\!]_u = [\![\uparrow \downarrow \alpha]\!]_u\)</span></li>
<li><span class="math inline">\(= \lambda w. [\![\downarrow \alpha]\!]_w = \lambda w. [\![\alpha]\!]_w(w)\)</span></li>
<li><span class="math inline">\(\implies\)</span> (両辺に <span class="math inline">\(v\)</span> を適用)</li>
<li><span class="math inline">\(0 = [\![A]\!]_u = [\![\alpha]\!]_u(v) = (\lambda w [\![\alpha]\!]_w(w))(v) = [\![\alpha]\!]_v(v) = [\![A]\!]_v = 1\)</span></li>
</ul>
<p>定数関数を評価するタイミングにおける世界が異なるのが原因. (thanks to <span class="citation">@autotaker1984</span>)</p>
<h2 id="two-sorted-type-theory">two-sorted type theory</h2>
<p>上でも注意事項として書いたように、PTQ では <span class="math inline">\(s\)</span> を基本型として与えていなかったが、それを認める論理も考えられる. two-sorted type theory では PTQ に <span class="math inline">\(w \in \mathcal{W} = \text{ME}_s = D_s\)</span> を加える.</p>
<p>この論理では内包論理に少し変更を加えることで述語論理と等しい表現力を持っていることが確認できる. すなわち <span class="math inline">\(\uparrow\)</span> とか <span class="math inline">\(\Diamond\)</span> などという演算子は不要になる.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\uparrow \phi \equiv \lambda w. \phi_w\)</span></li>
<li><span class="math inline">\(\downarrow \phi \equiv \phi(w)\)</span></li>
<li><span class="math inline">\(\Box \phi \equiv \forall w. \phi_w\)</span></li>
<li><span class="math inline">\(\Diamond \phi \equiv \exists w. \phi_w\)</span></li>
<li><span class="math inline">\([\![\phi_w]\!]_v = [\![\phi]\!]_w\)</span></li>
</ol>
<h2 id="neo-davidsonian-approach-新-davidson-方式">neo-Davidsonian approach (新 Davidson 方式)</h2>
<p>「<span class="math inline">\(b\)</span>が<span class="math inline">\(c\)</span>を殺す」という述語を意味する <span class="math inline">\(\text{KILL}(b,c)\)</span> と作ったとして、 「<span class="math inline">\(b\)</span>が<span class="math inline">\(c\)</span>を<span class="math inline">\(k\)</span>を用いて殺す」という述語を作りたくなったので <span class="math inline">\(\text{KILL}(b,c,k)\)</span> としたとする. 同じ字面を用いたとしても２つは異なる集合であり、次のような自然な推論:</p>
<p><span class="math display">\[\text{KILL}(b,c,k) \rightarrow \text{KILL}(b,c)\]</span></p>
<p>を導くような関係を二項演算<span class="math inline">\(\text{KILL}\)</span>と三項演算<span class="math inline">\(\text{KILL}\)</span>との間に定めたい. 或いは「何で」以外にも、「何処で」を付け足そうと思うと新しい述語を作る必要が出てくる.</p>
<p>[Davidson 1967] では最低限の引数として主語目的語以外のコンテキストを <strong>イベント</strong> と呼んで、これら3つの引数をいつも取るように <span class="math inline">\(\text{KILL}(b,c,e)\)</span> と設計する. 「何で」は <span class="math inline">\(e\)</span> の中に含まれてる情報だとして、それを取り出す述語 <span class="math inline">\(\text{INSTRUCT}\)</span> を用いる. 「<span class="math inline">\(b\)</span>が<span class="math inline">\(c\)</span>を<span class="math inline">\(k\)</span>で殺す」を「<span class="math inline">\(b\)</span>が<span class="math inline">\(c\)</span>を殺す、かつ、<span class="math inline">\(k\)</span> で」と読み替えて、</p>
<p><span class="math display">\[\text{KILL}(b,c,e) \land \text{INSTRUCT}(e,k)\]</span></p>
<p>と翻訳する. 単に「殺す」は</p>
<p><span class="math display">\[\text{KILL}(b,c,e)\]</span></p>
<p>と書ける. ただの連言だから</p>
<p><span class="math display">\[\text{KILL}(b,c,e) \land \text{INSTRUCT}(e,k) \rightarrow \text{KILL}(b,c,e)\]</span></p>
<p>は自然に導ける.</p>
<p>このように、あらゆる述語について引数を一つ増やしていつもイベント <span class="math inline">\(e\)</span> を受け取るようにした意味論をイベント意味論 (event semantics) と呼ぶ. [Parsons, 1990] はこれをさらに推し進め、動詞はイベントのみを受け取る一項演算子で、他はイベントから一属性を確認するだけの二項演算子にした. これを neo-Davidsonian approach という.</p>
<p>「殺した、主体が<span class="math inline">\(a\)</span>で、対象が<span class="math inline">\(b\)</span>で、手段が<span class="math inline">\(c\)</span>」を</p>
<p><span class="math display">\[\text{KILL}(e) \land \text{AGENT}(e,a) \land \text{PATIEND}(e,c) \land \text{INSTRUCT}(e,k)\]</span></p>
<p>と翻訳する. 但しこれらは結局、述語論理と同等の表現力しかない.</p>
<h2 id="モンタギュー意味論-montague-semantics">モンタギュー意味論 (Montague Semantics)</h2>
<p>自然言語と述語論理との間には大きな隔たりがあった. モンタギューは自然言語も形式言語の一つとして扱い、自然言語にも形式言語同様の解釈を与えることを目指した. 本章はPTQ [Montague, 1973] で採択された方法を説明する. これでは自然言語は内包論理に翻訳され、内包論理について意味論が定義される.</p>
<blockquote>
<p>&quot;English as a Formal Language (EFL) [Montague, 1970] では自然言語に対して直接意味論を定義することを試みられた.</p>
</blockquote>
<h3 id="構成性原理-フレーゲの原理">構成性原理 (フレーゲの原理)</h3>
<p>複雑な表現の解釈は部分の解釈の関数である.</p>
<p>これは即ち、 2つの語句 <span class="math inline">\(\alpha, \beta\)</span> をシンタックスの上で結合させた <span class="math inline">\(F(\alpha, \beta)\)</span> の解釈 <span class="math inline">\([\![F(\alpha, \beta)]\!]\)</span> は適当な関数 <span class="math inline">\(G\)</span> があって <span class="math display">\[[\![F(\alpha, \beta)]\!] = G([\![\alpha]\!], [\![\beta]\!])\]</span> となることを言っている. <span class="math inline">\([\![ \_ ]\!]\)</span> の準同型とも言える.</p>
<p>モンタギュー意味論では文法 <span class="math inline">\(F_i\)</span> について(<span class="math inline">\(i\)</span> は適当な添字) <span class="math inline">\(G_i\)</span> を具体的に構成していく.</p>
<h3 id="名詞句の解釈">名詞句の解釈</h3>
<p>&quot;John runs&quot;, &quot;Some boys run&quot;, &quot;Every boy runs&quot; を次のように解釈することにする.</p>
<ul>
<li><span class="math inline">\([\![\text{run}]\!] \in [\![\text{John}]\!]\)</span></li>
<li><span class="math inline">\([\![\text{run}]\!] \in [\![\text{some}~\text{boys}]\!]\)</span></li>
<li><span class="math inline">\([\![\text{run}]\!] \in [\![\text{every}~\text{boy}]\!]\)</span></li>
</ul>
<p>これは述語論理における述語の解釈と逆である (述語論理なら <span class="math inline">\([\![\text{John}]\!] \in [\![\text{run}]\!]\)</span>). これは量子化を上手く扱うために都合が良い.</p>
<p>John の解釈は、述語論理では単に個体 <span class="math inline">\(a\)</span> としていた. モンタギュー意味論ではジョンに体操する個体 <span class="math inline">\(a\)</span> という記号を使いながらも、Johnの解釈自体は 「<span class="math inline">\(a\)</span> が成り立つ述語全体」としている.</p>
<p>例えば</p>
<p>(個人に対応する) 個体 <span class="math inline">\(a, b, c\)</span> に関する述語として <span class="math inline">\(BOY, RUN, SING\)</span> があるとする. 述語論理同様、述語は、それを満たす個体の集合である.</p>
<ul>
<li><span class="math inline">\([\![\text{BOY}]\!] = \{ a,b,c \}\)</span></li>
<li><span class="math inline">\([\![\text{RUN}]\!] = \{ a,b \}\)</span></li>
<li><span class="math inline">\([\![\text{SING}]\!] = \{ b,c \}\)</span></li>
</ul>
<p>例えば <span class="math inline">\(a\)</span> が <span class="math inline">\(\text{BOY}\)</span> を満たすかに関しては <span class="math inline">\([\![\text{BOY}(a)]\!] = ([\![a]\!] \in [\![\text{BOY}]\!]) = 1\)</span> と解釈する. そして述語論理であれば、 <span class="math inline">\([\![\text{John}]\!] = a\)</span> であったが、モンタギュー意味論では異なる.</p>
<p><span class="math display">\[[\![\text{John}]\!] = \{ [\![P]\!] : P(a) = 1\} = \{ [\![\text{BOY}]\!], [\![\text{RUN}]\!] \} = \{\{a,b,c\},\{a,b\}\]</span></p>
<p>量子化については次のように解釈する</p>
<p><span class="math inline">\([\![\text{some}~\text{boys}]\!]\)</span> は <span class="math inline">\(a,b,c\)</span> のいずれかを成立させる述語全体: <span class="math display">\[[\![\text{some}~\text{boys}]\!] = \{ [\![P]\!] : P \cap \{a,b,c\} \ne \emptyset \} = \{[\![BOY]\!],[\![RUN]\!],[\![SING]\!]\}\]</span></p>
<p><span class="math inline">\([\![\text{every}~\text{boy}]\!]\)</span> は <span class="math inline">\(a,b,c\)</span> の全てを成立させる述語全体: <span class="math display">\[[\![\text{every}~\text{boys}]\!] = \{ [\![P]\!] : \{a,b,c\} \subseteq P \ne \emptyset \} = \{[\![BOY]\!]\}\]</span></p>
<p>ここで「主語述語構造」の解釈を定める.</p>
<p>文 <span class="math inline">\(S \rightarrow NP~VP\)</span> について <span class="math inline">\([\![S]\!] = ([\![VP]\!] \in [\![NP]\!])\)</span></p>
<h3 id="内包論理の下の名詞句の翻訳">内包論理の下の名詞句の翻訳</h3>
<p>先章では John という個体を単に John と書いたが、PTQ では個体はより複雑に</p>
<p><span class="math display">\[\lambda X. \downarrow X(\text{John})\]</span></p>
<p>と記述することにする.</p>
<h3 id="内包論理の下の主語名詞句の翻訳">内包論理の下の主語名詞句の翻訳</h3>
<p>「<span class="math inline">\(\alpha\)</span> が <span class="math inline">\(\delta\)</span> する」という主語名詞句の翻訳 (自然言語からPTQ) を <span class="math inline">\(\alpha(\uparrow \delta)\)</span> (関数適用) と定める.</p>
<p>集合と特性関数 (特徴関数) の区別をしなければ (<span class="math inline">\(A\)</span> という集合を <span class="math inline">\(A(x) = 1 \text{ if } x \in A \text{ else } 0\)</span> という関数と同一視する)、 &quot;John runs&quot; の解釈は</p>
<p><span class="math display">\[\left(\lambda X. \downarrow X(\text{John}))(\uparrow \text{run})
= \downarrow \uparrow \text{run}(\text{John})
= \text{run}(\text{John})\]</span></p>
<p>となる. これはいわゆる述語論理における記述と等しい.</p>
<p>最後の <span class="math inline">\(=\)</span> には <span class="math inline">\(\downarrow \uparrow\)</span> 打ち消しを用いた. 名詞句でわざわざ <span class="math inline">\(\downarrow\)</span> していて、動詞の適用の際に <span class="math inline">\(\uparrow\)</span> させているのは、適切に内包的動詞を扱うための技巧である.</p>
<h3 id="量化された名詞句">量化された名詞句</h3>
<p>同様に &quot;Every boy runs&quot; といった量化された主語名詞句を持った文を内包論理の下で翻訳したい.</p>
<p>まず &quot;Every boy&quot; を翻訳するわけだが、先ほどと同様に &quot;run&quot; を関数適用して、最終的に</p>
<p><span class="math display">\[\forall x. \text{BOY}(x) \rightarrow \text{run}(x)\]</span></p>
<p>が得られれば良い.</p>
<p>というわけで次のように定める.</p>
<ol style="list-style-type: decimal">
<li>「全ての <span class="math inline">\(\zeta\)</span>」を <span class="math inline">\(\lambda X. \forall x (\zeta(x) \rightarrow \downarrow X(x))\)</span> と翻訳する</li>
<li>「ある <span class="math inline">\(\zeta\)</span>」を <span class="math inline">\(\lambda X. \exists x (\zeta(x) \land \downarrow X(x))\)</span> と翻訳する</li>
</ol>
<p>これを用いれば &quot;Some Boys run&quot;</p>
<h3 id="内包的動詞">内包的動詞</h3>
<p>動詞には内包/外延の区別がある.</p>
<p>例えばこの世界には存在しない動物としてユニコーンがあるが、 「ユニコーンを探す」と「ユニコーンを見つける」は事情が異なる. 前者はユニコーンの存在とは独立に真にもなり得る行為であるが、 後者はユニコーンが存在しない故に常に偽となるような文である.</p>
<p>可能世界、内包論理はこのためにある. すなわち、ユニコーンが存在して形を持つ世界を想像できることで、常に偽となるにも関わらず、 「ユニコーン」と「ゴジラ」とを区別して使うことができる.</p>
<p>ただし動詞が内包的に使われるかどうかはしばしば曖昧である.</p>
<ol style="list-style-type: decimal">
<li>彼はユニコーンを探している</li>
<li>母親が公園で少女を探している</li>
</ol>
<p>1つ目は存在しないものを存在をなかば信じて探す行為でこれは内包的である. 2つ目は探している少女の存在を知っていて外見もしった上で探す行為であり、これは外延的である. これらの「探す」は英語であっても特別に区別なく <span class="math inline">\(\text{FIND}\)</span> や <span class="math inline">\(\text{SEEK}\)</span> が使われる.</p>
<blockquote>
<p>いやもしかしてら二つ目の文も内包的に使われてるようにも見えなくもない. 内包的に読むのはただテキスト通りに読む <strong>事物読み (de re reading)</strong> といい、 テキストの奥に「主語は目的語の存在を知ってるから探してるのだ」と深読みするのを <strong>言表読み (de dicto reading)</strong> という.</p>
</blockquote>
<h3 id="内包論理の下の他動詞の翻訳">内包論理の下の他動詞の翻訳</h3>
<p>「<span class="math inline">\(\beta\)</span> を <span class="math inline">\(\delta\)</span> する」を <span class="math inline">\(\delta(\uparrow \beta)\)</span> と翻訳する.</p>
<p>例として「ジョンがあるユニコーンを探す」を「ジョンが「「あるユニコーンを」探す」」という木構造で翻訳してみる.</p>
<ol style="list-style-type: decimal">
<li>「あるユニコーン」
<ul>
<li><span class="math inline">\(\lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x))\)</span></li>
</ul></li>
<li>「あるユニコーンを探す」
<ul>
<li><span class="math inline">\(\text{SEEK}(\uparrow \lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x)))\)</span></li>
</ul></li>
<li>「ジョンがあるユニコーンを探す」
<ul>
<li><span class="math inline">\((\lambda X. \downarrow X(\text{John})) (\uparrow \text{SEEK}(\uparrow \lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x))))\)</span></li>
<li><span class="math inline">\(= \text{SEEK}(\uparrow \lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x)))(\text{John})\)</span></li>
</ul></li>
</ol>
<p>ここで <span class="math inline">\(\text{SEEK}\)</span> がある種のカリー化された引数を2つ受け付ける関数になっている <span class="math inline">\((A \rightarrow (B \rightarrow C))\)</span> になってるから、 二項関数 <span class="math inline">\(((B, A) \rightarrow C)\)</span> と同一視して</p>
<p><span class="math display">\[\text{SEEK}(\text{John}, \uparrow \lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x)))\]</span></p>
<p>と書く. <span class="math inline">\(\text{SEEK}\)</span> の目的語は <span class="math inline">\(\uparrow\)</span> によって内包化されているため、それ自体は、解釈する世界に <strong>依らず</strong> 、世界を引数とする関数であるので、 <span class="math inline">\(\text{UNICORN}\)</span> を <span class="math inline">\(\text{GODZILLA}\)</span> で置き換えたものと完全に区別ができる.</p>
<p>しかし、逆にこの <span class="math inline">\(\text{SEEK}\)</span> が外延的である場合は <span class="math inline">\(\text{UNICORN}\)</span> の存在が解釈に影響すべきで、 「ジョンがあるユニコーンを探す」は</p>
<p><span class="math display">\[\exists x. (\text{UNICORN}(x) \land \text{SEEK}(\text{John}, \uparrow \lambda X. \downarrow X(x))) \text{ ---------(*)}\]</span></p>
<p>と書きたい.</p>
<h4 id="意味公準">意味公準</h4>
<p>外延的な動詞 <span class="math inline">\(\delta\)</span> については、ある述語 <span class="math inline">\(S\)</span> が在って次が成立するとする.</p>
<p><span class="math display">\[\delta(x, X) (= \delta(X)(x)) \leftrightarrow \downarrow X(\uparrow \lambda y. \downarrow S(x, y))\]</span></p>
<p>先ほどの例を用いて、</p>
<p><span class="math display">\[\text{SEEK}(\text{John}, \uparrow \lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x)))\]</span></p>
<p>に <span class="math inline">\(\delta = \text{SEEK}\)</span> としてこの意味公準を適用してみる.</p>
<ul>
<li><span class="math inline">\(\text{SEEK}(\text{John}, \uparrow \lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x)))\)</span></li>
<li><span class="math inline">\(=\downarrow X(\uparrow \lambda y. \downarrow S(\text{John}, y))\)</span>
<ul>
<li>where <span class="math inline">\(X = \uparrow \lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x))\)</span></li>
</ul></li>
<li><span class="math inline">\(= \left( \lambda X. \exists x. (\text{UNICORN}(x) \land \downarrow X(x)) \right) (\uparrow \lambda y. \downarrow S(\text{John}, y))\)</span></li>
<li><span class="math inline">\(= \exists x. \left( \text{UNICORN}(x) \land \downarrow (\uparrow \lambda y. \downarrow S(\text{John}, y))(x) \right)\)</span></li>
<li><span class="math inline">\(= \exists x. \left( \text{UNICORN}(x) \land (\lambda y. \downarrow S(\text{John}, y))(x) \right)\)</span></li>
<li><span class="math inline">\(= \exists x. \left( \text{UNICORN}(x) \land (\downarrow S(\text{John}, x)) \right)\)</span></li>
</ul>
<p>となって、かなり <span class="math inline">\(\text{(*)}\)</span> に近いかたちが得られた. 完全に一致する形を得るために、意味公準の <span class="math inline">\(X\)</span> を <span class="math inline">\(\uparrow \lambda X. \downarrow X(y))\)</span> で置換してみると、</p>
<p><span class="math display">\[\delta(x, \uparrow \lambda X. \downarrow X(y)) = \downarrow S(x,y)\]</span></p>
<p>を得る (途中略).</p>
<p>すなわち、 <span class="math inline">\(\text{SEEK}(x, \uparrow \lambda X. \downarrow X(y)) = \downarrow S(x,y)\)</span> を代入することで、<span class="math inline">\(\text{(*)}\)</span> を得、この意味公準の下で2つは同値であることが確認できる.</p>
<p>先ほどの <span class="math display">\[\delta(x, \uparrow \lambda X. \downarrow X(y)) = \downarrow S(x,y)\]</span> を書き換えると <span class="math display">\[\lambda y. \lambda x. \delta(x, \uparrow \lambda X. \downarrow X(y)) = \downarrow S\]</span></p>
<p>を得る (引数の順序に註意 <span class="math inline">\((S(x,y)=S(y)(x))\)</span>). この右辺の <span class="math inline">\(S\)</span> は <span class="math inline">\(\delta\)</span> によって定まるが、左辺のことを <span class="math inline">\(\delta^*\)</span> と表記することにする.</p>
<p>とすると、先ほどの「ジョンがユニコーンを探す」は</p>
<p><span class="math display">\[\exists x. (\text{UNICORN}(x) \land \text{SEEK}^*(\text{John}, x))\]</span></p>
<p>と書いて馴染み深い述語論理の記述になる.</p>
<h2 id="モンタギュー意味論の問題点">モンタギュー意味論の問題点</h2>
<p>として2つ挙げる.</p>
<h3 id="文を超えた照応関係">文を超えた照応関係</h3>
<p>二文目の代名詞が一文目の個体を指す場合についてモンタギュー文法は何も触れていない.</p>
<p>&quot;A man walks. He whistles.&quot;</p>
<p>文の間を <span class="math inline">\(\land\)</span> でつなぐとしても、量化のスコープがやばい:</p>
<p><span class="math display">\[\exists x(\text{MAN}(x) \land \text{WALK}(x)) \land \text{WHISTLE}(x)\]</span></p>
<h3 id="ロバ文-donkey-sentence">ロバ文 (Donkey sentence)</h3>
<ul>
<li>&quot;If a farmer owns a donkey, he betas it&quot;</li>
<li>&quot;Every farmer who owns a donkey beats it&quot;</li>
</ul>
<p>という2つの例文を我々は同じ意味を以って読む. しかし、それぞれを構成的に翻訳すると、次のようになるだろう:</p>
<ul>
<li><span class="math inline">\(\exists x. (\text{FARMER}(x) \land \exists y. (\text{DONKEY}(y) \land \text{OWN}(x, y)) \rightarrow \text{BEAT}(x, y))\)</span></li>
<li><span class="math inline">\(\forall x. (\text{FARMER}(x) \land \exists y. (\text{DONKEY}(y) \land \text{OWN}(x, y)) \rightarrow \text{BEAT}(x, y))\)</span></li>
</ul>
<p>しかし本来読みたいのは次である.</p>
<ul>
<li><span class="math inline">\(\forall x. \forall y. (\text{FARMER}(x) \land \text{DONKEY}(y) \land \text{OWN}(x, y)) \rightarrow \text{BEAT}(x, y)\)</span></li>
</ul>
<h2 id="ダイナミック意味論">ダイナミック意味論</h2>
<p>ダイナミック意味論は先のモンタギュー意味論の問題点を解決する. そしてこれまでやってきたことは何だったのだと成る程、全く異なる.</p>
<p>ダイナミック意味論のための論理をダイナミック述語論理 (DPL) という. シンタックスは察して.</p>
<h3 id="概要">概要</h3>
<p>ダイナミック意味論では、読み手や聞き手の状態を考える. ここで状態とは変数への割当関数の集合とする.</p>
<p>これまでは文を 0/1 (真偽) に解釈してきたが、 ダイナミック意味論では、 文の解釈という行為を、状態の遷移させるものだとする.</p>
<p>割当関数全体の冪集合を <span class="math inline">\(G\)</span> とする. 文の解釈は <span class="math inline">\(G \times G\)</span> の部分集合とする.</p>
<p>例えばある文の解釈に <span class="math inline">\(\langle g, h \rangle\)</span> が含まれる時、解釈する前に状態 <span class="math inline">\(g\)</span> を保つ場合、解釈した後に状態 <span class="math inline">\(h\)</span> を持ち得るという意味である. わざわざ部分集合だと言っているのは関数ではない (遷移後の状態を一意に定めない) からである. (非決定的な遷移関数といえる).</p>
<h3 id="notation">notation</h3>
<p>2つの割当関数 <span class="math inline">\(h, g\)</span> において、変数 <span class="math inline">\(x\)</span> 以外で等しい (<span class="math inline">\(\forall y. y \ne x \rightarrow h(y) = g(h)\)</span>) ことを <span class="math inline">\(h[x]g\)</span> と書く.</p>
<h3 id="単純式の解釈">単純式の解釈</h3>
<p>単純式 <span class="math inline">\(R(t_1 \ldots t_n)\)</span> の普通の解釈としては、 それが成立する引数組の集合</p>
<p><span class="math display">\[I(R) = \{ \langle t_1 \ldots t_n \rangle : R(t_1 \ldots t_n) \}\]</span></p>
<p>だけど、 ダイナミック意味論では、それが成立するような割当関数のみ通す (フィルタする) ものとする. すなわち、</p>
<p><span class="math display">\[[\![R(t_1 \ldots t_n)]\!] = \{ \langle g, g \rangle : \langle [\![ t_1 ]\!]_g \ldots [\![ t_n ]\!]_g \rangle \in I(R)\]</span></p>
<p>ここで <span class="math inline">\([\![ \_ ]\!]_g\)</span> は割当関数 <span class="math inline">\(g\)</span> の下での解釈.</p>
<h3 id="存在量化子の解釈">存在量化子の解釈</h3>
<p><span class="math inline">\(\exists x. \phi\)</span> の解釈を考える.</p>
<p>次のように状態の遷移を考える. 初め状態が <span class="math inline">\(g\)</span> だとし、 <span class="math inline">\(\exists x\)</span> の量化によって、実際に <span class="math inline">\(x\)</span> <strong>のみ</strong> に別な割当をした <span class="math inline">\(k\)</span> に移す. <span class="math inline">\(\phi\)</span> の解釈によって <span class="math inline">\(k \to h\)</span> と遷移するなら、 <span class="math inline">\(\exists x. \phi\)</span> によって確かに <span class="math inline">\(g \to h\)</span> と遷移できる. <span class="math inline">\(\exists\)</span> だから、中間の <span class="math inline">\(k\)</span> はそのようなものがただ一つでもあれば、全体として <span class="math inline">\(h\)</span> に遷移できる.</p>
<p>以上の考察から次のように定める.</p>
<p><span class="math display">\[[\![ \exists x. \phi ]\!] = \{
\langle g,h \rangle :
\exists k.
g[x]k \text{ and }
\langle k,h \rangle \in [\![ \phi ]\!]
\}\]</span></p>
<h4 id="単純式の量子化">単純式の量子化</h4>
<p>一階述語 <span class="math inline">\(P\)</span> と変数 <span class="math inline">\(x\)</span> からなる単純式 <span class="math inline">\(P(x)\)</span> の量子化 <span class="math inline">\(\exists x. P(x)\)</span> の解釈は以上を組み合わせると</p>
<ul>
<li><span class="math inline">\([\![ \exists x. P(x) ]\!] = \{ \langle g,h \rangle : \exists k. g[x]k \text{ and } k = h \text{ and } h(x) \in I(P) \}\)</span>
<ul>
<li><span class="math inline">\(= \{ \langle g,h \rangle : g[x]h \text{ and } h(x) \in I(P) \}\)</span></li>
</ul></li>
</ul>
<p>ここで <span class="math inline">\(I(P)\)</span> は <span class="math inline">\(I(P) = \{ x : P(x) \}\)</span> みたいな特徴関数.</p>
<h3 id="連言の解釈">連言の解釈</h3>
<p>2つの文の解釈は連言として解釈する. そのときに、スコープが越えていても成立するような解釈をダイナミック意味論では提供する.</p>
<p><span class="math display">\[[\![ \phi \land \psi ]\!] = \{ \langle g,h \rangle : \exists k.~
\langle g,k \rangle \in [\![\phi]\!] \text{ and }
\langle k,h \rangle \in [\![\psi]\!] \}\]</span></p>
<p>前から順に解釈するものとして、 <span class="math inline">\(\phi\)</span> を読んで <span class="math inline">\(k\)</span> に移って、その後に <span class="math inline">\(\psi\)</span> を読んで <span class="math inline">\(h\)</span> に移る. 遷移は非決定的なものなので、<span class="math inline">\(k\)</span> については <span class="math inline">\(\exists k\)</span> としてある.</p>
<h4 id="例">例</h4>
<p>スコープを超えてる例として <span class="math inline">\((\exists x. P(x)) \land Q(x)\)</span> を解釈してみる.</p>
<ul>
<li><span class="math inline">\([\![ (\exists x. P(x)) \land Q(x) ]\!]\)</span>
<ul>
<li><span class="math inline">\(= \{ \langle g,h \rangle : \exists k.~ \langle g,k \rangle \in [\![\exists x. P(x)]\!] \text{ and } \langle k,h \rangle \in [\![Q(x)]\!] \}\)</span></li>
<li><span class="math inline">\(= \{ \langle g,h \rangle : \exists k.~ (g[x]k \text{ and } k(x) \in I(P)) \text{ and } (h=k \text{ and } h(x) \in I(Q)) \}\)</span></li>
<li><span class="math inline">\(= \{ \langle g,h \rangle : g[x]h \text{ and } h(x) \in I(P) \text{ and } h(x) \in I(Q) \}\)</span></li>
</ul></li>
</ul>
<p>というわけで、モンタギュー意味論の問題点としてあげた一点目は解決された.</p>
<h3 id="否定文の解釈">否定文の解釈</h3>
<p>否定文は宣言であって全体としてダイナミックではない (解釈の前後で状態を変化させない). 単純式の解釈と同様にフィルタするだけである.</p>
<p><span class="math display">\[[\![\lnot \phi]\!] = \{ \langle g,g \rangle : \nexists k. \langle g, k \rangle \in [\![ \phi ]\!] \}\]</span></p>
<h3 id="全称量化子の解釈">全称量化子の解釈</h3>
<p>古典的に言えば <span class="math inline">\([\![\forall x. \phi]\!] = [\![\lnot \exists x. \lnot \phi]\!]\)</span> が成立すべきで、これを採用する.</p>
<ul>
<li><span class="math inline">\([\![\forall x. \phi]\!] = [\![\lnot \exists x. \lnot \phi]\!]\)</span>
<ul>
<li><span class="math inline">\(= \{ \langle g,g \rangle : \nexists h. \langle g,h \rangle \in [\![ \exists x. \lnot \phi ]\!] \}\)</span></li>
<li><span class="math inline">\(= \{ \langle g,g \rangle : \nexists h. \exists k. g[x]k \text{ and } \langle k,h \rangle \in [\![ \lnot \phi ]\!] \}\)</span></li>
<li><span class="math inline">\(= \{ \langle g,g \rangle : \nexists h. \exists k. g[x]k \text{ and } k=h \text{ and } \nexists m. \langle k,m \rangle \in [\![\phi]\!] \}\)</span></li>
<li><span class="math inline">\(= \{ \langle g,g \rangle : \nexists h. g[x]h \text{ and } \nexists m. \langle h,m \rangle \in [\![\phi]\!] \}\)</span></li>
<li><span class="math inline">\(= \{ \langle g,g \rangle : \forall h. g[x]h \Rightarrow \exists m. \langle h,m \rangle \in [\![\phi]\!] \}\)</span> (えいっ)</li>
</ul></li>
</ul>
<p>というわけで</p>
<p><span class="math display">\[[\![\forall x. \phi]\!] = \{ \langle g,g \rangle : \forall h. g[x]h \Rightarrow \exists m. \langle h,m \rangle \in [\![\phi]\!] \}\]</span></p>
<p>とする.</p>
<h3 id="選言の解釈">選言の解釈</h3>
<p><span class="math inline">\(\phi \lor \psi\)</span> の解釈を与える.</p>
<p>ド・モルガン的に <span class="math inline">\([\![\phi \lor \psi]\!] = [\![\lnot (\lnot \phi \lor \lnot \psi)]\!]\)</span> の成立を要請して、</p>
<p><span class="math display">\[[\![\phi \lor \psi]\!] = \{ \langle g,g \rangle : \exists k.~\left(
\langle h,k \rangle \in [\![ \phi ]\!] \text{ or }
\langle h,k \rangle \in [\![ \psi ]\!]
\right) \}\]</span></p>
<p>これは <span class="math inline">\(\psi\)</span> の解釈の中で <span class="math inline">\(\phi\)</span> を照応しないことになる.</p>
<h3 id="含意の解釈">含意の解釈</h3>
<p><span class="math inline">\(\phi \rightarrow \psi\)</span> の解釈を与える.</p>
<p>もう否定も選言もあるのでこれも作れて、</p>
<p><span class="math display">\[[\![\phi \rightarrow \psi]\!] =
\{
\langle g,g \rangle : \forall k.~\left(
\langle h,k \rangle \in [\![\phi]\!]
\Rightarrow
\langle k,j \rangle \in [\![\psi]\!]
\right)
\}\]</span></p>
<p>ロバ文はどのように解釈されるか. 一部省略して、「ロバを所有してる人が存在する、ならば、彼はロバを打つ」と読んで <span class="math inline">\((\exists x. P(x)) \rightarrow Q(x)\)</span> の解釈を考える.</p>
<ul>
<li><span class="math inline">\([\![\exists x. P(x) \rightarrow Q(x)]\!]\)</span>
<ul>
<li><span class="math inline">\(= \{ \langle g,g \rangle : \forall k.~\left( \langle h,k \rangle \in [\![\exists x.P(x)]\!] \Rightarrow \langle k,j \rangle \in [\![Q(x)]\!] \right) \}\)</span></li>
<li><span class="math inline">\(= \{ \langle g,g \rangle : \forall k.~\left( g[x]k \text{ and } k(x) \in I(P) \Rightarrow k(x) \in I(Q) \right) \}\)</span></li>
</ul></li>
</ul>
<p>というわけで二点目の問題点も解消された.</p>
<!--

  HTML として pandoc -B で include する.

  <H2> を列挙してそれらにリンクを貼った toc を id='toc' に埋め込む.
  markdown で書いてるだろうから例として次のような段落を書けばよい.

```
## INDEX
<div id=toc></div>
```

  used in
  - /memo/gnuplot
  - /memo/linux
  - /memo/imagemagick

-->
<script>
(function() {
  var sections = document.getElementsByTagName('h2');
  var i;
  var OL = document.createElement('ol');
  for (i=0; i < sections.length; ++i) {
    var LI = document.createElement('li');
    var A = document.createElement('a');
    A.innerHTML = sections[i].innerHTML;
    if (A.innerHTML.toUpperCase() == 'INDEX') continue;
    A.href = '#' + i;
    LI.appendChild(A);
    OL.appendChild(LI);

    var PREF = document.createElement('a');
    PREF.name = i;
    sections[i].appendChild(PREF);
  }

  var done = false;
  function work() {
    if (done) return;
    if ( document.getElementById('toc') === null) return; // no toc element
    document.getElementById('toc').appendChild(OL);
    done = true;
  };

  window.onload = work;
  setTimeout(work,800);
}());
</script>
</body>
</html>
