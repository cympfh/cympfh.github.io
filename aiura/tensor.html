<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>普遍性からのテンソル</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">普遍性からのテンソル</h1>
<p><p class=date style='text-align: right'>2019-05-16 (Thu.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#線形代数>線形代数</a> </div></p>
<h2>概要</h2>
<p>歴史的にはそもそもテンソルとはテンソル積で得られるベクトル空間の元として定義される. つまりテンソルの定義にはテンソル積の定義が先立つ.</p>
<h2>index</h2>
<p><div id=toc-level-2></div></p>
<h2>参考</h2>
<ol>
  <li>
    <a href="http://daisy.math.sci.ehime-u.ac.jp/users/tsuchiya/math/fem/exterior/section1.pdf">ベクトル空間のテンソル積とテンソル空間</a>
    <ul>
      <li>愛媛大学の講義資料? (たぶん)</li>
    </ul>
  </li>
</ol>
<h2>notation</h2>
<p>ベクトル空間 \(U,V,W\) について, \(U \to V\) と書いたら \(U\) から \(V\) への <strong>線形</strong> 写像のことを表すこととする. また更に, \(U \times V \to W\) と書いたら \(U\) と \(V\) との直積から \(W\) への <strong>双線形</strong> 写像のこととする.</p>
<p>2つの写像 \(\alpha, \beta\) について \(\alpha \beta\) のように単に並べて, 合成写像 \(\alpha \circ \beta\) を表す. また関数適用も \(f(x)\) の代わりに単に並べて \(fx\) と書く.</p>
<p>添字に関して, アインシュタインの縮約記法を採用する. 例えば \(a^i f(a_i)\) という式は \(\sum_i\) を省略しており, その \(i\) の範囲は文脈から自明なものとする.</p>
<h2>注意</h2>
<p>体を \(k\) で固定して考える. また登場するベクトル空間はすべて有限次元とする.</p>
<h2>普遍性によるテンソル積の定義</h2>
<p>ベクトル空間 \(V, W\) について次のようなベクトル空間 \(U_0\) が必ず存在して, それのことを \(V\) と \(W\) のテンソル積 \(V \otimes W\) と書く. \(U_0\) に要請する性質は次の通り.</p>
<ol>
  <li>\(\exists \kappa \colon V \times W \to U_0\)</li>
  <li>\(\forall U, \forall \phi \colon V \times W \to U, \exists! \overline{\phi}\colon U_0 \to U\) such that \(\phi = \overline{\phi} \kappa\)</li>
</ol>
<p>2つ目が1つ目の \((U_0, \kappa)\) に対する普遍性になっていることが分かる.</p>
<h3>補題</h3>
<p>先の条件は次の同値な条件に書き直せる</p>
<ol>
  <li>\(\kappa \colon V \times W \to U_0\) があって \(U_0\) は \(\kappa(V \times W)\) で生成される空間である</li>
  <li>
    \(\forall U, \forall \phi \colon V \times W \to U, \exists \overline{\phi}\colon U_0 \to U\) such that \(\phi = \overline{\phi} \kappa\)
    <ul>
      <li>\(\exists\) の \(!\) が取れた</li>
      <li>それ以外は同じ</li>
    </ul>
  </li>
</ol>
<p>同値なことの確認は難しくないので略.</p>
<p><details><summary>NOTE</summary> 特に言っておくと, \(U_0\) が \(\kappa(V \times W)\) から生成されるとは \(\kappa\) が epi であることを言っている. すなわち,</p>
\[\alpha \kappa = \beta \kappa \implies \alpha = \beta.\]
<p>ただし普通の写像での全射であるとまでは言ってないので注意. 生成するとは結局, \(U_0\) にある基底 \(\langle g_1,\ldots,\rangle\) があって, この各 \(g_i\) に写す方法がありさえすればよい. 任意の \(\gamma^i g_i\) に写せるとまでは言っていない (特に \(\kappa\) は双線形写像なので).</p>
<p>念のために生成することと epi であることが同値であることを見る.</p>
<p>\(V\) の基底を \(\langle e_i \rangle\) , \(W\) の基底を \(\langle f_j \rangle\) , \(U_0\) の基底を \(\langle g_k \rangle\) とする.</p>
<p>\(\kappa(V \times W)\) が \(U_0\) を生成することと, \(\alpha \kappa = \beta \kappa\) を仮定するときに \(\alpha=\beta\) を示す.</p>
<p>各基底 \(g_k\) について, ある \((v_k, w_k) \in V \times W\) があって, \(g_k = \kappa(v_k, w_k)\) である. \(U_0\) の任意の元 \(u = \gamma^k g_k\) について,</p>
\[\begin{align*}
\alpha u &amp; = \gamma^k \alpha g_k \\
         &amp; = \gamma^k \alpha \kappa(v_k, w_k) \\
         &amp; = \gamma^k \beta \kappa(v_k, w_k) \\
         &amp; = \beta u
\end{align*}\]
<p>であるので \(\alpha = \beta\) .</p>
<p>逆は対偶で示す. 生成しないことを仮定すると, ある基底 \(g_k\) を生成しないから, \(g_k\) の成分だけ射影する関数 \(\alpha\) とそれを2倍する関数 \(\beta=2\alpha\) を用意すれば, \(\alpha \kappa = \beta \kappa ~(=0)\) となるがもちろん \(\alpha \ne \beta\) である. </details></p>
<h2>テンソル積の存在</h2>
<p>テンソル積の定義を述べたが, そのような \(U = V \otimes W\) は必ず存在する. 例えば次である (もちろん線形同型を除けば唯一である).</p>
<p>\(V\) を \(m\) 次元 \(\langle e_i \rangle\) , \(W\) を \(n\) 次元 \(\langle f_j \rangle\) とするとき, \(U\) は \(mn\) 次元であって,</p>
\[U = \langle g_{ij} \mid 1 \leq i \leq n, 1 \leq j \leq m\rangle\]
\[\kappa \colon V \times W \to U\]
\[\kappa(e_i, f_j) = g_{ij}\]
<p>とする.</p>
<p>定義から明らかに \(\kappa(V \times W)\) は \(U\) を生成し, \(\kappa\) は epi である.</p>
<p>普遍性を確認する. つまり適当な \(U&#x27;\) と \(\phi \colon V \times W \to U&#x27;\) があるとする. このときに,</p>
\[\overline{\phi} \colon U \to U&#x27;\]
\[\overline{\phi} g_{ij} = \phi(e_i, f_j)\]
<p>で線形写像として定義する (基底の行き先だけを示したのであとはこれの線形結合で定義する).</p>
<p>任意の \((v, w) = (a^i e_i, b^j f_j) \in V \times W\) について,</p>
\[\begin{align*}
\overline{\phi} \kappa (v, w)
&amp; = a^i b^j \overline{\phi} \kappa(e_i, f_j) \\
&amp; = a^i b^j \overline{\phi} g_{ij} \\
&amp; = a^i b^j \phi(e_i, f_j) \\
&amp; = \phi(v, w) \\
\end{align*}\]
<p>したがって, \(\overline{\phi} \kappa = \phi\) .</p>
<p>\(\overline{\phi}\) が唯一であることは \(\kappa\) が epi であることから従う. つまり, 他に \(\psi\) があるなら \(\overline{\phi} \kappa = \psi \kappa\) であるので, \(\overline{\phi} = \psi\) が導かれる.</p>
<p>というわけで普遍性は確かに満たしており, これがテンソル積であることが確認できた. 特にこの \(\kappa\) のことを <strong>標準写像</strong> という.</p>
<h2>テンソル</h2>
<p>テンソル積の元のことを <strong>テンソル</strong> と呼ぶ.</p>
<p>\(V \otimes W\) 及びその写像 \(\kappa \colon V \times W \to V \otimes W\) について, \(\kappa(v, w)\) のことを \(v \otimes w\) と書く. \(\kappa\) が全射とは限らないという話から, 任意の \(V \otimes W\) のテンソルがこの \(v \otimes w\) という形式で書けるわけではない. (和でなら表現できる.)</p>
<p>テンソル積やテンソルは 2 つ以上でも再帰的に定義でき, また結合則が成り立つ（らしい）ので括弧を付けずに例えば \(U \otimes V \otimes W\) だとか \(u \otimes v \otimes w\) だとか書ける.</p>
<h2>定理</h2>
<p>体 \(k\) の上のベクトル空間 \(V\) に対して, 線形写像の集まり \(\{ f \mid f \colon V \to k \}\) のことを \(V\) の双対空間といい \(V^*\) と書くのであった.</p>
<p>ここでは便宜的に, 直積に対しては双線型写像の集まりということにして \((V \times W)^*\) という書き方も許してもらうことにする.</p>
<p>次の定理が成り立つ.</p>
\[V \otimes W \simeq (V^* \times W^*)^*\]
<h3>証明</h3>
<p>\((V^* \times W^*)^*\) もまた \(V\) と \(W\) のテンソル積であることを示す. テンソル積どうしは普遍性より同型であるから, それだけ示せばok.</p>
<p>いい感じの</p>
\[\xi \colon V \times W \to (V^* \times W^*)^*\]
<p>によって \(((V^* \times W^*)^*, \xi)\) がテンソル積になることを示す.</p>
<p>\((v, w) \in V \times W\) を</p>
\[h \colon V^* \times W^* \to k\]
\[h(f,g) = f(v) g(w)\]
<p>という \(h\) に対応付ける写像を \(\xi\) だとする.</p>
<p>ところで基底は双対基底にしておく. すなわち \(\langle h_{ij} \mid i, j \rangle\) が基底で,</p>
\[h_{ij}(f_{i&#x27;}, g_{j&#x27;}) = \begin{cases}
1 &amp; \text{ when } i=i&#x27; \text{ and } j=j&#x27; \\
0 &amp; \text{ otherwise }
\end{cases}\]
\[f_i(e_{i&#x27;}) = \begin{cases}
1 &amp; \text{ when } i=i&#x27; \\
0 &amp; \text{ otherwise }
\end{cases}\]
\[g_j(f_{j&#x27;}) = \begin{cases}
1 &amp; \text{ when } j=j&#x27; \\
0 &amp; \text{ otherwise }
\end{cases}\]
<p>こうすれば \(\xi(v_i, w_j) = h_{ij}\) .</p>
<p>任意の \(\phi \colon V \times W \to U\) に対して,</p>
\[\overline{\phi} h_{ij} = \phi(v_i, w_j)\]
<p>とする（くらいしか自然な写像はない）.</p>
<p>任意の \((v,w) \in V \times W\) について,</p>
\[\begin{align*}
\overline{\phi} \xi (a^i e_i, b^j f_j)
&amp; = a^i b^j \overline{\phi} h_{ij} \\
&amp; = a^i b^j \phi(v_i, w_j) \\
&amp; = \phi (a^i v_i, b^j w_j)
\end{align*}\]
<p>だから可換.</p>
<p>普遍性は略. 気が向いたら計算する.</p>
<p>というわけで, テンソルというとそれに対応する双線型写像があるから, 双線型写像のことをテンソルと同一視してよい.</p>
<p>ベクトル空間 \(V_1, \ldots, V_n\) があるときに, \(V_1 \otimes \cdots \otimes V_n\) のテンソルに一対一対応する多重線型写像</p>
\[V_1 \times \cdots V_n \to k\]
<p>がある.</p>
<p>対応は成分ごとに \(\kappa\) と \(\xi\) で写せばよい??（未確認）</p>
<p>\(\require{amscd}\)</p>
\[\begin{CD}
V \otimes W @&lt;\kappa&lt;&lt; V \times W @&gt;\xi&gt;&gt; (V^* \times W^*)^*
\end{CD}\]
<h2>おわり</h2>
<p>よくある解釈としては適切な基底と, 適切な積の構造を入れさえすれば, 結局多次元配列で表現される. 例えば \(m\) 次元ベクトル空間と \(n\) 次元ベクトル空間のテンソル積は, \(m \times n\) の二次元配列で表現できる. この意味で, テンソルを行列の拡張と思うことができる.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>