<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>随伴が導くモナド</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon" style="position:absolute; left:0.4em; top:0.4em; width:1.3em;border-radius:0.8em;"></i></a>
</header>
<header>
<h1 class="title">随伴が導くモナド</h1>
</header>
<p class="date" style="text-align: right">
2019-02-08 (Fri.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#圏論>圏論</a></p>
</div>
<p><span class="math inline">\(\def\A{\mathcal A} \def\B{\mathcal B} \def\Hom{\mathrm Hom} \def\Sets{\mathrm Sets} \def\Gr{\mathrm Gr}\)</span></p>
<h2 id="概要">概要</h2>
<p>随伴 <span class="math inline">\(F \dashv U\)</span> があるとき <span class="math inline">\(UF\)</span> はモナドになる.</p>
<p>このことを確認する前に随伴とモナドについて復習する.</p>
<h2 id="復習">復習</h2>
<h3 id="随伴">随伴</h3>
<p>2つの互いに逆方向の関手 <span class="math inline">\(F \colon \A \to \B\)</span> と <span class="math inline">\(U \colon \B \to \A\)</span> とがあって, 任意の <span class="math inline">\(X \in \A, Y \in \B\)</span> について, <span class="math display">\[\Hom_\B(FX, Y) \simeq \Hom_\A(X, UY)\]</span> という <strong>自然な</strong> 同型関係ががあるとき, <span class="math display">\[F \dashv U\]</span> であると書いて, <span class="math inline">\(F, U\)</span> が随伴であるという.</p>
<p>この同型の対応を <span class="math display">\[\Phi \colon \Hom_\B(FX, Y) \rightleftharpoons \Hom_\A(X, UY) \colon \Psi\]</span> と書くことにする.</p>
<p>ここでまず同型関係であるので, 左右の <span class="math inline">\(\Hom\)</span> に一対一対応があること. つまり <span class="math inline">\(\Phi\)</span> と <span class="math inline">\(\Psi\)</span> は互いに逆の関数になっている (Hom は集合とする).</p>
<p>しかもその対応が自然であることを要請する. 自然であるということの意味はここでは次の通り.</p>
<p>任意の <span class="math inline">\(g \colon X&#39; \to X, h \colon Y \to Y&#39;\)</span> について次が可換. <span class="math inline">\(\require{AMScd}\)</span> <span class="math display">\[\begin{CD}
\Hom_\B(FX, Y) @&gt;\Phi&gt;&gt; \Hom_\A(X, UY) \\
@Vh-FgVV @VUh-gVV \\
\Hom_\B(FX&#39;, Y&#39;) @&gt;\Phi&gt;&gt; \Hom_\A(X&#39;, UY&#39;) \\
\end{CD}\]</span> ここで縦の射は</p>
<ul>
<li><span class="math inline">\((h-Fg) : f \mapsto h \circ f \circ Fg\)</span></li>
<li><span class="math inline">\((Uh-g) : f \mapsto Uh \circ f \circ g\)</span></li>
</ul>
<p>という関数のこと. 左上から <span class="math inline">\(f : FX \to Y\)</span> という射を自由に取ってくれば, 次の等式が成り立つことが可換性である.</p>
<div class="thm">
<p>(<span class="math inline">\(\Phi\)</span> の自然性) <span class="math display">\[\Phi(h~f~Fg) = Uh~\Phi f~g\]</span></p>
</div>
<p>同様に <span class="math inline">\(\Psi\)</span> も自然である必要がある. (<a href="http://cympfh.cc/taglibro/2019/01/22.html">といっても, 一方が自然ならその逆も自然になる</a>.) 向きが逆なだけで全く同様に,</p>
<p><span class="math display">\[\begin{CD}
\Hom_\B(FX, Y) @&lt;\Psi&lt;&lt; \Hom_\A(X, UY) \\
@Vh-FgVV @VUh-gVV \\
\Hom_\B(FX&#39;, Y&#39;) @&lt;\Psi&lt;&lt; \Hom_\A(X&#39;, UY&#39;) \\
\end{CD}\]</span></p>
<div class="thm">
<p>(<span class="math inline">\(\Psi\)</span> の自然性) <span class="math display">\[\Psi(Uh~f~g) = h~\Psi f~Fg\]</span></p>
</div>
<p>2つの自然性の式はあとで使うので使いやすい形にだけしておいてメモしておく.</p>
<div class="thm">
<h4 id="memo-1">memo 1</h4>
<p><span class="math display">\[\Phi(h) = Uh~\Phi 1\]</span> <span class="math display">\[\Psi(Uh~f) = h~\Psi f\]</span></p>
<p>それぞれ適切に <span class="math inline">\(1\)</span> を代入すればこれが出てくる.</p>
</div>
<h3 id="モナド">モナド</h3>
<p>モナドと言ったが個人的には Kleisli Triple の形の方がわかりやすい (定義も書きやすい) のでこちらを使う. モナドとは同値な概念で変換も簡単なのでどっちでも良い.</p>
<p>ここでは次の <span class="math inline">\((T,\eta,-^\sharp)\)</span> を圏 <span class="math inline">\(\A\)</span> の Kleisli Triple と呼ぶ.</p>
<ul>
<li>関手 <span class="math inline">\(T : \A \to \A\)</span>
<ul>
<li>(実際には対象の対応付だけで十分)</li>
</ul></li>
<li>ポリモーフィズム <span class="math inline">\(\eta : 1 \to T\)</span>
<ul>
<li>ポリモーフィズムとは自然である必要はない自然変換</li>
<li>ここでは各対象 <span class="math inline">\(X \in \A\)</span> について <span class="math inline">\(\eta_X : X \to TX\)</span> なる射を与えるもの</li>
</ul></li>
<li><span class="math inline">\(-^\sharp \colon \Hom(A,TB) \to \Hom(TA, TB)\)</span>
<ul>
<li><span class="math inline">\(f \mapsto f^\sharp\)</span></li>
</ul></li>
</ul>
<p>であって次の3つが成立するもの.</p>
<ol type="1">
<li><span class="math inline">\(\eta_X^\sharp = 1_{TX}\)</span></li>
<li><span class="math inline">\(f = f^\sharp \eta_X\)</span> (<span class="math inline">\(f \colon X \to TY\)</span>)</li>
<li><span class="math inline">\((g^\sharp f)^\sharp = g^\sharp f^\sharp\)</span></li>
</ol>
<p>以上が Kleisli Triple である.</p>
<blockquote>
<p><span class="math inline">\(\eta\)</span> は適当に自然変換になって, <span class="math inline">\(\mu_X = 1_{TX}^\sharp\)</span> とすれば <span class="math inline">\((T,\eta,\mu)\)</span> がいわゆるモナドそのものになる.</p>
</blockquote>
<h2 id="随伴の合成はモナド">随伴の合成はモナド</h2>
<p>主張は以下の通りであった.</p>
<div class="thm">
<p>随伴 <span class="math inline">\(F \dashv U\)</span> について <span class="math inline">\(UF\)</span> はモナド.</p>
</div>
<p><span class="math inline">\(F \colon \A \to \B\)</span>, <span class="math inline">\(U \colon \B \to \A\)</span> とすると <span class="math display">\[UF \colon \A \to \A\]</span> であり, 随伴の対応関係を前に書いたように <span class="math inline">\(\Phi, \Psi\)</span> とすると, <span class="math display">\[\eta_X = \Phi(1_{FX})\]</span> <span class="math display">\[f^\sharp = U(\Psi f)\]</span> とすれば <span class="math inline">\((UF, \eta, -^\sharp)\)</span> が Kleisli Triple になることを示す.</p>
<blockquote>
<p>コツとしては <span class="math inline">\(1_X\)</span> が常に存在することと, あとは自然に型を合わせれば大抵出来上がる.</p>
</blockquote>
<h3 id="証明">証明</h3>
<p>Kleisli Triple に要請される3つの条件を満たすことを見ていけば良い.</p>
<blockquote>
<p>証明のコツ. 自然変換 (というかポリモーフィズム) の添字とか, 恒等射 <span class="math inline">\(1_X\)</span> の添字とかはもう合ってるものだと信じていちいち気にしない. 適用とか合成とかも全部ただの掛け算だと思って操作してくと気附いたら辻褄が合ってる.</p>
</blockquote>
<h4 id="eta_xsharp-1_tx">1. <span class="math inline">\(\eta_X^\sharp = 1_{TX}\)</span></h4>
<p><span class="math display">\[\begin{align*}
\eta_X^\sharp
&amp; = U(\Psi \eta_X) \\
&amp; = U(\Psi \Phi(1_{FX})) \\
&amp; = U1 \\
&amp; = 1_{UFX}
\end{align*}\]</span></p>
<p><span class="math inline">\(T=UF\)</span> なので確かに型もあってる. ただしこれ以降は <span class="math inline">\(1\)</span> の添字は省略してく.</p>
<h4 id="f-fsharp-eta_x">2. <span class="math inline">\(f = f^\sharp \eta_X\)</span></h4>
<p>右辺から始める.</p>
<p><span class="math display">\[\begin{align*}
f^\sharp \eta_X &amp; = U(\Psi f) \Phi(1) \\
\end{align*}\]</span></p>
<p>ここで &quot;memo 1&quot; を思い出すと, <span class="math display">\[\begin{align*}
U(\Psi f) \Phi(1)
&amp; = \Phi(\Psi(f)) \\
&amp; = f
\end{align*}\]</span></p>
<p>最後は <span class="math inline">\(\Phi\)</span> は <span class="math inline">\(\Psi\)</span> の逆関数であることを使った.</p>
<h4 id="gsharp-fsharp-gsharp-fsharp">3. <span class="math inline">\((g^\sharp f)^\sharp = g^\sharp f^\sharp\)</span></h4>
<p><span class="math display">\[\begin{align*}
(g^\sharp f)^\sharp
&amp; = U(\Psi(g^\sharp ~ f)) \\
&amp; = U(\Psi((U \Psi g) ~ f)) \\
\end{align*}\]</span></p>
<p>やはり &quot;memo 1&quot; を思い出すと, <span class="math inline">\(\Psi((U \Psi g) ~ f) = (\Psi g) (\Psi f)\)</span> なので, <span class="math display">\[\begin{align*}
(g^\sharp f)^\sharp
&amp; = U ( (\Psi g) (\Psi f) )
&amp; = U(\Psi g) ~ U(\Psi f)
&amp; = g^\sharp f^\sharp
\end{align*}\]</span></p>
<p>最後は <span class="math inline">\(U\)</span> が関手なので分配できることを使った. ところで <span class="math inline">\(\Phi\)</span> や <span class="math inline">\(\Psi\)</span> は別に関手ではないので分配できないことに註意.</p>
<p>以上から確かに <span class="math inline">\(UF\)</span> は適切な操作によって Kleisli Triple になる.</p>
<blockquote>
<p><span class="math inline">\(\mu_X = 1_{UFX}^\sharp = U(\Psi 1_{UFX})\)</span> によってモナドでもある.</p>
</blockquote>
<h2 id="例">例</h2>
<p>定番の例として自由関手と忘却関手. ここでは集合の圏 Sets と群からなる圏 Gr を考える.</p>
<p><span class="math display">\[F : \Sets \to \Gr\]</span></p>
<p>は与えられた集合の要素からなる自由群を構成する. 例えば <span class="math inline">\(F\{a,b\} = \langle a,b \rangle = (\{ \epsilon, a, b, ab, ba, a^2b, aba, \ldots \}, \times)\)</span>.</p>
<p><span class="math display">\[U : \Gr \to \Sets\]</span></p>
<p>は与えられた群の元の全てからなる集合を構成する (群の構造を忘れる). 例えば <span class="math inline">\(U \langle a,b \rangle = \{ \epsilon, a, b, ab, ba, a^2b, aba, \ldots \}\)</span>.</p>
<p>従って, 集合 <span class="math inline">\(X = \{a,b\}\)</span> について <span class="math display">\[UFX = \{ \epsilon, a, b, ab, ba, a^2b, aba, \ldots \}\]</span> これは, 要素が <span class="math inline">\(a,b\)</span> からなる文字列のこと. あるいはリストのこと.</p>
<p>以上.</p>
<hr />
<p>他の例を知りたい. 逆に任意のモナドは自明でない随伴に分解出来る?</p>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
