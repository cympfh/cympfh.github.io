<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Mon Sep 14 02:29:58 JST 2015</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../../../resources/css/c.css">
  <link rel="stylesheet" href="../../css/post.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<a href="../../">🔙 Back to Top</a>
<header>
<h1 class="title">Mon Sep 14 02:29:58 JST 2015</h1>
</header>
<h2 id="beamerスライドでプログレスバーを出す">beamerスライドでプログレスバーを出す</h2>
<p>スライドの一番下のところに、 今示してるページは全体の何割あたりのところであるかを、 棒で可視化するやつ</p>
<figure>
<img src="../../img/2015/0914-progressbar.jpg" />
</figure>
<p>プリアンブルに次を書いておく. もちろん、<code>usetheme</code> を呼んだ後でないと上書きされる.</p>
<div class="sourceCode"><pre class="sourceCode tex"><code class="sourceCode latex"><span class="co">%%% FOOTER</span>
<span class="fu">\makeatother</span>
<span class="fu">\setbeamertemplate</span>{footline}
{
  <span class="fu">\dimen</span>0=1.1<span class="fu">\paperwidth</span>
  <span class="fu">\multiply\dimen</span>0 by <span class="fu">\insertframenumber</span>
  <span class="fu">\divide\dimen</span>0 by <span class="fu">\inserttotalframenumber</span>
  <span class="fu">\edef</span>\progressbarwidth{\the\dimen0}
  <span class="fu">\leavevmode</span><span class="co">%</span>
  <span class="fu">\setbeamercolor</span>{progress outer}{fg=white, bg=white}
  <span class="fu">\setbeamercolor</span>{progress bar}{bg=pink!90!white}
  <span class="kw">\begin</span>{<span class="ex">beamercolorbox</span>}[wd=1.1<span class="fu">\paperwidth</span>,ht=0.25ex,dp=1ex]{progress outer}
    <span class="kw">\begin</span>{<span class="ex">beamercolorbox</span>}[wd=<span class="fu">\progressbarwidth</span>,ht=0.25ex,dp=1ex]{progress bar}
    <span class="kw">\end</span>{<span class="ex">beamercolorbox</span>}<span class="co">%</span>
  <span class="kw">\end</span>{<span class="ex">beamercolorbox</span>}<span class="co">%</span>
}
<span class="fu">\makeatletter</span></code></pre></div>
<p>本来、1.1という数字は要らないのだけど、なんか左右に余白が勝手にできるので (どっかでいじった？).</p>
<p>ついでながら、 ページ番号は、ナビゲーションの代わりに挿入させてる.</p>
<div class="sourceCode"><pre class="sourceCode tex"><code class="sourceCode latex"><span class="fu">\setbeamertemplate</span>{navigation symbols}{
  <span class="fu">\setbeamercolor</span>{footline}{fg=pink!90!white}
  <span class="fu">\usebeamerfont</span>{footline}<span class="co">%</span>
  <span class="fu">\usebeamercolor</span>[fg]{footline}<span class="co">%</span>
  <span class="fu">\hspace</span>{1em}
  <span class="fu">\fontsize</span>{2.8em}{2.8em}<span class="fu">\selectfont</span>
  <span class="fu">\rotatebox</span>{90}{<span class="fu">\insertframenumber</span>}</code></pre></div>
<p>オシャレのつもりで90度回転させてるけど、どうだろう...</p>
<h1 id="mon-sep-14-212125-jst-2015">Mon Sep 14 21:21:25 JST 2015</h1>
<h2 id="scala-の-list.diff-が遅い">Scala の List.diff が遅い</h2>
<p>といっても、クイックソートと基数ソートを比べるようなものだけど...</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> scala.<span class="fu">math</span>.<span class="fu">_</span>
<span class="kw">import</span> scala.<span class="fu">collection</span>.<span class="fu">mutable</span>.{Queue, Set}
<span class="kw">import</span> scala.<span class="fu">collection</span>.<span class="fu">immutable</span>.<span class="fu">_</span>
 
<span class="kw">object</span> Main {

  <span class="co">// 時間計測</span>
  <span class="kw">def</span> <span class="fu">thetime</span>(proc: () =&gt; Unit): Unit = {
    <span class="kw">val</span> start = System.<span class="fu">currentTimeMillis</span>
    <span class="fu">proc</span>()
    <span class="fu">println</span>((System.<span class="fu">currentTimeMillis</span> - start) + <span class="st">&quot;msec&quot;</span>)
  }

  <span class="co">// 関数型っぽい普通の差分</span>
  <span class="co">// ただしソート済みであることを前提とする</span>
  <span class="kw">def</span> <span class="fu">difference</span>(xs: List[Int], ys: List[Int]): List[Int] = {
    <span class="kw">def</span> <span class="fu">sub</span>(ac: List[Int], xs: List[Int], ys: List[Int]): List[Int] = {
      <span class="kw">if</span> (xs.<span class="fu">length</span> == <span class="dv">0</span>) ac.<span class="fu">reverse</span>
      <span class="kw">else</span> <span class="kw">if</span> (ys.<span class="fu">length</span> == <span class="dv">0</span>) ac.<span class="fu">reverse</span> ++ xs
      <span class="kw">else</span> <span class="kw">if</span> (xs.<span class="fu">head</span> == ys.<span class="fu">head</span>) <span class="fu">sub</span>(ac, xs.<span class="fu">tail</span>, ys.<span class="fu">tail</span>)
      <span class="kw">else</span> <span class="kw">if</span> (xs.<span class="fu">head</span> &gt; ys.<span class="fu">head</span>) <span class="fu">sub</span>(ac, xs, ys.<span class="fu">tail</span>)
      <span class="kw">else</span> <span class="fu">sub</span>(xs.<span class="fu">head</span> :: ac, xs.<span class="fu">tail</span>, ys)
    }
    <span class="fu">sub</span>(List(), xs, ys)
  }

  <span class="co">// 一回配列 [Bool] にしてから差分を出す</span>
  <span class="co">// ただし、リストの要素が [0 ... n] であることを前提とする</span>
  <span class="co">// (基数ソートっぽい)</span>
  <span class="kw">def</span> <span class="fu">viaArray</span>(n: Int, xs: List[Int], ys: List[Int]): List[Int] = {
    <span class="kw">val</span> a = Array.<span class="fu">fill</span>(n)(<span class="kw">false</span>)
    <span class="kw">val</span> b = Array.<span class="fu">fill</span>(n)(<span class="kw">false</span>)
    <span class="kw">for</span> (x &lt;- xs) <span class="fu">a</span>(x) = <span class="kw">true</span>
    <span class="kw">for</span> (y &lt;- ys) <span class="fu">b</span>(y) = <span class="kw">true</span>
    <span class="kw">var</span> ret = List[Int]()
    <span class="kw">for</span> (i &lt;- <span class="dv">0</span> until n) <span class="kw">if</span> ((!<span class="fu">a</span>(i)) &amp;&amp; <span class="fu">b</span>(i)) ret = i :: ret
    ret
  }

  <span class="kw">def</span> <span class="fu">main</span>(args: Array[String]) {
    <span class="kw">val</span> cin = <span class="kw">new</span> java.<span class="fu">util</span>.<span class="fu">Scanner</span>(System.<span class="fu">in</span>)

    <span class="kw">val</span> a: List[Int] = <span class="fu">Range</span>(<span class="dv">0</span>, <span class="dv">100000</span>) toList
    <span class="kw">val</span> b: List[Int] = <span class="fu">Range</span>(<span class="dv">100</span>, <span class="dv">10000</span>) toList
    <span class="kw">val</span> c: List[Int] = <span class="fu">Range</span>(<span class="dv">10</span>, <span class="dv">1000</span>) toList
    <span class="kw">def</span> <span class="fu">a1</span>(): Unit = <span class="fu">println</span>((a diff b).<span class="fu">length</span>) <span class="co">// 10^5 * 10^4</span>
    <span class="kw">def</span> <span class="fu">a2</span>(): Unit = <span class="fu">println</span>((b diff c).<span class="fu">length</span>) <span class="co">// 10^4 * 10^3</span>
    <span class="kw">def</span> <span class="fu">b1</span>(): Unit = <span class="fu">println</span>(<span class="fu">difference</span>(a, b).<span class="fu">length</span>)
    <span class="kw">def</span> <span class="fu">b2</span>(): Unit = <span class="fu">println</span>(<span class="fu">difference</span>(b, c).<span class="fu">length</span>)
    <span class="kw">def</span> <span class="fu">c1</span>(): Unit = <span class="fu">println</span>(<span class="fu">viaArray</span>(<span class="dv">100001</span>, a, b).<span class="fu">length</span>)
    <span class="kw">def</span> <span class="fu">c2</span>(): Unit = <span class="fu">println</span>(<span class="fu">viaArray</span>(<span class="dv">100001</span>, b, c).<span class="fu">length</span>)
    <span class="fu">thetime</span>(a1)
    <span class="fu">thetime</span>(a2)
    <span class="fu">thetime</span>(b1)
    <span class="fu">thetime</span>(b2)
    <span class="fu">thetime</span>(c1)
    <span class="fu">thetime</span>(c2)
  }
}</code></pre></div>
<p>結果が以下のよう</p>
<pre><code># List.diff (組み込み)
90100
96msec
9000
3msec
# 自前 difference
90100
2956msec
9000
25msec
# 自前 differenceViaArray
90100
43msec
9000
2msec</code></pre>
<p>組み込み <code>diff</code> のソースコードがどこにあるのかわからないので読んでないのだが、 <code>differenceViaArray</code> に較べて 二倍程度 遅い. <code>a-b</code> と <code>b-c</code> を比べると、 <span class="math inline">\(O(n^2)\)</span> というわけでもないようだけれど.</p>
<p><code>thetime(() =&gt; println(0))</code> って書きたいんだけど、型エラーでコンパイルできない. なんだろう.</p>
<h1 id="mon-sep-14-022958-jst-2015">Mon Sep 14 02:29:58 JST 2015</h1>
<h2 id="簡易的な画像の自動分類を試す">簡易的な、画像の自動分類を試す</h2>
<p>画像識別といえばNNsだけど、 SIFTに代表されるような旧き良き画像特徴量を用いた 分類を行う.</p>
<h2 id="事前処理">事前処理</h2>
<p>扱いやすさのために次の情報をわざと失う</p>
<ul>
<li>色</li>
<li>比</li>
</ul>
<p>具体的には、 モノクロにし、比率を無視した200x200の大きさにリサイズして 出来た画像を、直接扱うことにする. また、輪郭だけを取り出したほうが良い特徴量が得られる気がするので、そのようにする.</p>
<blockquote>
<p>改良としては、色の情報を用いること. 画像にはカラー画像とモノクロ画像とがあるので、 まずどちらであるかを分類して、 それぞれで学習した異なる分類器を作るのが良いだろう. また、何で分類するかであるが、 例えば画像に写った顔で分類するなら、 顔を検出してそこだけ取り出すとかは、 普通すべきことだろう. 今回はそこまでするつもりはない.</p>
</blockquote>
<p>モノクロやリサイズはツールで簡単に出来るにしても、 輪郭を取り出すのはそんな簡単にできるだろうか、 とググったらすぐに見つかった. 今回は <a href="http://www.johf.com/log/20130304b.html">ImageMagick で写真の輪郭を取り出す - Oi!</a> を参考にする. そこに載ってるコマンドに <code>-reize</code> と <code>-monochrome</code> だけ追加して</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="ex">convert</span> -resize 200x200! -segment 1x1 +dither -colors 2 -edge 1 -negate -monochrome in.jpg out.jpg</code></pre></div>
<p>となる.</p>
<p>さらに、<code>jpg</code> のようなバイナリだとそのままでは読めないので、 テキストとして読める <code>ppm</code> にすることにする.</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash"><span class="ex">convert</span> -resize 200x200! -segment 1x1 +dither -colors 2 -edge 1 -negate -monochrome -compress none in.jpg out.ppm</code></pre></div>
<p><img src="../../img/2015/0914-in.jpg" alt="in.jpg" /> <img src="../../img/2015/0914-out.jpg" alt="out.jpg" /></p>
<p>これで、画像はグレイスケールの行列 <span class="math inline">\(E\)</span> として表現される</p>
<p><span class="math display">\[0 \leq E_{i,j} \leq 255 (0 \leq i, j &lt; 400)\]</span></p>
<h2 id="画像特徴量">画像特徴量</h2>
<p>画像をさらに、画像に適した特徴量 (アフィン変換に不偏であるとか云々) に変換することが必要. ざっくりとどういうのがあるのかは <a href="http://www.slideshare.net/lawmn/siftsurf">画像認識の初歩、SIFT,SURF特徴量</a> を読むと良い.</p>
<p>最悪自分で実装しようと思ったが、 <a href="http://robwhess.github.io/opensift/">OpenSIFT: An Open-Source SIFT Library</a> てのがあったのでこれを用いる. ソースがurl先で配布されてるので自分でビルドして使う.</p>
<pre><code>./robwhess-opensift-6233815/bin/siftfeat -o hoge sample/out.ppm</code></pre>
<pre><code>Finding SIFT features...
Found 17 features.</code></pre>
<p><code>hoge</code> というテキストファイルが生成されて、 あとついでに、得られた特徴量を可視化したのであろう画像<br />
<img src="../../img/2015/0914-sift.jpg" /> が表示される (というか、たったの17個かぁ).</p>
<p>この <code>hoge</code> を元に、学習・分類すればよいわけである. どう使おう.</p>
<h3 id="hoge-ファイルの読み方"><code>hoge</code> ファイルの読み方</h3>
<p>頭のほうだけ見てみると</p>
<pre><code>17 128
46.330449 144.342443 9.258731 2.132983
 13 26 13 87 107 1 0 0 59 62 9 12 100 34 0 0 114 113 12 2
 63 34 2 4 23 45 22 9 35 83 7 7 32 12 2 23 117 87 11 5
 117 42 1 3 54 71 16 20 25 87 21 3 59 117 60 24 23 70 36 9
 6 7 49 90 3 0 0 0 40 117 40 5 83 27 8 2 25 87 42 29
 36 20 13 5 9 66 46 67 9 0 0 0 0 3 44 114 0 0 0 0
 12 25 1 0 3 6 2 0 35 74 33 17 28 6 3 0 0 4 22 96
 6 0 0 0 0 0 0 17
46.330449 144.342443 9.258731 -0.172558
 0 36 45 6 3 1 1 0 1 35 95 8 0 0 0 0 1 10 92 24
 :
 :</code></pre>
<p>つまりこういうことだろう. 一つの特徴量が <span class="math inline">\(N\)</span> 次元の特徴量が <span class="math inline">\(M\)</span> 個あるとき、 一行目は</p>
<pre><code>M N</code></pre>
<p>二行目以降、<span class="math inline">\(M\)</span> 個、データセットが複数行に渡って与えられる. 一つのデータセットはこう</p>
<pre><code>x y z w
 a1 a2 .. aN</code></pre>
<p><span class="math inline">\(x,y,z,w\)</span> が何を意味するのかよくわからない. 特徴量が見つかった点の座標と長さと、もうひとつは、角度？かな？</p>
<p><span class="math inline">\(a_1 ... a_N\)</span> が実際の、特徴量. 長さの情報はこちらに含まれるのでゎ？ まぁ、いいや、実際に使うのはこっちだけにしよう.</p>
<h2 id="学習データの整形">学習データの整形</h2>
<p>一つの画像から、<span class="math inline">\(M\)</span> 個の特徴量が見つかって、 全部合わせると <span class="math inline">\(NM\)</span> 次元の特徴量が見つかる. <span class="math inline">\(N\)</span> は <span class="math inline">\(128\)</span> で固定だけど、<span class="math inline">\(M\)</span> は画像によって異なる.</p>
<p>画像ごとに次元が違うのは困るので、 どうするのかというと、 確か、 大きいのから<span class="math inline">\(m\)</span>個拾ってくるということをすることで、 次元を揃える. 「大きい」ってどうやって見るんだろう. <code>hoge</code> を見ると、 データセットは <span class="math inline">\(x,y,z,w\)</span> の順に並んでるというわけでも ないようなので、「大きい」順に出力されてるのかもしれない. いやそうに違いない. <span class="math inline">\(m\)</span> 個に足りない場合は、ゼロで埋める.</p>
<p><code>hoge</code> を簡単に、学習用のデータにしよう. そもそも何の学習器を用いるか考えてないけど、 どうせ学習データのフォーマットはみんな決まってる.</p>
<p>bashスクリプトで書いてみる.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">m=</span>10 <span class="co"># 例えばね</span>
<span class="fu">cat</span> hoge <span class="kw">|</span>
<span class="fu">grep</span> <span class="st">&#39;^ &#39;</span> <span class="kw">|</span> <span class="co"># 使いたい特徴量はみんな空白で始まる行に書かれる</span>
<span class="fu">grep</span> -o <span class="st">&#39;[0-9]*&#39;</span> <span class="kw">|</span> <span class="co"># 数字単位で改行</span>
<span class="fu">head</span> -n <span class="va">$((</span> <span class="va">$m</span> * 128 <span class="va">))</span> <span class="kw">|</span> <span class="co"># 使うのは最初の m*128 個</span>
<span class="fu">awk</span> <span class="st">&#39;{print $1 + 1}&#39;</span> <span class="kw">|</span> <span class="co"># 0-origin が出力されるので 1-originにする</span>
<span class="fu">sort</span> -n <span class="kw">|</span> <span class="fu">uniq</span> -c <span class="kw">|</span> <span class="co"># 数える</span>
<span class="fu">sed</span> <span class="st">&#39;s/^ *\([0-9]*\) \([0-9]*\)/\2:\1/&#39;</span> <span class="kw">|</span> <span class="co"># &lt;1-origin id&gt;:&lt;個数&gt; のフォーマットにする</span>
<span class="fu">tr</span> <span class="st">&#39;\n\&#39;</span> <span class="st">&#39; &#39;</span> <span class="co"># 改行を空白に置換</span></code></pre></div>
<p>邪魔なコメントと改行を取り除くと下のようになる</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="va">m=</span>10;
<span class="fu">cat</span> hoge <span class="kw">|</span> <span class="fu">grep</span> <span class="st">&#39;^ &#39;</span> <span class="kw">|</span> <span class="fu">grep</span> -o <span class="st">&#39;[0-9]*&#39;</span> <span class="kw">|</span> <span class="fu">head</span> -n <span class="va">$((</span> <span class="va">$m</span> * 128 <span class="va">))</span> <span class="kw">|</span> <span class="fu">awk</span> <span class="st">&#39;{print $1 + 1}&#39;</span> <span class="kw">|</span> <span class="fu">sort</span> -n <span class="kw">|</span> <span class="fu">uniq</span> -c <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/^ *\([0-9]*\) \([0-9]*\)/\2:\1/&#39;</span> <span class="kw">|</span> <span class="fu">tr</span> <span class="st">&#39;\n\&#39;</span> <span class="st">&#39; &#39;</span></code></pre></div>
<h2 id="学習">学習</h2>
<p>画像処理の分野での主流が分からないけど、 まあ、分類といえばSVMでしょ.</p>
<ul>
<li><a href="http://svmlight.joachims.org/">SVM-Light Support Vector Machine</a></li>
</ul>
<p>バイナリが配布されていてそのまま使える.</p>
<p>学習・テストデータは、 一行に一つのデータセットを書いたテキストファイル. 一つのデータセットは、</p>
<pre><code>&lt;target&gt;\t&lt;1-origin id&gt;:&lt;weight&gt;\t...&lt;1-origin id&gt;:&lt;weight&gt;</code></pre>
<p><code>&lt;target&gt;</code> はデータセットの分類結果. 学習の場合には、<code>1</code> または <code>-1</code> と書く. 結果がわからない場合には適当に書いておけばいい (<code>0</code> とか書いとけばいい?).</p>
<p><code>&lt;1-origin id&gt;:&lt;weight&gt;</code> は先ほど作ったものをそのまま用いればよい. 先ほどのでは <code>&lt;weight&gt;</code> として、そのIDの出現回数を用いた. 普通は正規化くらいするわな (<code>特徴量正規化</code>). 大抵の場合、正規化はするほうがよい.</p>
<p>改めて書くと、</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">(</span> <span class="bu">echo</span> -n <span class="st">&#39;1 &#39;</span><span class="kw">;</span> <span class="fu">cat</span> hoge <span class="kw">|</span> <span class="fu">grep</span> <span class="st">&#39;^ &#39;</span> <span class="kw">|</span> <span class="fu">grep</span> -o <span class="st">&#39;[0-9]*&#39;</span> <span class="kw">|</span> <span class="fu">head</span> -n <span class="va">$((</span> <span class="va">$m</span> * 128 <span class="va">))</span> <span class="kw">|</span> <span class="fu">awk</span> <span class="st">&#39;{print $1 + 1}&#39;</span> <span class="kw">|</span> <span class="fu">sort</span> -n <span class="kw">|</span> <span class="fu">uniq</span> -c <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/^ *\([0-9]*\) \([0-9]*\)/\2:\1/&#39;</span> <span class="kw">|</span> <span class="fu">tr</span> <span class="st">&#39;\n&#39;</span> <span class="st">&#39; &#39;</span> <span class="kw">;</span> <span class="bu">echo</span> <span class="kw">)</span> <span class="op">&gt;</span> <span class="ex">train</span>
<span class="ex">svm_learn</span> ./train</code></pre></div>
<p>って感じ (これは訓練事例1つだけで訓練したもの).</p>
<p>道具は揃ったので、あとはやってみるだけ. 画像は元々持ってるのを使う.</p>
<p>「ゆゆ式」の画像54枚をポジティブとする. (キャラクターじゃなくてアニメを直接ターゲットとするのは、 本当はどうかと思う) 思ったより手持ちが少なかった. ネガティブ（「ゆゆ式」ではない画像）はいくらでもあるのだけど、 ポジティブに対して極端にネガティブが多いと良くないので、 同じ54枚だけ使うことにする.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/bin/bash</span>

<span class="va">m=</span>70

<span class="bu">:</span> <span class="op">&gt;</span> ./train

<span class="va">target=</span>1
<span class="kw">for</span> <span class="ex">f</span> in <span class="kw">`</span><span class="fu">cat</span> posimgs<span class="kw">`;</span> <span class="kw">do</span>
  <span class="ex">convert</span> -resize 200x200! -segment 1x1 +dither -colors 2 -edge 1 -negate -monochrome -compress none <span class="va">$f</span> out.ppm
  <span class="ex">./robwhess-opensift-6233815/bin/siftfeat</span> -x -o sift.txt out.ppm
  <span class="kw">(</span>
  <span class="bu">echo</span> -n <span class="st">&quot;</span><span class="va">$target</span><span class="st"> &quot;</span><span class="kw">;</span>
  <span class="fu">cat</span> sift.txt <span class="kw">|</span> <span class="fu">grep</span> <span class="st">&#39;^ &#39;</span> <span class="kw">|</span> <span class="fu">grep</span> -o <span class="st">&#39;[0-9]*&#39;</span> <span class="kw">|</span> <span class="fu">head</span> -n <span class="va">$((</span> <span class="va">$m</span> * 128 <span class="va">))</span> <span class="kw">|</span> <span class="fu">awk</span> <span class="st">&#39;{print $1 + 1}&#39;</span> <span class="kw">|</span> <span class="fu">sort</span> -n <span class="kw">|</span> <span class="fu">uniq</span> -c <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/^ *\([0-9]*\) \([0-9]*\)/\2:\1/&#39;</span> <span class="kw">|</span> <span class="fu">tr</span> <span class="st">&#39;\n&#39;</span> <span class="st">&#39; &#39;</span> <span class="kw">;</span>
  <span class="bu">echo</span> <span class="kw">)</span> <span class="op">&gt;&gt;</span> <span class="ex">train</span>
<span class="kw">done</span>

<span class="va">target=</span>-1
<span class="kw">for</span> <span class="ex">f</span> in <span class="kw">`</span><span class="fu">cat</span> negimgs<span class="kw">`;</span> <span class="kw">do</span>
  <span class="ex">convert</span> -resize 200x200! -segment 1x1 +dither -colors 2 -edge 1 -negate -monochrome -compress none <span class="va">$f</span> out.ppm
  <span class="ex">./robwhess-opensift-6233815/bin/siftfeat</span> -x -o sift.txt out.ppm
  <span class="kw">(</span>
  <span class="bu">echo</span> -n <span class="st">&quot;</span><span class="va">$target</span><span class="st"> &quot;</span><span class="kw">;</span>
  <span class="fu">cat</span> sift.txt <span class="kw">|</span> <span class="fu">grep</span> <span class="st">&#39;^ &#39;</span> <span class="kw">|</span> <span class="fu">grep</span> -o <span class="st">&#39;[0-9]*&#39;</span> <span class="kw">|</span> <span class="fu">head</span> -n <span class="va">$((</span> <span class="va">$m</span> * 128 <span class="va">))</span> <span class="kw">|</span> <span class="fu">awk</span> <span class="st">&#39;{print $1 + 1}&#39;</span> <span class="kw">|</span> <span class="fu">sort</span> -n <span class="kw">|</span> <span class="fu">uniq</span> -c <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/^ *\([0-9]*\) \([0-9]*\)/\2:\1/&#39;</span> <span class="kw">|</span> <span class="fu">tr</span> <span class="st">&#39;\n&#39;</span> <span class="st">&#39; &#39;</span> <span class="kw">;</span>
  <span class="bu">echo</span> <span class="kw">)</span> <span class="op">&gt;&gt;</span> <span class="ex">train</span>
<span class="kw">done</span>

<span class="ex">svm_learn</span> ./train a.model</code></pre></div>
<pre><code>Runtime for XiAlpha-estimates in cpu-seconds: 0.00
XiAlpha-estimate of the error: error&lt;=93.58% (rho=1.00,depth=0)
XiAlpha-estimate of the recall: recall=&gt;7.27% (rho=1.00,depth=0)
XiAlpha-estimate of the precision: precision=&gt;7.27% (rho=1.00,depth=0)
Number of kernel evaluations: 3822</code></pre>
<p>全然ダメと読む.</p>
<p><code>convert</code> での事前処理を省いたり、 使う特徴量を増やしたりしたけど全然ダメだった</p>
</body>
</html>
