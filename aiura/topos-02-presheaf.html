<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>トポス - 前層の圏</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon" style="position:absolute; left:0.4em; top:0.4em; width:1.3em;border-radius:0.8em;"></i></a>
</header>
<header>
<h1 class="title">トポス - 前層の圏</h1>
</header>
<p class="date" style="text-align: right">
2019-10-19 (Sat.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#トポス>トポス</a> <a class='tag is-red' href=index.html#圏論>圏論</a></p>
</div>
<p><span class="math inline">\(\require{AMScd}\)</span> <span class="math display">\[\def\C{\mathcal C}\def\Sets{\mathrm{Sets}}\def\E{\mathcal E}\def\op{\mathrm{op}}\def\Y{\mathcal Y}\]</span></p>
<p><a href="topos-01.html">前回</a> はトポスの定義と, トポスの最も簡単な例として <span class="math inline">\(\Sets\)</span> があることを述べた. 今回は非自明だが典型的なトポスの例として前層を紹介する.</p>
<h2 id="前層の圏">前層の圏</h2>
<p><span class="math inline">\(\C\)</span> を任意の圏とする. 対象を <span class="math inline">\(\C\)</span> から <span class="math inline">\(\Sets\)</span> への反変関手であるような関手圏 <span class="math display">\[\E = \Sets^{\C^{\op}}\]</span> を <span class="math inline">\(\C\)</span> の上の <strong>前層</strong> （の圏）という.</p>
<h2 id="前層はトポス">前層はトポス</h2>
<p><span class="math inline">\(\C\)</span> がどんなものであっても, その上の前層はトポスである. トポスには３つの要件があった. 前層がその３つを満たすことを順に見ていく.</p>
<h3 id="終対象1-積-冪の存在">終対象（<span class="math inline">\(1\)</span>）, 積, 冪の存在</h3>
<p><span class="math inline">\(1\)</span> 及び積の存在は <span class="math inline">\(\Sets\)</span> のそれを使う.</p>
<h4 id="終対象">終対象</h4>
<p><span class="math inline">\(1 \in \E\)</span> は次で定まる. <span class="math display">\[1 \colon \C^{\op} \to \Sets\]</span> <span class="math display">\[1 \colon A \mapsto 1\]</span></p>
<p>これが確かに終対象であることを定義通り確かめる. すなわち, 任意の <span class="math inline">\(F \in \E\)</span> について, <span class="math inline">\(s \colon F \to 1\)</span> が唯一あることを見ればいい.</p>
<p>ここで <span class="math inline">\(F\)</span> は <span class="math inline">\(\E\)</span> の対象で <span class="math inline">\(s\)</span> は <span class="math inline">\(\E\)</span> の射であるが, <span class="math inline">\(\E\)</span> は関手圏であったので, <span class="math inline">\(F\)</span> は関手 <span class="math inline">\(\C^{\op} \to \Sets\)</span> で <span class="math inline">\(s\)</span> は自然変換 <span class="math inline">\(F \to 1\)</span> である. 自然変換であるとはすなわち, <span class="math inline">\(\C\)</span> における任意の射を <span class="math inline">\(F\)</span> および <span class="math inline">\(1\)</span> で写したものの間にいい感じの射を与えてくれること. そして自然変換 <span class="math inline">\(s \colon F \to 1\)</span> は対象 <span class="math inline">\(A\)</span> には <span class="math inline">\(s_A \colon FA \to 1A\)</span> (ここで <span class="math inline">\(1A=1\)</span>) を与えてくれるのだった.</p>
<p>これを図式で書くと次の通り.</p>
<p><span class="math display">\[\begin{CD}
A        @.   FA      @&gt;s_A&gt;&gt;  1A       \\
@VfVV         @AFfAA           @A1fAA   \\
B        @.   FB      @&gt;s_B&gt;&gt;  1B
\end{CD}\]</span></p>
<p>左の縦の <span class="math inline">\(f \colon A \to B\)</span> は <span class="math inline">\(\C\)</span> から任意に取ってきた射. これを <span class="math inline">\(F\)</span> と <span class="math inline">\(1\)</span> で <span class="math inline">\(\Sets\)</span> に写してる. 反変なので矢印の向きが逆になっている. 横向きに <span class="math inline">\(s_A, s_B\)</span> でこれをつないで四角形を作っているが, ここが可換であることが自然変換であることの要件. <span class="math inline">\(1A=1B=1\)</span>, <span class="math inline">\(1f=1\)</span> なので右の四角形だけ書き直すと,</p>
<p><span class="math display">\[\begin{CD}
FA      @&gt;s_A&gt;&gt;  1    \\
@AFfAA           @|   \\
FB      @&gt;s_B&gt;&gt;  1
\end{CD}\]</span></p>
<p>となる. さて <span class="math inline">\(s_A, s_B\)</span> は結局, 終対象への射なのでそれは終対象の要件から唯一であることが分かる. <span class="math display">\[s_A = !_A\]</span> そしてそのとき問題なく可換でもある.</p>
<p>というわけでこのような自然変換 <span class="math inline">\(s\)</span> は唯一存在する. 従って <span class="math inline">\(1 \in \E\)</span> は確かに終対象.</p>
<h4 id="積">積</h4>
<p>次に積. これも <span class="math inline">\(\Sets\)</span> の積をそのまま使う. <span class="math inline">\(F, G \in \E\)</span> について, <span class="math inline">\(F \times G\)</span> を次で定める. <span class="math display">\[F \times G \colon \C^{\op} \to \Sets\]</span> <span class="math display">\[(F \times G)(A) = FA \times GA\]</span></p>
<p>これが積であることは明らかだよね.</p>
<h4 id="冪">冪</h4>
<p>次に冪対象. これは <a href="Yoneda.html">米田の補題</a> 及びカリー化を使うと自然に出てくる. すなわち米田の補題によれば, 関手 <span class="math inline">\(F \colon \C^{\op} \to \Sets\)</span> は <span class="math display">\[\Sets^{\C^{\op}}(\C(-,A),F) \simeq FA\]</span> を満たす. ここで <span class="math inline">\(\C(-,A)\)</span> とは <span class="math inline">\(\C\)</span> の対象 <span class="math inline">\(B\)</span> を <span class="math inline">\(\C(B,A)\)</span> に写すような関手 <span class="math inline">\(\C^{\op} \to \Sets\)</span> である. 簡単に <span class="math inline">\(\Y^A\)</span> と書くことにする. そして <span class="math inline">\(\Sets^{\C^{\op}}(\Y^A, F)\)</span> とは <span class="math inline">\(\Y^A\)</span> から <span class="math inline">\(F\)</span> への自然変換全体からなる集合のことである.</p>
<p>先の <span class="math inline">\(F\)</span> に（あるかは分からないが）冪対象 <span class="math inline">\(F^G\)</span> を入れてみると, <span class="math display">\[\Sets^{\C^{\op}}(\Y^A, F^G) \simeq F^G(A)\]</span> が出てくる. この左辺にアンカリー化を施すと <span class="math display">\[\begin{align*}
F^G(A)
&amp; \simeq \Sets^{\C^{\op}}(\Y^A, F^G)  \\
&amp; \simeq \Sets^{\C^{\op}}(\Y^A \times G, F)
\end{align*}\]</span> が得られる. 最後のものは積しか使われていないし, 積はさっき定義したので確かに存在する. そこで <span class="math display">\[F^G \colon \C^{\op} \to \Sets\]</span> <span class="math display">\[F^G(A) := \Sets^{\C^{\op}}(\Y^A \times G, F)\]</span> と定義すればよい.</p>
<h3 id="始対象-余積">始対象, 余積</h3>
<p>結論だけ述べると</p>
<ul>
<li><span class="math inline">\(0(A) = 0\)</span>,</li>
<li><span class="math inline">\((F+G)(A) = FA + GA\)</span>.</li>
</ul>
<h3 id="subobject-classifier">subobject classifier</h3>
<h4 id="部分対象subobject-部分関手subfunctor">部分対象（subobject）, 部分関手（subfunctor）</h4>
<p>subobject classifier を定めるに先立って部分対象（subobject）を（今頃になってようやく！）定義しておく.</p>
<p>ある圏の対象 <span class="math inline">\(A,B\)</span> について <span class="math inline">\(A\)</span> が <span class="math inline">\(B\)</span> の <strong>部分対象</strong> であることを, mono 射 <span class="math inline">\(A \to B\)</span> が存在することと定義し <span class="math display">\[A \subset B\]</span> と書いて表す. これは特に Sets 圏においてはいわゆる「部分集合<span class="math inline">\((\subset)\)</span>」の一般化だと思える. 圏論で Sets を扱う場合, その要素までは見ないので, 例えば <span class="math inline">\(\{0\} \subset \{1,2\}\)</span> である. あくまで単射的な対応がつけばいい.</p>
<p>関手 <span class="math inline">\(F, G \colon \C \to \mathcal D\)</span> について <span class="math inline">\(F\)</span> が <span class="math inline">\(G\)</span> の <strong>部分関手</strong> であるとは, 任意の対象 <span class="math inline">\(X\)</span> について <span class="math display">\[FX \subset GX\]</span> であることで, このとき <span class="math display">\[F \subset G\]</span> だと書く.</p>
<h4 id="omega-in-e"><span class="math inline">\(\Omega \in \E\)</span></h4>
<p><span class="math display">\[\tilde{\Omega} \colon \C^{\op} \to \Sets\]</span> <span class="math display">\[\tilde{\Omega}(A) = \{ F \mid F \subset \C(-, A) \}\]</span></p>
<p>ここで <span class="math inline">\(\C(-,A)\)</span> はやはり米田の補題で出てきた関手で <span class="math inline">\(\Y^A\)</span> などとも書いたものである. <span class="math inline">\(\Y^A\)</span> の部分関手全体を <span class="math inline">\(\tilde{\Omega}\)</span> と定めた. さらにその中に順序を定める.</p>
<p><span class="math inline">\(F, G \subset \C(-, A)\)</span> について, <span class="math inline">\(\exists ! \colon G \to F\)</span> で</p>
<p><span class="math display">\[\begin{CD}
F      @&gt;mono&gt;&gt;  \Y^A    \\
@A!AA           @|   \\
G      @&gt;mono&gt;&gt;  \Y^A
\end{CD}\]</span></p>
<p>となるのを <span class="math inline">\(F \succeq G\)</span> だと定める. そして <span class="math inline">\(F \equiv G \iff F \succeq G \land G \succeq F\)</span> として <span class="math inline">\(\tilde{\Omega}\)</span> の上の同値を定めることで <span class="math display">\[\Omega(A) = \tilde{\Omega}(A) / \!\equiv\]</span> とする.</p>
<h4 id="true-morphism">true morphism</h4>
<p><span class="math display">\[t \colon 1 \to \Omega\]</span> <span class="math display">\[t_A \colon 1 \to \Omega(A)\]</span> <span class="math display">\[t_A(\ast) = \Y^A\]</span></p>
<p>で定める.</p>
<p>以上で定まった <span class="math inline">\((\Omega, t)\)</span> が <span class="math inline">\(\E\)</span> の subobject classifier である.</p>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
