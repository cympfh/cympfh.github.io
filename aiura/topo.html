<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>位相</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">位相</h1>
<p><p class=date style='text-align: right'>2017-03-11 (Sat.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#位相空間>位相空間</a> </div> % 位相をやります</p>
<h2>index</h2>
<p><div id=toc></div></p>
<h2>位相の定義</h2>
<p>位相空間 \(X\) とは、集合 \(X\) に <strong>位相 (開集合系)</strong> \(\mathcal O_X\) を与えたもののことである. ただし、位相 \(\mathcal O_X\) とは \(\mathcal O_X \subseteq P(X)\) (冪集合) であって、次の3つを要請するもの</p>
<ol>
  <li>\(\emptyset, X \in \mathcal O_X\)</li>
  <li><strong>有限</strong> の添字族 \(\Lambda\) について \(\forall \lambda \in \Lambda, U_\lambda \in \mathcal O_X \implies \bigcap_{\lambda \in \Lambda} U_\lambda \in \mathcal O_X\)</li>
  <li>(無限を許す) 添字族 \(\Lambda\) について \(\forall \lambda \in \Lambda, U_\lambda \in \mathcal O_X \implies \bigcup_{\lambda \in \Lambda} U_\lambda \in \mathcal O_X\)</li>
</ol>
<p>\(\mathcal O_X\) の元のことを \(X\) の開集合 (open set) と言う. また補集合が開集合であるもののことを閉集合 (closed set) と言う.</p>
<ul>
  <li>\(U \in O_X \iff U\) is open</li>
  <li>\(X \setminus U \in O_X \iff U\) is closed</li>
</ul>
<p>注意として、開集合でかつ閉集合であるということがある. その自明なものとして \(\emptyset, X\) .</p>
<h3>(註) 無限個の積について</h3>
<p>有限個の開集合の積は開集合とし、 無限 (以下) 個の開集合の和を開集合とする.</p>
<p>直感的に、開集合とは、実数空間で言うと (例えば) 開区間 \((a, b)\) のようなものである. \(U_n = (-1&#x2F;n, 1&#x2F;n)\) それぞれは開集合であるが、これの可算無限個の積</p>
\[\bigcap_{n=1}^\infty U_n = \{0\}\]
<p>を開集合として認めたくない.</p>
<h2>連続写像の定義</h2>
<p>集合 \(X, Y\) 間の写像</p>
\[f: X \to Y\]
<p>に対して、逆像</p>
\[f^{-1}(V) = \{ x \in X : f(x) \in V \}\]
<p>を定義する. これは点を点に写すような \(f^{-1}: Y \to X\) なる逆写像とは異なることに註意.</p>
<p>このような \(f^{-1}\) が、 \(Y\) における開集合を \(X\) における開集合に写すとき、 すなわち、</p>
\[\forall V \in \mathcal O_Y, f^{-1}(V) \in \mathcal O_X\]
<p>となるとき、 \(f\) を <strong>連続写像</strong> という.</p>
<h2>部分位相</h2>
<h3>補題</h3>
<p><div class="thm"> 集合 \(X\) に関して2つの位相 \(\mathcal O_X, \mathcal O_X&#x27;\) があるとき、この積 \(\mathcal O_X \cap \mathcal O_X&#x27;\) もまた位相である. </div></p>
<ol>
  <li>\((\emptyset, X \in \mathcal O_X) \land (\emptyset, X \in \mathcal O_X&#x27;)\) より \(\emptyset, X \in \mathcal O_X \cap \mathcal O_X&#x27;\)</li>
  <li>
    \(\forall i \in I, (U_i \in \mathcal O_X) \land (U_i \in \mathcal O_X&#x27;)\) のとき、
    <ul>
      <li>\(\bigcap_i U_i \in \mathcal O_X \land \bigcap_i U_i \in \mathcal O_X&#x27;\)</li>
      <li>したがって、 \(\bigcap_i U_i \in \mathcal O_X \cap \mathcal O_X&#x27;\)</li>
    </ul>
  </li>
  <li>\(\bigcup\) も同様</li>
</ol>
<h3>部分位相の定義</h3>
<p>位相空間 \(X\) とその部分集合 \(Y\) があるとき、 \(Y\) に <strong>自然に</strong> 位相を導入することができる. これを <strong>部分位相</strong> という. すなわち、</p>
\[\mathcal O_Y = \{ U \cap Y : U \in \mathcal O_X \}\]
<p>と定める. これが位相であることは確認できる.</p>
<h2>商位相</h2>
<p>位相空間 \(X\) と集合 \(Y\) との間に全射</p>
\[p : X \to Y\]
<p>があるとき、次のように \(Y\) に位相を導入することが出来る.</p>
\[\mathcal O_Y = \{ p(U) : U \in \mathcal O_X \}\]
<p>これが位相であることは確認でき、この位相のとき \(p\) は連続写像になる. この位相は、 \(p\) を連続たらしめる位相の中に (包含に関して) 最大の位相である (小さいほど連続になりやすいことに註意).</p>
<h2>コンパクト</h2>
<h3>被覆</h3>
<p>位相空間 \(X\) の被覆とは、 \(X\) の開集合の族 \(\{U_i\}_{i \in I}\) であって、</p>
\[\bigcup_i U_i = X\]
<p>なるもののこと.</p>
<h3>コンパクトの定義</h3>
<p>位相空間 \(X\) がコンパクトであるとは、 \(X\) の任意の被覆 \(\{U_i\}_{i \in I}\) について、有限個の \(\{U_i\}_{i \in J}\) を適切に選べば、これが尚も \(X\) の被覆と出来ること. すなわち、有限集合 \(J\) がって、</p>
\[\bigcup_{j \in J} U_j = X\]
<p>と出来ること.</p>
<h3>例</h3>
<ol>
  <li>\(\mathbb{R}\) はコンパクトではない</li>
  <li>
    \((0, 1) \subseteq \mathbb{R}\) はコンパクトではない
    <ul>
      <li>\(\mathbb{R}\) から部分位相を導入してることに註意</li>
    </ul>
  </li>
  <li>\([0, 1] \subseteq \mathbb{R}\) はコンパクトである</li>
  <li>\([0, 1] \cap \mathbb{Q} \subseteq \mathbb{R}\) はコンパクトでない</li>
</ol>
<h4>証明</h4>
<p>コンパクトでないことの証明は、実際に反例を一つ与えればよい. すなわち、その中の有限個では被覆できない点があるような被覆を与えれば良い.</p>
<ul>
  <li>
    \(\mathbb{R} = \bigcup_{i \in \mathbb{Z}} U_i\)
    <ul>
      <li>where \(U_i = (i-1&#x2F;2-\epsilon, i+1&#x2F;2+\epsilon)\)</li>
    </ul>
  </li>
  <li>
    \((0, 1) = \bigcup_{i \in \mathbb{N}} U_i\)
    <ul>
      <li>where \(U_i = (1&#x2F;n, 1)\)</li>
    </ul>
  </li>
  <li>
    \([0, 1] \cap \mathbb{Q} = \bigcup_{i \in \mathbb{N}} U_i\)
    <ul>
      <li>
        where
        <ul>
          <li>\(U_i = ([0, r - 1&#x2F;n) \cap (r + 1&#x2F;n, 1]) \cap \mathbb{Q}\)</li>
          <li>\(r\) は無理数で \(0 &lt; r &lt; 1\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>コンパクトであることの証明は辛い.</p>
<p>\([0,1]\) がコンパクトであることの証明を行う. \([0,1]\) の被覆 \(\{U_i\}_i\) が与えられたとする. \(0 \leq x \leq 1\) について、 命題「閉区間 \([0,x]\) が有限個で被覆できる」を \(P(x)\) とする. \(X = \{x : 0\leq x \leq 1, P(x) \}\) について、これは実数の部分集合であるので、 \(\sup X\) が存在する (これは有理数については言えない).</p>
<p>\(\sup X = r &lt; 1\) とする. \(r \in [0,1]\) を被覆する \(U_i\) が存在するので、 \(P(r + \epsilon)\) が成立し、 \(\sup X = r\) に矛盾する. 従って \(\sup X=1\) が言える.</p>
<h2>補題 0</h2>
<p><div class="thm"> \(X\) が開集合であることと、 \(\forall x \in X, \exists U \text{ is open }, x \in U \subseteq X\) とは同値. </div></p>
<p>\((\Rightarrow)\) の証明: 任意の点 \(x \in X\) について \(U=X\) とすれば、 \(x \in X \subseteq X\) が自明に成立する.</p>
<p>\((\Leftarrow)\) の証明: 点 \(x\) に対して \(x \in U \subseteq X\) なる \(U\) を \(U_x\) と名付けると、 開集合の公理から \(\bigcup_{x \in X} U_x\) は開集合であるが、これがちょうど \(X\) と一致する. 従って \(X\) は開集合である.</p>
<h2>補題 1</h2>
<p><div class="thm"> ハウスドルフ空間 \(X\) の部分集合 \(Z\) がコンパクトなとき、 \(Z\) は閉集合. </div></p>
<p>\(X \setminus Z\) が開集合であることを示す. 開集合であることを示すのに先の補題 0 を用いる. すなわち、 任意の点 \(x \in X \setminus Z\) に対して、</p>
\[\exists U \text{ is open }, x \in U \subseteq X \setminus Z\]
<p>を示せば良い.</p>
<p>\(X\) がハウスドルフ空間であることから、 点 \(x \in X\) と 点 \(z \in X \setminus Z\) に対して それらを分離するような</p>
<ul>
  <li>\(z \in U_z\)</li>
  <li>\(x \in V_z\)</li>
  <li>\(U_z \cap V_z = \emptyset\)</li>
</ul>
<p>がある. さて、 \(Z\) の全ての点 \(z\) に対して</p>
\[\{ U_z \cap Z \}_{z \in Z}\]
<p>は ( \(Z\) の部分位相に於いて) \(Z\) の被覆であるが、 \(Z\) のコンパクト性より、ある有限の点集合 \(Z&#x27;\) を以って</p>
\[\{ U_z \cap Z \}_{z \in Z&#x27;}\]
<p>が \(Z\) の被覆である. これに対応して</p>
\[V = \cap_{z \in Z&#x27;} V_z\]
<p>を作れて、これは \(Z\) と積を持たない. また、有限個の積であるから、 \(V\) は開集合.</p>
<p>したがって、任意の \(x \in X \setminus Z\) に対して、</p>
\[x \in V \subseteq X \setminus Z\]
<p>なる開集合 \(V\) が得られた.</p>
<p>従って、 \(X \setminus Z\) は開集合である.</p>
<h2>補題 2</h2>
<p><div class="thm"> コンパクト集合の部分閉集合はコンパクトである. </div></p>
<p>コンパクト集合 \(X\) についてその部分集合 \(Z \subseteq X\) には部分位相を入れていることに註意. \(Z\) に任意の被覆 \(\{U_i\}_i\) を与えた時、 ちょうど</p>
\[\{ U_i \}_i \cap \{ X \setminus Z \}\]
<p>は、 \(X\) の被覆になっている. ここで、 \(Z\) が閉集合 (補題 1) であるから、 \(X \setminus Z\) は開集合であることを用いてる. \(X\) のコンパクト性故、</p>
\[\exists J, \{ U_i \}_{i \in J} \cap \{ X \setminus Z \}\]
<p>によって、 \(X\) を被覆する. このときに</p>
\[\exists J, \{ U_i \}_{i \in J}\]
<p>によって \(Z\) が被覆できる. 従って、 \(Z\) はコンパクト.</p>
<h2>補題 3</h2>
<p><div class="thm"> コンパクト集合の連続写像による像はコンパクト. </div></p>
<p>2つの位相集合 \(X, Y\) の間に連続写像 \(f : X \to Y\) があるとき、 \(f(X)\) は \(Y\) の部分集合であるが、 部分位相を入れる時、 \(f(X)\) はコンパクト集合である.</p>
<p>証明は 補題 2 とほぼほぼ同様.</p>
<h2>定理</h2>
<p><div class="thm">コンパクト集合からハウスドルフ空間への全単射な連続写像は同相を与える</div></p>
<p>コンパクト集合 \(X\) からハウスドルフ空間 \(Y\) への写像</p>
\[f : X \to Y\]
<p>を考える. これが連続写像であることから、自然に</p>
\[f^{-1} : \mathcal O_Y \to \mathcal O_X\]
<p>が定まる. 同相であることを示すには逆写像も連続であることを示せばよい. そのためには、</p>
\[f : P(X) \to P(Y)\]
\[f(U) = \{ f(x) : x \in U \}\]
<p>これが開集合を保つ、つまり、</p>
\[f : \mathcal O_X \to \mathcal O_Y\]
\[\forall U \in \mathcal O_X, f(U) \in \mathcal O_Y\]
<p>と、開集合を開集合に写していればよい.</p>
<p>今の場合、 開集合を開集合に写すことは、閉集合を閉集合に写すことと等しい. なぜなら、 \(f\) は全単射なので.</p>
<ul>
  <li>
    閉集合 \(Z \subseteq X\) に対して、 \(f(Z)\) が閉集合であることを示す.
    <ol>
      <li>補題 2 より、 \(Z\) はコンパクトである.</li>
      <li>補題 3 より、 \(f(Z)\) はコンパクト</li>
      <li>補題 1 より、 \(f(Z) \subseteq Y\) は閉集合</li>
    </ol>
  </li>
</ul>
<p>以上より示された.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>