<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>メビウス関数の反転公式</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-svg-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title" id="1-メビウス関数の反転公式">メビウス関数の反転公式</h1>
<p><p class=date style='text-align: right'>2021-02-09 (Tue.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#組合せ数学>組合せ数学</a> </div></p>
<h2 id="2-INDEX">INDEX</h2>
<p><div id="toc"></div></p>
<h2 id="2-仮定する知識">仮定する知識</h2>
<p>半順序集合, 束</p>
<h2 id="2-局所有限な半順序集合">局所有限な半順序集合</h2>
<p>半順序集合 \((E, \preceq)\) について <strong>区間</strong> とは, \(x \preceq y\) に対して,</p>
\[[x,y] = \{ z \in E \mid x \preceq z \preceq y \}\]
<p>のこと.</p>
<p>すべての区間が有限集合であることを <strong>局所有限</strong> だという.</p>
<p>元の \(\preceq\) を使って \([x,y]\) は尚, 半順序集合であるし, しかも \(x,y\) をそれぞれ最小元と最大元とする束である. \(E\) が局所有限なら \([x,y]\) は有限の束である.</p>
<h2 id="2-メビウス関数">メビウス関数</h2>
<p>局所有限な半順序集合 \(E\) の上にメビウス関数</p>
\[\mu \colon E \times E \to \mathbb Z\]
<p>を定める. メビウス関数は次を満たすものとして定義される.</p>
<p>\(x \preceq y\) のとき,</p>
\[\sum_{z \in [x,y]} \mu(x, z) = \delta(x, y),\]
<p>\(x \not\preceq y\) のとき,</p>
\[\mu(x,y) = 0.\]
<p>ここで \(\delta\) はクロネッカーのデルタなどと呼ばれるものであって,</p>
\[\delta(x, y) = \begin{cases}
1 &amp; \text{ if } x = y\\
0 &amp; \text{ else }
\end{cases}\]
<p>という関数.</p>
<p>さて上に書いた \(\mu\) がメビウス関数だが, 陽な定義にはなっていなくて, 次のように書き直した方が帰納的定義として計算しやすい.</p>
\[\mu(x, y) = \begin{cases}
1 &amp; \text{ if } x = y \\
- \sum_{x \preceq z \prec y} \mu(x,z) &amp; \text{ if } x \preceq y \\
0 &amp; \text{ else } \\
\end{cases}\]
<h3 id="3-性質">性質</h3>
<p>\(x \preceq y\) のとき,</p>
\[\sum_{z \in [x,y]} \mu(z, y) = \delta(x, y)\]
<h4 id="4-証明">証明</h4>
<p>元の定義</p>
\[\sum_{z \in [x,y]} \mu(x, z) = \delta(x, y)\]
<p>を書き換えていくことで与えられた式の左辺を作ることを考える.</p>
\[
\begin{align*}
&amp; \sum_{z \in [x,y]} \mu(x, z) = \delta(x, y) &amp; \text{ 定義}\\
\iff &amp; \sum_{z \in [z&#x27;,y]} \mu(z&#x27;, z) = \delta(z&#x27;, y) &amp; \text{ 変数の置き換え} \\
\iff &amp; \sum_{x \preceq z&#x27; \preceq y} \sum_{z \in [z&#x27;,y]} \mu(z&#x27;, z) = \sum_{z&#x27;} \delta(z&#x27;, y) &amp; z&#x27; \text{を動かす} \\
\iff &amp; \sum_{x \preceq z&#x27; \preceq y} \sum_{z \in [z&#x27;,y]} \mu(z&#x27;, z) = 1 &amp; \text{ 右辺は簡単に計算できる} \\
\iff &amp; \sum_{x \preceq z \preceq y} \sum_{x \preceq z&#x27; \preceq z} \mu(z&#x27;, z) = 1 &amp; \text{ 気をつけて2つの Sum を交換する} \\
\iff &amp; \sum_{x \preceq z \preceq y} k(x,z) = 1 &amp; k(x,z) = \sum_{x \preceq z&#x27; \preceq z} \mu(z&#x27;, z) \text{と置いた} \\
\end{align*}
\]
<p>証明したいのはこの最後の \(k\) について \(k(x,z) = \delta(x,z)\) が成り立つということだった. \(x=z\) のときには明らか.</p>
\[\begin{align*}
&amp; \sum_{x \preceq z \preceq y} k(x,z) = 1 &amp; \text{ さっきの最後の式 } \\
\iff &amp; k(x,x) + \sum_{x \prec z \preceq y} k(x,z) = 1 \\
\iff &amp; 1 + \sum_{x \prec z \preceq y} k(x,z) = 1 \\
\iff &amp; \sum_{x \prec z \preceq y} k(x,z) = 0 \\
\end{align*}\]
<p>これが一般に成り立つので, \([x, y]\) に対して,</p>
\[\forall y&#x27; \in [x,y] ,~ y&#x27; \ne x \implies \sum_{z \in [x,y&#x27;]} k(x,z) = 0\]
<p>が言える.</p>
<p>この \([x,y]\) は有限の束なので \(y&#x27;\) を小さいものから順に舐めていくことで</p>
\[k(x,z) = 0\]
<p>が言える.</p>
<p>以上から \(k=\delta\) .</p>
<h2 id="2-リーマン関数（ゼータ関数）">リーマン関数（ゼータ関数）</h2>
<p>局所有限半順序集合 \(E\) に対して,</p>
\[
\zeta(x, y) = \begin{cases}
1 &amp; \text{ if } x \preceq y \\
0 &amp; \text{ else }
\end{cases}
\]
<h2 id="2-反転公式">反転公式</h2>
<p>メビウス関数とリーマン関数は次のような関係にある. 2つの関数 \(f,g \colon E \to \mathbb R\) について,</p>
\[\begin{align*}
&amp; g(x) = \sum_{y \in E} \zeta(y,x) f(y) \\
\iff &amp; f(x) = \sum_{y \in E} \mu(y,x) g(y) \\
\end{align*}\]
<h3 id="3-証明 ( \(\implies\) )">証明 ( \(\implies\) )</h3>
<p>\(g(x)=\) を仮定したときに2つ目にこれを代入することで等式を確認する.</p>
\[\begin{align*}
\sum_y \mu(y,x) g(y)
&amp; = \sum_y \mu(y,x) \sum_z \zeta(z, y) f(z) &amp; \text{ 仮定を代入した } \\
&amp; = \sum_{y \preceq x} \mu(y,x) \sum_{z \preceq y} f(z) &amp; \mu \text{ が値を持つ範囲に限定した }\\
&amp; = \sum_{z \preceq x} f(z) \sum_{y \in [z,x]} \mu(y, x) &amp; \text{ Sum を交換した }\\
&amp; = \sum_{z \preceq x} f(z) \delta(y, x) &amp; \text{ 上で述べた「性質」}\\
&amp; = f(x) \\
\end{align*}\]
<h3 id="3-証明 ( \(\impliedby\) )">証明 ( \(\impliedby\) )</h3>
<p>全く同様に代入して確かめる.</p>
\[\begin{align*}
\sum_y \zeta(y, x) f(y)
&amp; = \sum_y \zeta(y,x) \sum_z \mu(z, y) g(z) &amp; \text{ 仮定を代入した } \\
&amp; = \sum_{y \preceq x} \sum_{z \preceq y} \mu(z, y) g(z) &amp; \text{ それぞれ値が持つ範囲 }\\
&amp; = \sum_{z \preceq x} g(z) \sum_{y \in [z,x]} \mu(z, y) &amp; \text{ Sum の交換 }\\
&amp; = \sum_{z \preceq x} g(z) \delta(z, y) &amp; \mu \text{ の定義 }\\
&amp; = g(x) \\
\end{align*}\]
<h2 id="2-例. 整除関係のメビウス関数">例. 整除関係のメビウス関数</h2>
<p>\(1\) 以上の正整数 \(\mathbb Z_{+}\) の上に</p>
\[x \preceq y \iff x \text{ は } y \text{ を割り切る}\]
<p>という半順序を入れる事ができる.</p>
<p>整数論の文脈で単にメビウス関数と言った場合はこの半順序の上のメビウス関数のこと. ただし</p>
\[\mu(x) = \mu(1, x)\]
<p>と書く.</p>
<h3 id="3-性質">性質</h3>
<p>これまでに述べてきたことにそのまま適用することで次が言える.</p>
\[\sum_{d \preceq n} \mu(d, n) = \delta(1, n),\]
\[g(n) = \sum_{d \preceq n} f(d) \iff f(n) = \mu(d, n) g(d).\]
<p>さて \(d \preceq n\) のときに, \([d, n]\) は \([1, n&#x2F;d]\) と同型なので \(\mu(d,n) = \mu(1,n&#x2F;d)=\mu(n&#x2F;d)\) である. というわけで,</p>
\[\sum_{d \preceq n} \mu(n&#x2F;d) = \delta(1, n),\]
\[g(n) = \sum_{d \preceq n} f(d) \iff f(n) = \mu(n&#x2F;d) g(d)\]
<p>と言い直せる.</p>
<h3 id="3-定理">定理</h3>
<p>\(1\) 以上の自然数 \(n\) が相異なる \(p\) 個の素数の積で表される時</p>
\[\mu(n) = (-1)^p\]
<p>であって, さもなくば</p>
\[\mu(n) = 0.\]
<p>特に \(n=1\) は相異なるゼロ個の合成数だとみなす. 例えば</p>
<ul>
  <li>\(\mu(1)= 1\)</li>
  <li>\(\mu(2)= -1\)</li>
  <li>\(\mu(4)= 0\)</li>
  <li>\(\mu(5)= -1\)</li>
  <li>\(\mu(6)= 1\)</li>
</ul>
<p>これが成り立つことは次の直積を考えると楽なので後述する.</p>
<h2 id="2-直積">直積</h2>
<h2 id="2-直積順序">直積順序</h2>
<p>2つの半順序集合 \(E_1, E_2\) について,</p>
\[(x_1, y_1) \preceq (x_2, y_2) \iff x_1 \preceq x_2 \land y_1 \preceq y_2\]
<p>と定めることで, 直積</p>
\[E_1 \times E_2 := \{ (x, y) \mid x \in E_1, y \in E_2 \}\]
<p>が定義される.</p>
<h3 id="3-直積のメビウス関数">直積のメビウス関数</h3>
<p>\(E_1, E_2\) 及び \(E_1 \times E_2\) の上に定まるメビウス関数をそれぞれ \(\mu_1, \mu_2, \mu_{1,2}\) としておくと次が成り立つ.</p>
\[\mu_{1,2} = \mu_1 \times \mu_2,\]
<p>すなわち</p>
\[\mu_{1,2}((x_1, y_1), (x_2, y_2)) = \mu_1(x_1, x_2) \times \mu_2(y_1, y_2).\]
<h3 id="3-例. 有限集合の包含関係">例. 有限集合の包含関係</h3>
<p>有限集合 \(E\) の部分集合とその \(\subseteq\) は半順序の関係にあるのでメビウス関数を定める事ができる. この包含関係は各要素についてそれを含むかどうかという順序の直積になっている. 例えば \(e \in E\) について, \(e\) を含まないことを \(0\) , 含むことを \(1\) で表せば</p>
\[(\{0,1\}, 0 \preceq 1)\]
<p>という半順序で \(e\) に関する包含関係が表される. これを \(|E|\) 個だけ並べて直積を取ったのが \(\subseteq\) だと言える.</p>
<p>各要素 \(e \in E\) に関するメビウス関数は</p>
\[\mu(x, x) = 1,\]
\[\mu(0, 1) = -1,\]
\[\mu(1, 0) = 0.\]
<p>直積のメビウス関数はこれの積なので,</p>
\[\mu(X, Y) = \begin{cases}
(-1)^{|Y \setminus X|} &amp; \text{ if } A \subseteq B \\
0 &amp; \text{ else. }\\
\end{cases}\]
<h3 id="3-例. 整除関係">例. 整除関係</h3>
<p>正整数は素因数分解をすることで, 素数の多重集合だと思うことが出来る. 例えば,</p>
<ul>
  <li>\(1 = \{\}\)</li>
  <li>\(2 = \{ 2\}\)</li>
  <li>\(3 = \{ 3\}\)</li>
  <li>\(4 = \{ 2,2\}\)</li>
</ul>
<p>とすると, \(\mathbb Z_{+}\) 上の整除関係 \(\preceq\) は多重集合の包含関係とみなす事が出来る.</p>
<p>仮に一つの素数 \(p\) による合成数 \(1,p,p^2,\ldots\) の上の整除関係を考える場合, \(n=p^a\) が \(m=p^b\) を割り切るとは,</p>
\[n \preceq m \iff a \leq b\]
<p>というただの自然数の大小関係で言い換えることが出来る.</p>
<p>自然数の上の大小関係のメビウス関数は,</p>
\[\mu \colon \mathbb N \times \mathbb N \to \mathbb Z\]
\[\mu(a,b) = \begin{cases}
1 &amp; \text{ if } a = b \\
-1 &amp; \text{ if } a + 1 = b \\
0 &amp; \text{ else } \\
\end{cases}\]
<p>で表される.</p>
<p>一般の自然数に今の話を拡張するには, 自然数を並べて直積を取ればよく, 結局 各素数の指数を見て, それが \(a+1=b\) であるようなものの個数だけ \((-1)\) の累乗を取ったものになる.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>