<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>層</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon" style="position:absolute; left:0.4em; top:0.4em; width:1.3em;border-radius:0.8em;"></i></a>
</header>
<header>
<h1 class="title">層</h1>
</header>
<p class="date" style="text-align: right">
2017-11-12 (Sun.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#層>層</a></p>
</div>
<h2 id="index">index</h2>
<div id="toc">

</div>
<p><span class="math display">\[\def\O{\mathcal{O}}\]</span></p>
<h2 id="前層-preshaef">前層 (preshaef)</h2>
<p>二通りの定義を与える.</p>
<h3 id="定義1">定義1</h3>
<div class="thm">
<p>位相空間 <span class="math inline">\(X\)</span> の <strong>前層</strong> とは、 集合 <span class="math inline">\(A\)</span>, 関数 <span class="math inline">\(E: A \rightarrow \O(X)\)</span>, 関数 <span class="math inline">\(\rceil: A \times \O(X) \rightarrow A\)</span> (<span class="math inline">\((a, U) \mapsto a \rceil U\)</span>) からなる三組 <span class="math inline">\((A, E, \rceil)\)</span> であって次のようなもの.</p>
<ol start="0" type="1">
<li>任意の <span class="math inline">\(a, b \in A\)</span> に対して <span class="math inline">\(a \rceil \emptyset = b \rceil \emptyset\)</span></li>
<li><span class="math inline">\(a \rceil Ea = a\)</span> <span class="math inline">\(~~~\)</span>(註意: <span class="math inline">\(\rceil\)</span> の結合則は <span class="math inline">\(E\)</span> の適用より弱い)</li>
<li><span class="math inline">\(E (a \rceil U) = E a \cap U\)</span></li>
<li><span class="math inline">\((a \rceil U) \rceil V = a \rceil U \cap V\)</span> <span class="math inline">\(~~\)</span> (註意: <span class="math inline">\(\cap\)</span> の結合則のが <span class="math inline">\(\rceil\)</span> より強い)</li>
</ol>
</div>
<h4 id="例">例</h4>
<p>関数の集合 <span class="math inline">\(A\)</span>, 関数の定義域を与える手続き <span class="math inline">\(E\)</span>, 普通の意味で関数の(定義域の)制限 <span class="math inline">\(\rceil\)</span>.</p>
<p>註意すべき点として、層としての制限 <span class="math inline">\(\rceil\)</span> の右項には <span class="math inline">\(Ef\)</span> よりも広い集合を与えても構わないということ. 関数の制限 (これを区別する意味で <span class="math inline">\(\lceil\)</span> と書く) の右項には普通、ドメインより小さい領域を与えるだろう. そこで次のように <span class="math inline">\(\rceil\)</span> を定め直せばよい: <span class="math display">\[f \rceil U := f \lceil (Ef \cap U)\]</span></p>
<p>また、ドメインが空集合な関数は空集合ただ1つである. <span class="math display">\[f \rceil \emptyset = \emptyset = g \rceil \emptyset\]</span></p>
<p>ドメイン (定義域) が空集合であるような関数は <strong>存在しない</strong> しないのではなく, <strong>唯1つ</strong> 存在することに註意 (参考; <a href="https://ja.wikipedia.org/wiki/%E7%A9%BA%E9%96%A2%E6%95%B0">空関数</a>).</p>
<blockquote>
<p>明らかに前層とはこれを抽象化したものである</p>
</blockquote>
<h3 id="定義2">定義2</h3>
<div class="thm">
<p>位相空間 <span class="math inline">\(X\)</span> の <strong>前層</strong> とは、 <span class="math inline">\(X\)</span> の開集合を適当な集合の集合 <span class="math inline">\(\mathcal{A}\)</span> に写すような <span class="math display">\[F : \O(X) \to \mathcal{A}\]</span> 及び <span class="math inline">\(U,V \in \O(X)\)</span> について <span class="math inline">\(U \subseteq V\)</span> ならば <span class="math display">\[r_{UV} : F(V) \to F(U)\]</span> が定まっているようなもの. これらの <span class="math inline">\(\left(F, r = \{ r_{UV} : U, V \in \O(X) \}\right)\)</span> を前層だという. ただし次を要請する.</p>
<ol start="0" type="1">
<li><span class="math inline">\(F(\emptyset)\)</span> は単集合</li>
<li><span class="math inline">\(r_{UU}\)</span> は恒等写像</li>
<li><span class="math inline">\(U \subseteq V \subseteq W\)</span> のとき <span class="math inline">\(r_{UW} = r_{UV} \circ r_{VW}\)</span></li>
</ol>
</div>
<p>こちらは圏論的に <strong>関手</strong> として前層を定義している (参考; <a href="http://cympfh.cc/taglibro/2018/07/17.html">前層はモノイド(右)作用の一般化</a>).</p>
<p>これら2つの定義が等価であることを確認する.</p>
<h3 id="定義1-定義2">定義1 → 定義2</h3>
<div class="thm">
<p>前層が <span class="math inline">\((A,E,\rceil)\)</span> で与えられた時、次で定義2を構成できる.</p>
<ol type="1">
<li><span class="math inline">\(F(U) = \{ f \in A : Ef = U \}\)</span></li>
<li><span class="math inline">\(r_{UV}(f) = f \rceil U\)</span></li>
</ol>
</div>
<p>要請を満たすことを確認する.</p>
<ol start="0" type="1">
<li><span class="math inline">\(F(\emptyset) = \{ f : Ef = \emptyset \}\)</span> は単集合か?
<ul>
<li><span class="math inline">\(f = f \rceil (Ef)\)</span> より <span class="math inline">\(f \in F(\emptyset) \Rightarrow f = f \rceil \emptyset\)</span></li>
<li><span class="math inline">\(F(\emptyset)\)</span> が 2つ以上の要素をもって <span class="math inline">\(f,g\)</span> がそうであるとき、
<ul>
<li><span class="math inline">\(f = f\rceil \emptyset = g\rceil \emptyset = g\)</span></li>
<li>従って、<span class="math inline">\(F(\emptyset)\)</span> は要素を高々1つしか持たない</li>
</ul></li>
<li>また <span class="math inline">\(F(\emptyset)\)</span> は空集合でもない
<ul>
<li>任意の <span class="math inline">\(a\)</span> について
<ul>
<li><span class="math inline">\(E(a \rceil \emptyset) = Ea \cap \emptyset = \emptyset\)</span></li>
</ul></li>
<li>であるので、<span class="math inline">\((a \rceil \emptyset) \in F(\emptyset)\)</span></li>
</ul></li>
</ul></li>
<li><span class="math inline">\(r_{UU}\)</span> は恒等写像か?
<ul>
<li>明らか</li>
</ul></li>
<li><span class="math inline">\(r_{UW} = r_{UV} \circ r_{VW}\)</span>
<ul>
<li><span class="math inline">\(r_{VW} : F(W) \to F(V)\)</span></li>
<li><span class="math inline">\(r_{UV} : F(V) \to F(U)\)</span></li>
<li><span class="math inline">\(f \in F(W) = \{ f : Ef = W \}\)</span> について
<ul>
<li><span class="math inline">\(r_{VW}(f) = f \rceil V\)</span></li>
<li><span class="math inline">\((r_{UV} \circ r_{VW}(f) = (f \rceil V) \rceil U = f \rceil (V \cap U) = f \rceil U = r_{UV}(f)\)</span></li>
</ul></li>
</ul></li>
</ol>
<p>というわけでok.</p>
<h3 id="定義2-定義1">定義2 → 定義1</h3>
<div class="thm">
<p>逆に前層が <span class="math inline">\((F, r)\)</span> で与えられたとき、 先ほどの全く逆によって構成できる.</p>
<ol type="1">
<li><span class="math inline">\(A = \bigcup_{U \in \O(X)} F(U)\)</span></li>
<li><span class="math inline">\(f \in F(U) \iff Ef = U\)</span></li>
<li><span class="math inline">\(f \rceil U = r_{VW}(f)\)</span>
<ul>
<li>where <span class="math inline">\(V = U \cap W, W=Ef\)</span></li>
</ul></li>
</ol>
</div>
<p>要請を満たすことを確認する.</p>
<ol start="0" type="1">
<li><span class="math inline">\(a,b \in A\)</span> について
<ul>
<li><span class="math inline">\(a \rceil \emptyset = r_{VW}(a)\)</span>
<ul>
<li>ここで <span class="math inline">\(V = \emptyset, W = Ef = U_a\)</span> で
<ul>
<li><span class="math inline">\(r_{VW} : F(W) \to F(V)\)</span></li>
<li><span class="math inline">\(F(V)\)</span> は単集合であるので、 <span class="math inline">\(r_{VW}\)</span> は一点に写す関数</li>
</ul></li>
<li>従って <span class="math inline">\(r_{VW}(a) = r_{VW&#39;}(b)\)</span></li>
</ul></li>
<li>よって <span class="math inline">\(a \rceil \emptyset = b \rceil \emptyset\)</span></li>
</ul></li>
<li><span class="math inline">\(f \rceil (Ef) = r_{VW} f\)</span>
<ul>
<li>ただし <span class="math inline">\(V = Ef \cap W, W = Ef\)</span></li>
<li>なので <span class="math inline">\(V=W\)</span> なんで <span class="math inline">\(r_{VW}\)</span> は恒等写像</li>
<li>というわけで、 <span class="math inline">\(f \rceil (Ef) = f\)</span></li>
</ul></li>
<li><span class="math inline">\(f \rceil U = r_{VW}(f) \in F(V)\)</span>
<ul>
<li>ここで <span class="math inline">\(V = U \cap Ef\)</span></li>
<li><span class="math inline">\(E(f \rceil U) = V = U \cap Ef\)</span></li>
</ul></li>
<li><span class="math inline">\((f \rceil U) \rceil V = f \rceil (U \cap V)\)</span>
<ul>
<li>大体同様に</li>
</ul></li>
</ol>
<p>ところでしかし、この定義1と2とが本当に対応してるかを見るには、 定義1の前層を定義2に(上の方法で)した後、再び(上の方法で)定義1に戻して得た前層が、元の前層と同じ (あるいは同型) であることを確かめないといけない.</p>
<h2 id="両立-compatible">両立 (compatible)</h2>
前層 <span class="math inline">\(A\)</span> の2つの元 <span class="math inline">\(f, g \in A\)</span> が <strong>両立</strong> するとは、
<div class="thm">
<p><span class="math display">\[f \rceil Eg = g \rceil Ef\]</span></p>
</div>
<p>とあること.</p>
<p>関数集合の例でいうと、 定義域の交わる部分で関数の値が一致することを表す.</p>
<h2 id="層-sheaf">層 (sheaf)</h2>
<p>やはり二通りの定義を与える.</p>
<h3 id="定義1-1">定義1</h3>
<p><span class="math inline">\(X\)</span> の上の前層 <span class="math inline">\(A\)</span> が次を満たすとき、<span class="math inline">\(A\)</span> を <span class="math inline">\(X\)</span> の上の <strong>層</strong> と呼ぶ.</p>
<div class="thm">
<ul>
<li><span class="math inline">\(\forall f,g \in F\)</span> が両立するような <span class="math inline">\(F \subset A\)</span> に対して、次の2つを成立させる <span class="math inline">\(g\)</span> が唯一つ存在すること
<ol type="1">
<li><span class="math inline">\(\forall f \in F, g \rceil Ef = f\)</span></li>
<li><span class="math inline">\(Eg = \bigcup_{f \in F} Ef\)</span>
<ul>
<li>このような <span class="math inline">\(g\)</span> を <span class="math inline">\(F\)</span> に対して <span class="math inline">\(\cup F\)</span> と書く</li>
</ul></li>
</ol></li>
</ul>
</div>
<h4 id="例-1">例</h4>
<p>前に述べた関数の例は層である</p>
<h3 id="定義2-1">定義2</h3>
<p>定義1と同値な定義を与える.</p>
<div class="thm">
<p>位相空間 <span class="math inline">\(X\)</span> に対して 位相空間 <span class="math inline">\(S\)</span> と局所同相写像 <span class="math inline">\(p: S \to X\)</span> があるとき、 <span class="math inline">\((S, p)\)</span> を <span class="math inline">\(X\)</span> の上の <strong>層</strong> という.</p>
</div>
<p>ここで <span class="math inline">\(p: S \to X\)</span> が局所同相写像とは、任意の点 <span class="math inline">\(s \in S\)</span> に対して、 定義域を <span class="math inline">\(s\)</span> を含むように適切に小さく制限して得た写像 <span class="math inline">\(p \lceil U\)</span> が同相写像であること.</p>
<h3 id="定義1-定義2-1">定義1 → 定義2</h3>
<p>層 <span class="math inline">\(A\)</span> が与えられた時、 <span class="math display">\[\tilde{S} = \{ (x, f) ~:~ f \in A, x \in Ef \}\]</span> <span class="math inline">\(\tilde{S}\)</span> の上の同値関係 <span class="math display">\[(x_1,f_1) \equiv (x_2, f_2) \iff
x_1=x_2
\land
\exists U (x \in U), U \subseteq Ef_1\cap Ef_2 \land
f_1 \rceil U = f_2 \rceil U\]</span> で割って <span class="math display">\[S = \tilde{S}\!\!\equiv\]</span> とする. 同値関係で明らかに <span class="math inline">\(x\)</span> については1つに定まるので <span class="math display">\[p : S \to X\]</span> <span class="math display">\[p (x, f) = x\]</span> という関数が定まる.</p>
<p><span class="math inline">\(S\)</span> に位相を入れる. <span class="math inline">\(x \in X\)</span> の近傍を <span class="math inline">\(V_x\)</span> とするとき <span class="math inline">\((x,f)\)</span> の近傍を <span class="math display">\[\{ (y, f) /\! \equiv ~:~ y \in V_x\}\]</span> と定める. これによって位相を入れる (<a href="neigh-to-topo.html">近傍によって位相を入れる</a> 参照).</p>
<p>以上の <span class="math inline">\((S,p)\)</span> が層 <span class="math inline">\(A\)</span> に対応する定義2の形の層である.</p>
<h3 id="定義2-定義1-1">定義2 → 定義1</h3>
<p><span class="math inline">\(X\)</span> 上の層 <span class="math inline">\((S,p)\)</span> から <span class="math inline">\((A,E,\rceil)\)</span> の形の層を次のようにして構成できる.</p>
<p><span class="math inline">\(U \in \O(X)\)</span> について <span class="math display">\[\Gamma(U) = \{ f : f:U \to S, p \circ f = i \}\]</span> として</p>
<ol type="1">
<li><span class="math inline">\(A = \bigcup \Gamma(U)\)</span></li>
<li><span class="math inline">\(Ef=U \iff f \in \Gamma(U)\)</span></li>
<li><span class="math inline">\(f \rceil V = f \lceil (V \cap Ef)\)</span>
<ul>
<li>右辺は単なる関数の制限</li>
</ul></li>
</ol>
<p>定義2 であっても前層でかつ定義1の層と一致することがわかる.</p>
<p>ここで <span class="math inline">\(\Gamma\)</span> の定義で出てくる <span class="math inline">\(i\)</span> は <span class="math inline">\(U \to X\)</span> の埋め込みである. <span class="math inline">\(\Gamma(U)\)</span> の要素は <span class="math inline">\(p\)</span> に対する <span class="math inline">\(U\)</span> 上の切断のこと. 以下のような可換図式が成り立つ.</p>
<p><img src="data:image/png;base64,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"></p>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
