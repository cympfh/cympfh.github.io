<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>米田の補題</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">米田の補題</h1>
<p><p class=date style='text-align: right'>2018-11-10 (Sat.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#圏論>圏論</a> </div></p>
\[
\def\op#1{{#1}^{\text{op}}}
\def\Nat{\mathit{Nat}}
\require{amscd}
\]
<p>極力, 関数適用の括弧や関数合成の \(\circ\) は省略する. 例えば \((g \circ f)(x)\) は単に \(gfx\) と書く. また対象 \(A\) の上の恒等射を \(1_A\) と書き, \(A\) がどうでもいいとき単に \(1\) と書く.</p>
<h2>関手 \(\mathcal C\)</h2>
<p>圏 \(\def\C{\mathcal C}\C\) において, その2つの対象 \(A,B \in \C\) の間の射を全て集めたものを</p>
\[\C(A,B)\]
<p>だとか</p>
\[\mathrm{Hom}(A,B)\]
<p>だとか書く. 今は単にこれは集合だとする. つまり \(\def\Sets{\mathrm{Sets}}\Sets\) における対象であるとする.</p>
<p>だとすると, コレ自体が関手だと見なせる.</p>
<h3>関手 \(\C(A,-)\)</h3>
<p>まずは \(A\) の部分は固定するとして \(B\) 部分を引数にする関手</p>
\[\C(A,-)\]
<p>を次のように定義する.</p>
\[\C(A,-) : \C \to \Sets\]
\[\C(A,-) : B \mapsto \C(A,B)\]
<p>対象の割り当てはこのように定めるが, 射については次のようにする.</p>
\[\begin{CD}
B_1 @&gt;f&gt;&gt; B_2 \in \C
\end{CD}\]
<p>について \(\C(A,B_1) \to \C(A,B_2)\) なる射を与える必要があるが, 自明なものとして, \(f\) を後ろに合成するという関数があり得る.</p>
\[\C(A,f) : \C(A,B_1) \to \C(A,B_2)\]
\[\C(A,f) : g \mapsto f \circ g\]
<p>ただしここで \(\C(A,-)(f)\) を \(\C(A,f)\) と書いた.</p>
\[\begin{CD}
B_1 @. \C(A,B_1) \ni g \\
@VfVV @V\C(A,f)VV \\
B_2 @. \C(A,B_2) \ni fg \\
\end{CD}\]
<p>以上で定まる \(\C(A,-)\) は確かに関手である. 念の為確認しておく.</p>
<h4>Proof</h4>
<p>これが関手であるとは恒等射 \(1\) が \(1\) に写ることと, 合成について準同型であること.</p>
<ul>
  <li>\(1 \in \C\) について,</li>
</ul>
<p>\(\C(A, 1) = (g \mapsto 1g) = (g \mapsto g) = 1\) なので恒等射. - \(f_1, f_2, f_1f_2 \in \C\) について, \(\C(A, f_1f_2) = (g \mapsto (f_1f_2)g) = (g \mapsto f_1g) (g \mapsto f_2g) = \C(A,f_1) \C(A,f_2)\) なので確かに準同型.</p>
<p>以上よりok.</p>
<p>というわけで, 圏 \(\C\) とその中の１つの対象 \(A \in \C\) について, 関手</p>
\[\C(A,-) : \C \to \Sets\]
<p>が定義された.</p>
<h3>関手 \(\C(-,B)\)</h3>
<p>今度は逆に \(\C(A,B)\) という射の集合について, \(A\) だけを引数にすることで, これが関手になる. ただし今度は合成するのが前からになる都合上,</p>
\[\op{\C} \to \Sets\]
<p>という関手として定義する. 向きだけが逆な以外は先ほどと全く同様に定義される.</p>
\[\begin{CD}
A_1 @. \C(A_1,B) \ni g \\
@AfAA @V\C(f,B)VV \\
A_2 @. \C(A_2,B) \ni gf
\end{CD}\]
<h3>関手 \(\C(-,-)\)</h3>
<p>以上2つを組み合わせれば関手</p>
\[\C(-,-) : \op{\C} \times \C \to \Sets\]
<p>が定義される.</p>
<p>対象の割り当てはやはり \((A, B)\) に対して \(\C(A,B)\) を射の集まり (集合) として定義する.</p>
<p>射は前後から合成する.</p>
\[\begin{CD}
A_1  @. B_1   @. \C(A_1,B_1) \ni h \\
@AfAA   @VgVV    @V\C(f,g)VV \\
A_2  @. B_2   @. \C(A_2,B_2) \ni ghf \\
\end{CD}\]
<h2>米田の補題</h2>
<p>関手 \(F : \op{\C} \to \Sets\) について</p>
\[\Sets^{\op{\C}} (\C(-, C), F) \simeq FC\]
<p>ここで \(\Sets^{\op{\C}}\) は関手圏である.</p>
<p>\(F\) から \(G\) への自然変換の集まりを \(\Nat(F,G)\) と書くことにする. また \(\Nat\) はやはり \(\Nat(-,-)\) という関手を定めることに注意 ( \(\Nat\) は適切な関手圏のこと). これを用いれば, 先ほどの主張は</p>
\[\Nat(\C(-, C), F) \simeq FC\]
<p>とも書ける.</p>
<p>また, これと対称的な主張として</p>
\[\Sets^{\op{\C}} (\C(C,-), F) \simeq FC\]
<p>または</p>
\[\Nat(\C(C,-), F) \simeq FC\]
<p>が成り立つ.</p>
<h3>Proof</h3>
<p>一方は他方の対称なので一方だけ証明する. 同型射</p>
\[\Phi_C : \Nat(\C(-, C), F) \to FC\]
<p>の存在を言うことで, 2つが同型であることを示す.</p>
<p>\(s \in \Nat(\C(-,C),F)\) について,</p>
\[\begin{CD}
\C(C,C)     @&gt;s_C&gt;&gt; FC \\
\end{CD}\]
<p>であって \(1_C \in \C(C,C)\) なので, \(s_C(1_C) \in FC\) である. そこで</p>
\[\Phi_C(s) = s_C(1_C)\]
<p>と定義すると, 実はこれが同型射になっている. 全単射であることを示す.</p>
<h4>\(\Phi_C\) は単射</h4>
<p>\(s,t \in \Nat(\C(-,C),F)\) について, \(\Phi_C(s)=\Phi_C(t)\) を仮定して, \(s=t\) を導く. すなわち,</p>
\[\forall C, s_C(1_C)=t_C(1_C) \implies \forall D, s_D=t_D\]
<p>を示す.</p>
<p>\(s\) の自然性より \(f \in \C(D,C)\) について</p>
\[\begin{CD}
C     @. \C(C,C)   @&gt;s_C&gt;&gt; FC \\
@AfAA    @V\C(f,C)VV       @VFfVV \\
D     @. \C(D,C)   @&gt;s_D&gt;&gt; FD \\
\end{CD}\]
<p>この右の四角形が \(\Sets\) において可換なので</p>
\[s_D f = (Ff) s_C\]
<p>が成り立つ. 同様に \(t_D f = (Ff) t_C\) であって, 今 \(s_C=S_D\) なので</p>
\[s_D f = t_D f\]
<p>である. 今これは任意の \(f \in \C(D,C)\) について成立するので結局 \(s_D=t_D\) であって, \(D\) も自由に取って良いので</p>
\[s=t\]
<p>が導かれた.</p>
<p>というわけで \(\Phi_C\) は単射.</p>
<h4>\(\Phi_C\) は全射</h4>
<p>任意の \(X \in FC\) についてある自然変換 \(s\) があって \(\Phi_C(s)=X\) であることを示す. つまり,</p>
\[\forall X \in FC, \exists s, s_C(1_C) = X\]
<p>を示す.</p>
<p>自然変換 \(s\) を定義するには任意の対象 \(D\) について, 関数 \(s_D : \C(D,C) \to FD\) を定義できればよい.</p>
<p>射 \(f : D \to C\) について</p>
\[Ff : FC \to FD\]
<p>\(X \in FC\) について \((Ff)X \in FD\) だから,</p>
\[s_D(f) = (Ff)(X)\]
<p>と定義するのが自然. これによって定義される \(s\) を用いると,</p>
\[s_C(1_C) = (F1)(X) = 1(X)=X\]
<p>なので, これが全射性の証拠になっている.</p>
<p>というわけで \(\Phi_C\) は全単射. というわけで \(\Nat(\C(-,C),F)\) と \(FC\) は同型.</p>
<p>これとの対称性から \(\Nat(\C(C,-),F)\) と \(FC\) との同型も全く同様に示される.</p>
<h4>\(\Phi_C\) の逆写像</h4>
<p>\(\Phi_C\) が全単射であることがわかったので逆写像を作ることも出来る. それは全射性を示される中で暗に定められており, すなわち,</p>
\[\Psi_C \colon FC \to \Nat(\C(-,C),F)\]
\[\Psi_C(X) = s ~;~ \text{ where } s_A(f) = (Ff)(X)\]
<p>米田の補題の証明としてはこれが逆写像であることを見る方が早いか.</p>
<h4>自然な同型であること</h4>
<p>ここまでで示したことは, 集合として</p>
\[\Sets^{\op{\C}} (\C(-, C), F) \simeq FC\]
<p>という同型関係があることにすぎない. 米田の補題は更にこれが自然な同型であることまでを言う.</p>
<p>すなわち, \(Y_\C(C) = \C(-,C)\) としたとき, \(\Nat(Y_\C(-), F)\) もまた \(F\) と同様に</p>
\[\op{\C} \to \Sets\]
<p>なる関手である.</p>
<p>このとき,</p>
\[\Nat(Y_\C(-),F) \simeq F\]
<p>であることが言える.</p>
<p>すなわち, 互いに逆になる自然変換がある. それはちょうど今定めた \(\Phi\) ( \(C\) に対して \(\Phi_C\) を与えるもの) と \(\Psi\) がそれになっている.</p>
<h4>系</h4>
\[\Sets^{\op{\C}} (\C(-, C), F) \simeq FC\]
<p>に \(F=\C(-,D)\) を代入することで</p>
\[\Sets^{\op{\C}} (\C(-, C), \C(-, D)) \simeq \C(C,D)\]
<p>を得る.</p>
<h4>系</h4>
\[\C(-, C) \simeq \C(-, D) \Rightarrow C \simeq D\]
<h5>証明</h5>
<p>仮定より \(s : \C(-, C) \simeq \C(-, D) : t\) なる自然同型 \(s,t\) がある.</p>
<p>これらを \(\Phi_C, \Phi_D\) で送って出来る,</p>
\[\Phi_C(s) : C \to D\]
\[\Phi_D(t) : D \to C\]
<p>がちょうど逆射になっている.</p>
<h5>全ての終対象は同型を除いて一意</h5>
<p>普通に証明出来る命題だが, 今の系を用いても証明できる. すなわち, 終対象の定義を思い出すと, \(C\) が終対象であるとは, \(\forall A, \C(A,C) \simeq \{\ast\}\) であることであった. 従って, \(C\) も \(D\) も終対象であるなら, 任意の \(A\) について今のことが言えるので,</p>
\[\C(-,C) \simeq \C(-,D)\]
<p>である. よって</p>
\[C \simeq D.\]
<p>同様に他の極限 (積など) についても同じことが言える.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>