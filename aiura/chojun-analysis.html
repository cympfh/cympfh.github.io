<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="超準解析とは何か?/定義/諸定理/定義/Ultrapower/無限小、無限大/" />
  <meta property="og:url" content="http://cympfh.cc/taglibro">
  <meta property="og:type" content="article">
  <meta property="og:title" content="超準解析" />
  <meta property="og:description" content="超準解析とは何か?/定義/諸定理/定義/Ultrapower/無限小、無限大/" />
  <meta property="og:image" content="http://cympfh.cc/resources/img/identicon.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@cympfh" />
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>超準解析</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>
<header>
<h1 class="title">超準解析</h1>
</header>
<p class="date" style="text-align: right">
2017-02-12 (Sun.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#フィルタ>フィルタ</a></p>
</div>
<h2 id="超準解析とは何か">超準解析とは何か?</h2>
<p>1960年に Abraham Robinson が作った nonstandard analysis は無限の数を扱うなんか計算モデル？ standard analysis (epsilon-delta) の上位互換として作られる.</p>
<h2 id="定義">定義</h2>
<p>以下を満たす <span class="math inline">\(U\)</span> を集合 <span class="math inline">\(J\)</span> 上のフィルタ (filter) と呼ぶ.</p>
<ol type="1">
<li><span class="math inline">\(U \subseteq 2^J\)</span></li>
<li><span class="math inline">\(\emptyset \not\in U\)</span></li>
<li><span class="math inline">\(\forall A, B \in U, A \cap B \in U\)</span> (intersection property)</li>
<li><span class="math inline">\(\forall A \in U, \forall B (A \subseteq B), B \in U\)</span></li>
</ol>
<p>以下の <span class="math inline">\(U\)</span> を <span class="math inline">\(J\)</span> 上の超ウィルタ (ultrafilter) と呼ぶ.</p>
<ol type="1">
<li><span class="math inline">\(U\)</span> は <span class="math inline">\(J\)</span> 上のフィルタ</li>
<li><span class="math inline">\(\forall A \in J\)</span> について次のどちらかちょうど一つが成立 (maximality)
<ol type="1">
<li><span class="math inline">\(\{A\} \in U\)</span></li>
<li><span class="math inline">\(J \setminus \{A\} \in U\)</span></li>
</ol></li>
</ol>
<p>以下の <span class="math inline">\(U\)</span> を <span class="math inline">\(J\)</span> 上の自由超フィルタ (free-ultrafilter) と呼ぶ.</p>
<ol type="1">
<li><span class="math inline">\(U\)</span> は <span class="math inline">\(J\)</span> 上の超フィルタ</li>
<li><span class="math inline">\(\nexists A \in U, |A| &lt; \infty\)</span> (freeness)</li>
</ol>
<h2 id="諸定理">諸定理</h2>
<h3 id="定理">定理</h3>
<p><span class="math inline">\(A\)</span> 上の超フィルタ <span class="math inline">\(U\)</span> 及び <span class="math inline">\(A\)</span> の有限個への分割 <span class="math inline">\(A_1, \ldots, A_n\)</span> について <span class="math display">\[\exists! i, A_i \in U\]</span> が成立する.</p>
<h3 id="証明">証明</h3>
<p>まず、<span class="math inline">\(\exists i, A_i \in U\)</span> を背理法によって示す.</p>
<p><span class="math inline">\(\forall i, A_i \not\in U\)</span> を仮定すると maximality 故に <span class="math inline">\(\forall i, A \setminus A_i \in U\)</span>. 更に intersection property から <span class="math inline">\(\emptyset = \bigcap_i (A \setminus A_i) \in U\)</span>. これは <span class="math inline">\(U\)</span> の超フィルタの定義に反する.</p>
<p>従って <span class="math inline">\(\exists i, A_i \in U\)</span> は成立する.</p>
<p>異なる <span class="math inline">\(i = i_1, i_2\)</span> についてこれが成立するとき、同様に <span class="math inline">\(\emptyset = \cap_{i=i_1, i_2} A_i \in U\)</span> となるので、そのような <span class="math inline">\(i_1, i_2\)</span> は存在しない.</p>
<p>以上から唯一の <span class="math inline">\(i\)</span> で成立する.</p>
<h3 id="定理-1">定理</h3>
<p><span class="math inline">\(A\)</span> 上のフィルタ <span class="math inline">\(F&#39;\)</span> から超フィルタ <span class="math inline">\(F\)</span> を導くことができる. <span class="math inline">\(\Phi\)</span> を <span class="math inline">\(A\)</span> 上のフィルタ全てからなる集合とする (<span class="math inline">\(F&#39; \in \Phi\)</span>).</p>
<p><span class="math inline">\(\Phi\)</span> の元に関して包含関係によって半順序を附けることができる. その最大限が欲しかった超フィルタ <span class="math inline">\(F\)</span> である.</p>
<h3 id="証明-1">証明</h3>
<p>(略)</p>
<h2 id="定義-1">定義</h2>
<p>2つの <span class="math inline">\(n\)</span> 次元実ベクトル <span class="math inline">\(a, b\)</span> 、実数に関する二項演算 <span class="math inline">\(\circ\)</span> に関して、 <span class="math inline">\(\{ i : 1 \leq i \leq n, a_i \circ b_i \}\)</span> を <span class="math display">\[[\![ a \circ b ]\!]\]</span> と書くことにする. 例えば <span class="math inline">\([\![ a = b ]\!]\)</span> は、成分の値が等しいインデックスの集合.</p>
<h3 id="超フィルタの法の下の等号性-equivalence-modulo-an-ultrafilter">超フィルタの法の下の等号性 (Equivalence Modulo an Ultrafilter)</h3>
<p>超フィルタ <span class="math inline">\(U\)</span> 及び2つの <span class="math inline">\(n\)</span> 次元実ベクトル <span class="math inline">\(a, b\)</span> について <span class="math display">\[a = b \mod{U} \iff [\![ a=b ]\!] \in U\]</span></p>
<h3 id="超フィルタの法の下の順序">超フィルタの法の下の順序</h3>
<p><span class="math display">\[a \leq b \mod{U} \iff [\![ a \leq b ]\!] \in U\]</span></p>
<p>この順序は全順序である.</p>
<h3 id="例">例</h3>
<ul>
<li><span class="math inline">\(\mathbb{a} = (0, 1, 0, 1, \ldots)\)</span></li>
<li><span class="math inline">\(\mathbb{b} = (1, 0, 1, 0, \ldots)\)</span></li>
<li><span class="math inline">\(\mathbb{0} = (0, 0, 0, 0, \ldots)\)</span></li>
<li><span class="math inline">\(\mathbb{1} = (1, 1, 1, 1, \ldots)\)</span></li>
</ul>
<p>について</p>
<ul>
<li><span class="math inline">\(\mathbb{a} \ne \mathbb{b} \mod{U}\)</span></li>
<li><span class="math inline">\(\mathbb{a} = 0 \mod{U}\)</span> または <span class="math inline">\(\mathbb{a} = 1 \mod{U}\)</span></li>
<li><span class="math inline">\(\mathbb{b} = 0 \mod{U}\)</span> または <span class="math inline">\(\mathbb{b} = 1 \mod{U}\)</span></li>
</ul>
<p>が <span class="math inline">\(U\)</span> によって成立する. 例えば <span class="math inline">\(\{0,2,4,\ldots\} \in U\)</span> なる超フィルタが作れる.</p>
<h2 id="ultrapower">Ultrapower</h2>
<p>ある超フィルタ <span class="math inline">\(U\)</span> を法とする等号によって <span class="math inline">\(n\)</span> 次元実ベクトル空間 <span class="math inline">\(R^n\)</span> の同値類を取った空間を <strong>超実空間 (hyperreal)</strong> と呼び <span class="math inline">\({}^*R\)</span> と書く. 次のように加算と乗算を定めることで体になる.</p>
<ul>
<li><span class="math inline">\(\mathbb{a} + \mathbb{b} = (a_1, a_2, \ldots) + (b_1, b_2, \ldots) = (a_1 + b_1, a_2 + b_2, \ldots)\)</span></li>
<li><span class="math inline">\(\mathbb{a} * \mathbb{b} = (a_1, a_2, \ldots) * (b_1, b_2, \ldots) = (a_1 * b_1, a_2 * b_2, \ldots)\)</span></li>
</ul>
<p>成り立ってほしい性質はだいたい成り立つ.</p>
<ul>
<li><span class="math inline">\(a_1=a_2 \land b_1=b_2 \mod U\)</span></li>
<li><span class="math inline">\(\iff [\![ a_1=a_2 ]\!] \in U \land [\![ b_1=b_2 ]\!] \in U\)</span></li>
<li><span class="math inline">\(\implies [\![ a_1=a_2 ]\!] \cap [\![ b_1=b_2 ]\!] \in U\)</span></li>
<li><span class="math inline">\(\iff [\![ a_1=a_2 \land b_1=b_2 ]\!] \in U\)</span></li>
<li><span class="math inline">\(\iff [\![ a_1+b_1=a_2+b_2 ]\!] \in U\)</span></li>
<li><span class="math inline">\(\iff a_1 + b_1 = a_2 + b_2 \mod U\)</span></li>
</ul>
<p>加算に関する単位元</p>
<ul>
<li><span class="math inline">\(a + zero = a \mod U\)</span></li>
<li><span class="math inline">\(\iff [\![a + zero = a]\!] \in U \iff [\![zero=0]\!] \in U\)</span></li>
<li><span class="math inline">\(\iff zero = 0 \mod U\)</span></li>
</ul>
<p>同様に乗算に関する単位元</p>
<ul>
<li><span class="math inline">\(a * one = a \mod U\)</span></li>
<li><span class="math inline">\(\iff one = 1 \mod U\)</span></li>
</ul>
<p><span class="math inline">\(U\)</span> の法の下で、それぞれ単位元は唯一に存在する.</p>
<p>逆元</p>
<ul>
<li><span class="math inline">\(a = (-a_1, -a_2, \ldots)\)</span></li>
<li><span class="math inline">\(\implies a + (-a) = 0 \mod U\)</span></li>
</ul>
<p>とすることで <span class="math inline">\(+\)</span> に関する <span class="math inline">\(a\)</span> の逆元 <span class="math inline">\((-a)\)</span> を構成することができる. 唯一の存在であることも確認できる. 2つの逆元 <span class="math inline">\(m, n\)</span> があるとする.</p>
<ul>
<li><span class="math inline">\(a + m = 0 \mod U\)</span></li>
<li><span class="math inline">\(a + n = 0 \mod U\)</span></li>
</ul>
<p>このとき</p>
<ul>
<li><span class="math inline">\(a + m + n = 0 + n = n \mod U\)</span></li>
<li><span class="math inline">\(a + m + n = 0 + m = m \mod U\)</span></li>
</ul>
<p>ということで自明に <span class="math inline">\(m = n \mod U\)</span>. というわけで <span class="math inline">\(U\)</span> の法の下で逆元は唯一.</p>
<p>乗算に関してもだいたい実数と同じ.</p>
<h2 id="無限小無限大">無限小、無限大</h2>
<p>自然数の列の集合を <span class="math inline">\({}^*N\)</span> と書く. <span class="math inline">\(a \in {}^*R\)</span> と <span class="math inline">\(n \in {}^*N\)</span> との大小を超フィルタ <span class="math inline">\(U\)</span> の下で定める.</p>
<ol type="1">
<li><span class="math inline">\(\forall n \in {}^*N, a \leq n\)</span> を満たす <span class="math inline">\(a\)</span> を無限小と呼ぶ.</li>
<li><span class="math inline">\(\forall n \in {}^*N, a \geq n\)</span> を満たす <span class="math inline">\(a\)</span> を無限大と呼ぶ.</li>
</ol>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
