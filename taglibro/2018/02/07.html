<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Wed Feb 07 2018</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../../../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<a href="../../">🔙 Back to Top</a>
<header>
<h1 class="title">Wed Feb 07 2018</h1>
</header>
<h2 id="諸々定義">諸々定義</h2>
<ul>
<li>位相空間: 略</li>
<li>開集合、閉集合: 略</li>
<li>連続写像:
<ul>
<li>(位相空間の間の) 写像 <span class="math inline">\(f : X \to Y\)</span> であって、<span class="math inline">\(Y\)</span> の任意の開集合 <span class="math inline">\(U\)</span> に対して逆像 <span class="math inline">\(f^{-1}(U)\)</span> がいつも開集合となるような写像</li>
</ul></li>
<li>同相写像:
<ul>
<li>写像 <span class="math inline">\(f\)</span> と、その逆写像 <span class="math inline">\(f^{-1}\)</span> が共に連続であるような写像</li>
</ul></li>
<li>被覆:
<ul>
<li>集合 <span class="math inline">\(X\)</span> の被覆 (或いは <strong>開</strong> 被覆) とは、無限個を許す開集合の系 <span class="math inline">\(\{U_i\}_i\)</span> であって <span class="math inline">\(\cup_i U_i=X\)</span> となるもののこと</li>
</ul></li>
<li>コンパクト空間: 略</li>
<li>ハウスドルフ空間: 略
<ul>
<li>空間 <span class="math inline">\(X\)</span> について、次のような操作 <span class="math inline">\(H\)</span> が存在するとき、<span class="math inline">\(X\)</span> をハウスドルフ空間と呼ぶ
<ol type="1">
<li><span class="math inline">\(X\)</span> から異なる2点 <span class="math inline">\(x,y\)</span> を取ってくる</li>
<li><span class="math inline">\(H\)</span> とはこの2点についてそれぞれの近傍を見つけてくる操作
<ul>
<li><span class="math inline">\((U_x, U_y) = H(x, y)\)</span>
<ul>
<li><span class="math inline">\(x \in U_x\)</span></li>
<li><span class="math inline">\(y \in U_y\)</span></li>
</ul></li>
<li>ただし2つの近傍は交わっていないこと
<ul>
<li><span class="math inline">\(U_x \cap U_y = \emptyset\)</span></li>
</ul></li>
<li>このような操作 <span class="math inline">\(H\)</span> はもちろん、<span class="math inline">\(X\)</span> に対してただ一通りとは限らない
<ul>
<li>後の説明ではとりあえず、ただ一通りを持っておく</li>
</ul></li>
</ul></li>
</ol></li>
</ul></li>
</ul>
<h2 id="補題1.-コンパクト空間の部分閉集合はコンパクト空間">補題1. コンパクト空間の部分閉集合はコンパクト空間</h2>
<div class="thm">
<p>コンパクト空間 <span class="math inline">\(X\)</span> の部分集合 <span class="math inline">\(Y\)</span> が閉集合なら、<span class="math inline">\(Y\)</span> もコンパクト空間である.</p>
</div>
<p><span class="math inline">\(Y=X\)</span> ならば自明にそうなので、そうでないとする. およそコンパクトの定義通りに示す.</p>
<p><span class="math inline">\(Y\)</span> に対して任意の被覆を与える: <span class="math display">\[\{U_i\}_i : \bigcup_i U_i = Y.\]</span></p>
<p>これに単集合 <span class="math inline">\(\{X \setminus Y\}\)</span> を付け加える. ここで <span class="math inline">\((X \setminus Y)\)</span> は <span class="math inline">\(Y\)</span> が閉集合であることから開集合であることに注意. <span class="math display">\[\bigcup_i U_i \cup (X \setminus Y) = X\]</span> であるので、これは <span class="math inline">\(X\)</span> の被覆である.</p>
<p>さて <span class="math inline">\(X\)</span> はコンパクト空間であるので、有限のインデックスの集合 <span class="math inline">\(I\)</span> を使って、 <span class="math display">\[\bigcup_I U_i \cup (X \setminus Y) = X\]</span> とできる.</p>
<p>これに対して <span class="math display">\[\bigcup_I U_i = Y\]</span> であることもほとんど明らか. 従って <span class="math inline">\(Y\)</span> もコンパクト空間.</p>
<h2 id="補題2.-コンパクト空間を連続写像で写した先はコンパクト空間">補題2. コンパクト空間を連続写像で写した先はコンパクト空間</h2>
<div class="thm">
<p>コンパクト空間 <span class="math inline">\(X\)</span> を連続写像で写したとき <span class="math inline">\(Y=f X\)</span> とすると <span class="math inline">\(Y\)</span> はコンパクト空間である.</p>
</div>
<p>これも先ほど同様に定義通り示す. <span class="math inline">\(f\)</span> の値域を <span class="math inline">\(Y\)</span> に制限したとき、<span class="math inline">\(f\)</span> は全射であることに注意.</p>
<p><span class="math inline">\(Y\)</span> に任意の被覆 <span class="math inline">\(\{U_i\}_i\)</span> を取ってくる. 各 <span class="math inline">\(U_i\)</span> を <span class="math inline">\(f^{-1}\)</span> で戻してきたものを <span class="math inline">\(V_i = f^{-1}(U_i)\)</span> と書くことにするが、<span class="math inline">\(f\)</span> の連続性より、これらは開集合.</p>
<p>さて <span class="math inline">\(\{V_i\}_i\)</span> は <span class="math inline">\(X\)</span> の被覆となっている. さもなくば、どの <span class="math inline">\(V_i\)</span> にも属さない点 <span class="math inline">\(x \in X\)</span> を取ってきて <span class="math inline">\(\forall i, f(x) \not\in U_i\)</span>. とでき、<span class="math inline">\(U_i\)</span> が被覆であることに反する.</p>
<p>そして <span class="math inline">\(X\)</span> がコンパクトであることの仮定から、有限のインデックスの集合 <span class="math inline">\(I\)</span> を用いて <span class="math display">\[\bigcup_I V_i = X\]</span> とできる. 同じインデックス集合を用いて <span class="math display">\[\bigcup_I U_i = Y\]</span> とできることもほとんど明らか (特に全射性があるので). 従って <span class="math inline">\(Y\)</span> もコンパクト空間.</p>
<h2 id="定理.-コンパクト空間からハウスドルフ空間への連続全単射は同相写像">定理. コンパクト空間からハウスドルフ空間への連続全単射は同相写像</h2>
<blockquote>
<p>多様体であることを示す先に局所座標を与えるが、局所座標であるためには同相写像でなければならない. そのような場合にこの定理を何度も用いた.</p>
</blockquote>
<div class="thm">
<p>コンパクト空間 <span class="math inline">\(X\)</span> からハウスドルフ空間 <span class="math inline">\(Y\)</span> への連続で全単射な写像 <span class="math inline">\(f\)</span> があるとき、これは同相写像である.</p>
</div>
<p><span class="math inline">\(f:X \to Y\)</span> が連続であることは仮定してあるので、その逆 <span class="math inline">\(f^{-1}: Y \to X\)</span> が連続であることを示せば、<span class="math inline">\(f\)</span> は同相写像である. 連続写像の定義から、結局次を示せば良い.</p>
<div class="thm">
<p><span class="math inline">\(X\)</span> の中の任意の開集合 <span class="math inline">\(U\)</span> を取ってきたとき、<span class="math inline">\(f U\)</span> がいつも開集合であれば <span class="math inline">\(f\)</span> は同相写像.</p>
</div>
<p><span class="math inline">\(fU\)</span> が <span class="math inline">\(Y\)</span> または <span class="math inline">\(\emptyset\)</span> ならば自明に開集合であるので、そのような場合は除く. この場合、 <span class="math inline">\(fU\)</span> も <span class="math inline">\(Y \setminus fU\)</span> も空でないので、どちらからも1点ずつ取ってくることが出来る. <span class="math inline">\(Y\)</span> はハウスドルフ空間であるので、その2点を分離する近傍を取れる. これを利用する.</p>
<div class="thm">
<h3 id="remark">Remark</h3>
<p>集合 <span class="math inline">\(V (\subset Y)\)</span> が開集合であることは次と同値. 任意の点 <span class="math inline">\(y \in V\)</span> に対して、 <span class="math display">\[y \in V_y \subset V\]</span> なる開集合 (近傍) <span class="math inline">\(V_y\)</span> を取ってこれること.</p>
</div>
<p>ある一点 <span class="math inline">\(y \in fU\)</span> に対してこの上のような近傍を構成する.</p>
<ul>
<li>点 <span class="math inline">\(y \in fU\)</span> に対して、<span class="math inline">\(fU\)</span> の補集合のすべての点を分離させる:
<ul>
<li><span class="math inline">\(\{ H(y, y&#39;) = (V_y, V_y&#39;) : y&#39; \in (Y \setminus fU) \}\)</span></li>
</ul></li>
</ul>
<p>仮定から <span class="math inline">\(X\)</span> はコンパクト. <span class="math inline">\(X\setminus U\)</span> は <span class="math inline">\(X\)</span> の部分閉集合なので、これもコンパクト (<strong>補題1</strong>). これを <span class="math inline">\(f\)</span> で写した先 <span class="math inline">\(f(X \setminus U) = Y \setminus fU\)</span> も、やはりコンパクト (<strong>補題2</strong>).</p>
<p><span class="math display">\[\{ V_y&#39; \cap (Y\setminus fU) : y&#39; \in (Y \setminus fU), H(y, y&#39;) = (V_y, V_y&#39;) \}\]</span> これは <span class="math inline">\((Y \setminus fU)\)</span> における被覆である. <em>注意として、<span class="math inline">\((Y\setminus fU)\)</span> における位相あるいは開集合とは、<span class="math inline">\(Y\)</span> における開集合を制限 (<span class="math inline">\(\cap\)</span>) したものであること.</em> そしてこれがコンパクトであるので、有限の点集合 <span class="math inline">\(J=\{y&#39;\}\)</span> で尚被覆できる. <span class="math display">\[(Y\setminus fU) = \bigcup \{ V_y&#39; \cap (Y\setminus fU) : y&#39; \in J \}\]</span> <span class="math inline">\(V_y\)</span> と <span class="math inline">\(V_y&#39;\)</span> が交わらないので、 <span class="math display">\[\iff fU \supseteq \bigcup \{ V_y : y&#39; \in J, H(y,y&#39;)=(V_y,V_y&#39;) \}\]</span></p>
<p>この右辺は有限個の開集合の union なのでやはり開集合である. 構成の仕方より <span class="math inline">\(y\)</span> を含む近傍であって、 そして <span class="math inline">\(fU\)</span> の含まれる集合であることを示した.</p>
<p>任意の点 <span class="math inline">\(y\in fU\)</span> についてこれが言えるので、結局これは <span class="math inline">\(fU\)</span> が開集合であることを言っている.</p>
<p>というわけで、 任意の開集合 <span class="math inline">\(U\)</span> に対して <span class="math inline">\(fU\)</span> が開集合である. 従って <span class="math inline">\(f^{-1}\)</span> は連続写像である. 仮定と併せて <span class="math inline">\(f\)</span> は同相写像である.</p>
<!--

  HTML として pandoc -B で include する.

  <H2> を列挙してそれらにリンクを貼った toc を id='toc' に埋め込む.
  markdown で書いてるだろうから例として次のような段落を書けばよい.

```
## INDEX
<div id=toc></div>
```

  used in
  - /memo/gnuplot
  - /memo/linux
  - /memo/imagemagick

-->
<script>
(function() {
  var sections = document.getElementsByTagName('h2');
  var i;
  var OL = document.createElement('ol');
  for (i=0; i < sections.length; ++i) {
    var LI = document.createElement('li');
    var A = document.createElement('a');
    A.innerHTML = sections[i].innerHTML;
    if (A.innerHTML.toUpperCase() == 'INDEX') continue;
    A.href = '#' + i;
    LI.appendChild(A);
    OL.appendChild(LI);

    var PREF = document.createElement('a');
    PREF.name = i;
    sections[i].appendChild(PREF);
  }

  var done = false;
  function work() {
    if (done) return;
    if ( document.getElementById('toc') === null) return; // no toc element
    document.getElementById('toc').appendChild(OL);
    done = true;
  };

  window.onload = work;
  setTimeout(work,800);
}());
</script>
<footer>
    <p class="is-pulled-right">
    @cympfh / cympfh@gmail.com
    </p>
</footer>
<!--

  HTML として pandoc -B で include する.

  <H2> を列挙してそれらにリンクを貼った toc を id='toc' に埋め込む.
  markdown で書いてるだろうから例として次のような段落を書けばよい.

```
## INDEX
<div id=toc></div>
```

  used in
  - /memo/gnuplot
  - /memo/linux
  - /memo/imagemagick

-->
<script>
(function() {
  var sections = document.getElementsByTagName('h2');
  var i;
  var OL = document.createElement('ol');
  for (i=0; i < sections.length; ++i) {
    var LI = document.createElement('li');
    var A = document.createElement('a');
    A.innerHTML = sections[i].innerHTML;
    if (A.innerHTML.toUpperCase() == 'INDEX') continue;
    A.href = '#' + i;
    LI.appendChild(A);
    OL.appendChild(LI);

    var PREF = document.createElement('a');
    PREF.name = i;
    sections[i].appendChild(PREF);
  }

  var done = false;
  function work() {
    if (done) return;
    if ( document.getElementById('toc') === null) return; // no toc element
    document.getElementById('toc').appendChild(OL);
    done = true;
  };

  window.onload = work;
  setTimeout(work,800);
}());
</script>
</body>
</html>
