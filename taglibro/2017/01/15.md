% Sun Jan 15 22:09:19 JST 2017

## Can't Stop の戦略

考えてみる.

### ルール概要

<iframe width="560" height="315" src="https://www.youtube.com/embed/XxvhDiT-eio" frameborder="0" allowfullscreen></iframe>

- 2-4人ゲーム
- 盤面
    - $i$-th レーンがある
        - $i=2,3,\ldots,11,12$
        - レーンとは $m_i = 13 - 2 \times |i-7|$ 個のマスが一列にならんだもの
            - 端がスタートでもう端がゴール
    - 人数に対応した色の **石** が十分な数ある
    - 3つの **駒** がある
        - **石** ではない
    - 初め盤面には石も駒も置かれてない
- ターン制で手を行う
    - 1人の1ターンは好きなだけ次を繰り返す
        1. 4つのサイコロを振る
        1. 出目を2つと2つに分け、それぞれの和を $m, n$ とする
        1. $m$-th レーンと $n$-th レーンのそれぞれについて、駒をスゴロクの要領で一つ進める
            - **駒を一つ進める** とは次によって定められる手続きのこと
                - そのレーンに既に駒があるなら、それを一マスだけゴール方向に動かす
                    - 既にゴールのマスにあるなら何もしない
                - そのレーンに駒が無く、
                    - 使用していない駒が余っているとき (駒は3つしかないことに註意)、
                        - そのレーンに自分の色の石が置いてある時、その次のマスに駒を置く
                        - 石も置いてないとき、スタートのマスに駒を置く
                    - 駒が余っていないなら「駒を進めることに失敗」
                - ただし後述するが、レーンは使用不可という状態になる場合がある
                    - そのようなレーンについては駒を進めることはできない
                    - これは「駒を進めることに失敗」
            - 上で定めた手続きに於いて **失敗** を定めた
                - $m, n$ のいずれか一方で失敗するとき、成功する方だけ行う
                - $m, n$ の **両方で** 失敗するとき、
                    - バーストと言ってその人のターンは終了する
                    - その際に、その人が進めた駒は盤面から取り除かれる !!
        1. バーストしなかった場合、ターンを自ら終わることが出来る
            - この場合、駒を自分の色の石に置き換え、次の人のターンに移る
                - 駒を置いてたマスに石を置いて、駒を取り除く
            - 終了を選択しないなら、サイコロを振るところから、再び繰り返す
    - 各レーンのゴールのマスに石を置かれた場合、そのレーンはその色の人のものになる
        - 石が置かれた直後からそのレーンは使用不可になる
        - 従ってこれはバーストを誘発する
    - ある一人のプレイヤーが3つのレーンを得るとゲームは終了し、その人の勝利となる

### 出目の確率

サイコロを振る前に私が考えることと言えば

「4個サイコロを振って出目の2個の組み合わせ (和) で $m$ が作れるか?」

ということである.
すなわち、
すでに駒を置いた $m$ のレーンがある場合には、
$m$ を出しさえすればいいのである.
そうすれば何度でもターンが続けられるので、それ以上の戦略は不要に思える.

4個のサイコロ中2個の和で $m$ を作る確率を計算する.

```ruby
# 出目のリスト dices から2つ選んで m を作れるか?
def make?(dices, m)
  dices.combination(2).any? { |a, b| a + b == m }
end

# m-th lane
(2..12).each do |m|
  count = 0
  # 4個のサイコロの出目を全列挙
  (1..6).to_a.repeated_permutation(4) do |a, b, c, d|
    count += 1 if make?([a, b, c, d], m)
  end
  pr = count.to_f / 6 / 6 / 6 / 6
  puts "#{sprintf("%2d", m)} => #{pr}"
end
```

#### 結果

```
 2 => 0.13194444444444445
 3 => 0.2330246913580247
 4 => 0.35570987654320985
 5 => 0.44753086419753085
 6 => 0.5609567901234568
 7 => 0.6435185185185185
 8 => 0.5609567901234568
 9 => 0.44753086419753085
10 => 0.35570987654320985
11 => 0.2330246913580247
12 => 0.13194444444444445
```

大凡予想通りである.

1. $1 \leq m \leq 7$ では単調増加
    - $m \geq 7$ は対称
1. $6,7,8$-th レーンだけが $50$ % を超える
1. 雑な覚え方としては、端から $10, 20, 30, 40, 50, 60, 50, \ldots$ %

$6,7,8$-th の3つのレーンに駒を置いている場合にバーストする確率は、

```
0.06871499254944341
```

すなわち、93%くらいでセーフ.

### 速度

$m$-th レーンを考える.
4つのサイコロを振って駒を進める **1 ステップ** で $m$-th レーン上の駒を平均でどれだけ進められるだろうか?
これを **速度** と呼ぶことにする.
ただし初めにスタートに駒を置くという行為も1マス進めると見なして良いのはいいでしょう.

> N.B. 先ほどの確率は4つの出目の内の2つの和で $m$ を作れるか? しか考慮してないのでここでは使わない.
> 今は残り2つの和でも進めるところまで考慮する.
> すなわち、 $m$ と $m$ を作れるなら2マス進めることが出来るから.

速度を計算するプログラムは次の通り.

```ruby
# 出目のリスト dices から2つ選んで n を作れるか?
def make?(dices, n)
  dices.combination(2).any? { |a, b| a + b == n }
end

# m-th lane
(2..12).each do |m|
  count = 0
  # 4個のサイコロの出目を全列挙
  (1..6).to_a.repeated_permutation(4) do |a, b, c, d|
    sum = [a, b, c, d].inject :+
    if make?([a, b, c, d], m)
      if sum == m + m
        count += 2
      else
        count +=1
      end
    end
  end
  average = count.to_f / 6 / 6 / 6 / 6
  puts "speed(#{sprintf("%2d", m)}) = #{average}"
end
```

#### 結果

```
speed( 2) = 0.13271604938271606
speed( 3) = 0.2376543209876543
speed( 4) = 0.3703703703703704
speed( 5) = 0.4753086419753086
speed( 6) = 0.6080246913580247
speed( 7) = 0.7129629629629629
speed( 8) = 0.6080246913580247
speed( 9) = 0.4753086419753086
speed(10) = 0.3703703703703704
speed(11) = 0.2376543209876543
speed(12) = 0.13271604938271606
```

1. 先ほどの確率と一見似てるがちょい大きくて $m=7$ に近づくほど大きくなる具合が大きい
1. $1 \leq m \leq 7$ では単調増加
    - $m \geq 7$ は対称

速度と、レーンの長さが分かっているので、$m$-th レーンについて、平均で何ステップの試行がゴールに必要かが分かる.

#### 結果

```
steps( 2) = 22.604651162790695
steps( 3) = 21.03896103896104
steps( 4) = 18.9
steps( 5) = 18.935064935064936
steps( 6) = 18.091370558375633
steps( 7) = 18.233766233766236
steps( 8) = 18.091370558375633
steps( 9) = 18.935064935064936
steps(10) = 18.9
steps(11) = 21.03896103896104
steps(12) = 22.604651162790695
```

- 想像以上に、どのレーンであっても、まあまあバランスが取れている
- しかしやっぱり $m=7$ 付近が有利で、端っこに比べて 4 ステップ程度早くゴールできる
- 不思議なことに $m=7$ が最小というわけでもなく
    - $step(6) < step(7) < step(4) < step(5) < step(3) < step(2)$
    - となっている ($m \geq 8$ は対称性があるので)
    - 全然単調じゃない!!

