% Wed May 23 2018

## ゆるキャンのカードゲーム

いつかのGameMarketで買った.
五分位でさくっと終わるので、ついつい何度もプレイしてしまう.
単なる運ゲームだと思っていたが、運要素は確かに大きいが、考える要素が全く無いわけでもなく、面白い.

[『ゆるキャン△』のカードゲーム「ゆるキャン△～どこでもテント張り！～」発売決定！　ニコニコ超会議ほかのイベント会場で先行販売も](https://www.animatetimes.com/news/details.php?id=1523932447)

なんと説明書がこのサイトに載ってあるのでルールがこれで分かってしまう.
要は 0 の数字のカードから 8 の数字のカードまでを 4 枚ずつ用意すればいいだけなので、トランプを 1 セット用意し、10を0と見做して、JQKとジョーカーを抜けば、それで遊べてしまう.

### ルールの要約

カードは 0 から 8 までの数字のカードが4枚ずつ.
加えて、松ぼっくり (ジョーカー) のカードが2枚あるのだが、ここではこれを使わない版のルールを紹介する.
2人以上4人以下で遊ぶが、2人だとつまらないと思う. それに、もしかしたら5人くらいでやっても悪くないかもしれない.

机の上に以下のような $7+6+\cdots+1=56$ 個のセルを用意する.

```
[1,1] [1,2] [1,3] [1,4] [1,5] [1,6] [1,7]
[2,1] [2,2] [2,3] [2,4] [2,5] [2,6]
[3,1] [3,2] [3,3] [3,4] [3,5]
[4,1] [4,2] [4,3] [4,4]
[5,1] [5,2] [5,3]
[6,1] [6,2]
[7,1]
```

セルとはカードがちょうど1枚置けるための場所のこと.
`[n,_]` を綺麗に一列に並べて、
`[n+1,_]` をそのすぐ下に、カード半枚分だけずらして並べることで、ちょうどピラミッドのように並べることが期待されている.

カードをシャッフルし、7枚ランダムに選んで、表にして `[1,1] [1,2] ... [1,7]` に並べる.

残りのカードを、プレイヤーに公平な枚数だけ配って手札とする. 手札は本人しか見ることができない.
手札の枚数は、配れるだけ配り、残った端数は伏せたままゲームから除外する.

プレイヤーに予め順序を決めて、その順に従ってプレイを行ってもらう. 順はループする.
出来るプレイとは次のようなもの.

1. 次のような3つのセルを選び、
    - 既にカードが置かれた `[n, m]`
    - 既にカードが置かれた `[n, m+1]`
    - 未だカードが置かれていない `[n+1, m]`
1. `[n+1,m]` に手札から一枚選んで表にして置く.
    - ただし置いていいカードの数字には制限がある
        - `[n, m] [n, m+1]` にあるカードの数字が `A` `B` のとき
        - `A` と `B` との差、あるいは和
            - ただし、このゲームに於いては 8 よりも大きな数字は 8 と同一視する
        - 例えば 3 と 7 のカードに対して出せるカードは 4 または 8

出せるカードが手札にない場合はプレイに失敗し、そのプレイヤーは脱落となる.
元のルールでは一人が脱落した時点で終わりだったような気もするが、最後の一人が残るまでやっても面白い.

感じとしてはちょうど7並べに近い.

### どのカードが強いか

数字は明らかに対等ではない.
この世界には 8 より大きい数字はすべて 8 であるという強いルールがある.
であるので、和として8が出せるようなパターンが他の数字よりも多い.

簡単化してみる.
0以上8以下の数字のペアは $9\times 9$ 通り.
これが上のルールで言うところの `[n,m] [n,m+1]` に相当するとして、`[n+1,m]` に出せる数字は何であることが多いだろうか?
出せるか出せないかが問題なので、和と差が同じ場合、一通りとして数える.
つまり、例えば、ペア $(1,2)$ については出せる数字は $\{1,3\}$ の2つがある. $1,3$ という数字の「出しやすさ」としてカウントする.
しかし、ペア $(0,2)$ については出せる数字は $\{2\}$ の唯1つしかない. $2$ の「出しやすさ」は1つ分しかカウントしない.

```ruby
# Ruby
xs = []
(0..8).each do |x|
  (0..8).each do |y|
    a = (x - y).abs
    b = [x + y, 8].min
    xs += [a, b].uniq
  end
end

xs.group_by{|x|x}
  .map{|x,g| [x, g.size]}
  .each{|x,s| puts "(card) #{x} => #{s}"}
```

結果は次の通り

```
(card) 0 => 9
(card) 1 => 16
(card) 2 => 15
(card) 3 => 14
(card) 4 => 13
(card) 5 => 12
(card) 6 => 11
(card) 7 => 10
(card) 8 => 45
```

予想通り 8 が最も強い.
次点に強いのが 1 だが、8 の出すやすさの差は激しく、3倍程度違う.
