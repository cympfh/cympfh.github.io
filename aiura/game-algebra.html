<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>ゲームの代数</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">ゲームの代数</h1>
<p><p class=date style='text-align: right'>2017-04-23 (Sun.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#ゲーム理論>ゲーム理論</a> </div> % 代数を定義して諸性質を見ていきます</p>
<h2>index</h2>
<p><div id="toc"></div></p>
<h2>前提</h2>
<p>ここではゲームとは組み合わせゲームを指します. <a href="game-class.html">組み合わせゲームの帰結類</a> に組み合わせゲームの定義と帰結類についてまとめているのでここは読んだことを前提にします.</p>
<h2>ゲームの和 (直和, 選択和)</h2>
<p>2つのゲーム \(G\) , \(H\) の和 \(G+H\) を次のように定める.</p>
<p>\(G\) と \(H\) を横に並べた状態で、 二人がゲーム \(G+H\) をプレイする. 許される手は、 \(G\) または \(H\) のどちらか一方を選択し、 そちらにとって許される手を1度打つ. これを先手と後手とが交互に繰り返す.</p>
<p>\(G\) , \(H\) がともに最終局面の時が \(G+H\) の最終局面である ( \(G=\{\} \land H=\{\} \iff G+H=\{\}\) ). 一方が既に最終局面で、もう一方を最終局面にした (つまり最後の手を打った) 人の勝ちである.</p>
<h3>不偏ゲームの和</h3>
<p>形式的表現での定義を与える. 不偏ゲームの場合、ゲームとは単に選択肢 (ゲーム) の集合である.</p>
<ul>
  <li>\(G+\{\} = G\)</li>
  <li>\(\{\}+H = H\)</li>
  <li>\(G+H = \{ G&#x27;+H : G&#x27; \in G \} \cup \{ G+H&#x27; : H&#x27; \in H \}\)</li>
</ul>
<p>右辺の \(G&#x27;+H\) なんかもゲーム同士の \(+\) であって、ここが再帰的定義になってる.</p>
<p>ところで不偏ゲームは非不偏ゲームはの特別な場合に過ぎないので、非不偏ゲームだけを考える.</p>
<h3>非不偏ゲームの和</h3>
<p>左右を別々に考えるだけで、不偏ゲームの場合と同様である.</p>
<p>\(G = \{\mathcal{G}^L | \mathcal{G}^R\}\) , \(H = \{\mathcal{H}^L | \mathcal{H}^R\}\) について</p>
<ul>
  <li>\(G+\{|\} = G\)</li>
  <li>\(\{|\}+H = H\)</li>
  <li>
    \(G+H = \{ (G+H)^L | (G+H)^R \}\)
    <ul>
      <li>
        where
        <ul>
          <li>\((G+H)^L = \{ G^L + H : G^L \in \mathcal{G}^L \} \cup \{ G + H^L : H^L \in \mathcal{H}^L \}\)</li>
          <li>\((G+H)^R = \{ G^R + H : G^R \in \mathcal{G}^R \} \cup \{ G + H^R : H^R \in \mathcal{H}^R \}\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h3>ゼロ</h3>
<p>最終局面 ( \(\{\}\) または \(\{|\}\) ) をゲーム \(0\) と呼ぶ. これは \(+\) の単位元である.</p>
<h2>ゲームの反転</h2>
<p>左右の立場を入れ替える操作を反転とし、ゲーム \(G\) に対して \(-G\) と表現する.</p>
<p>形式的には左選択肢と右選択肢を入れ替えればよいだけだが、再帰的に反転をシなければならないことに註意. つまり</p>
<ul>
  <li>
    \(-0 = 0\)
    <ul>
      <li>( \(-\{\} = \{\}\) )</li>
    </ul>
  </li>
  <li>\(-G = -\{ \mathcal{G}^L | \mathcal{G}^R \} = \{ -\mathcal{G}^R | -\mathcal{G}^L \}\)</li>
</ul>
<h3>差</h3>
<p>二項演算 \(-\) を反転を使って定義する.</p>
\[G - H = G + (-H)\]
<ul>
  <li>\(-(-G) = G\)</li>
  <li>\(-(G+H) = (-G) + (-H)\)</li>
</ul>
<h2>ゲームの等価性 ( \(=\) , \(\ne\) )</h2>
<p>ゲームの等価性 ( \(=\) ) を次のように定める.</p>
<p><div class="thm"> \(G = H\) とは、 任意のゲーム \(X\) について \(G+X\) と \(H+X\) との帰結類が同じであること </div></p>
<p>これは 「任意の文脈 \(X\) について \(G\) な部分を \(H\) に置き換えてもゲーム全体の勝敗には差支えがない」 ということを言っている. 明らかにこの \(=\) は同値関係を与えている.</p>
<ul>
  <li>\(F=G \land G=H \Rightarrow F=H\)</li>
  <li>\(G=G\)</li>
</ul>
<p>自然に \(\ne\) も定義する.</p>
<h3>定理</h3>
<p><div class="thm"></p>
\[G \in \mathcal{P} \iff G = 0\]
<p></div></p>
<p>後手必勝のゲームに限って 0 と等価である.</p>
<h4>\((\Leftarrow)\) の証明:</h4>
<p>\(G\) が 0 と等価であるとは \(G+X\) が \(0+X\) と同じ帰結類であるということ. \(X=0\) とすると、 \(G+0=G\) と \(0+0=0\) とが同じ帰結類であるということ. \(0\) の帰結類は \(\mathcal{P}\) であるので、 \(G\) の帰結類も \(\mathcal{P}\) .</p>
<h4>\((\Rightarrow)\) の証明:</h4>
<p>任意のゲーム \(X\) について、 \(G+X\) の帰結類が \(0+X=X\) の帰結類と同じであることを示す. ゲームの帰結類は次の 4 ケース</p>
<ol>
  <li>左 が <strong>先</strong> 攻で 右 が後攻のとき、 <strong>左</strong> が必勝</li>
  <li>左 が <strong>先</strong> 攻で 右 が後攻のとき、右 が必勝</li>
  <li>左 が後攻で 右 が先攻のとき、 <strong>左</strong> が必勝</li>
  <li>左 が後攻で 右 が先攻のとき、右 が必勝</li>
</ol>
<p>の組み合わせで決まることは <a href="game-class.html">以前</a> に書いた. この 4 ケースについて、 \(X\) と \(G+X\) とが一致することを言う.</p>
<p>\(X\) が左が先攻で左が勝つ場合 (ケース1)、 \(G+X\) についても先攻で左が勝つ. 具体的には、左はまず \(G+X\) の \(X\) 部分について正しく手を打つ. 右が \(X\) について打つならば正しく応じることで \(X\) について勝てる. \(G\) については左は自分からは打たず、右が打った場合に限って打てばよい. 右が先に打てば \(G\) については右が先攻になる. \(G\) は後攻必勝であるので、左が勝てる. 以上のようにして左は \(G\) についても \(X\) についても勝つので \(G+X\) でも勝つ.</p>
<p>他のケースも同様.</p>
<h3>定理</h3>
<p><div class="thm"></p>
\[G - G = 0\]
<p></div></p>
<p>先の定理を使えば、 \(0\) と等価であることを示すためには、後攻必勝であることを示せばよいことがわかる.</p>
<p>\(G - G = G + (-G)\) は後攻が先攻と同じ手を常に使う <strong>物真似戦略</strong> によって後攻必勝である.</p>
<p>具体的には、先攻が \(H - G\) (または \(G - H\) ) にしたとき、後攻は \(H - H\) にできる. 符号が反転してる方を操作しているからこそ出来ることに註意. これを繰り返すことでいつか \(0 - 0 = 0\) にでき、後攻が勝つ.</p>
<p>これは先攻後攻を逆にした2つのチェス盤を並べて相手が片方に打った手をもう片方に打つことに相当する.</p>
<h3>定理</h3>
<p><div class="thm"></p>
\[G + J = H + J \iff G = H\]
<p></div></p>
<p>当然成り立っていて欲しい性質であるが確かめておく.</p>
<p>\((\Leftarrow)\) だけを示す. 逆もほぼ同様であるので.</p>
<p>\(G=H\) を仮定する. 任意の \(X\) で \(G+X\) , \(H+X\) の帰結類が同じ. \(X=J+X&#x27;\) とすれば、 \(G+J+X&#x27;\) , \(H+J+X&#x27;\) の帰結類が同じ. これは任意の \(X&#x27;\) について \(X\) を \(J+X&#x27;\) とすることで言える. というわけで \(G+J=H+J\) .</p>
<h3>系</h3>
<p><div class="thm"></p>
\[G=G&#x27; \land H=H&#x27; \Rightarrow G+H = G&#x27;+H&#x27;\]
<p></div></p>
<p>先の定理を使う.</p>
<h2>半順序 ( \(\geq, &gt;, \|, \rhd, \unrhd\) )</h2>
<p>任意の文脈 \(X\) で部分 \(G\) を \(H\) に置き換えても左にとっては差し支えないようなときを \(H \geq G\) という. 或いは「ゲーム \(H\) は左にとってゲーム \(G\) よりも有利である」とも言える.</p>
<ul>
  <li>\(G \geq H\) とは、任意の \(X\) について、 \(H+X\) が左が勝つとき、 \(G+X\) も左が勝つ</li>
  <li>\(G \leq H\) とは、任意の \(X\) について、 \(H+X\) が右が勝つとき、 \(G+X\) も右が勝つ</li>
</ul>
<p>以上を組み合わせて自然に次の比較演算子を定義する.</p>
<ul>
  <li>\(G~\|~H \iff \lnot(G\geq H) \land \lnot(G \leq H)\) (比較不能)</li>
  <li>\(G &gt; H \iff (G \geq H) \land (G \ne H)\)</li>
  <li>\(G \rhd H \iff (G &gt; H) \lor (G~\|~H)\)</li>
  <li>\(G \unrhd H \iff (G \geq H) \lor (G~\|~H)\)</li>
</ul>
<h3>性質</h3>
<ul>
  <li>\(G \geq H \iff H \leq G\)</li>
  <li>\(G \geq H \land G \leq H \iff G = H\)</li>
</ul>
<h3>定理</h3>
<p><div class="thm"></p>
\[G + J \geq H + J \iff G \geq J\]
<p></div></p>
<p>証明は \(=\) のときと同様.</p>
<h3>系</h3>
<p><div class="thm"></p>
\[G \geq H \iff G - H \geq 0\]
<p></div></p>
<p>先の定理で \(J=-H\) とすると得られる.</p>
<h3>半順序つきの群</h3>
<p>以上から、ゲーム全体は、 <strong>可換群</strong> であって <strong>半順序</strong> の構造を入れることができる.</p>
<h3>帰結類</h3>
<ul>
  <li>\(G &gt; 0 \iff G \in \mathcal{L}\) (左必勝)</li>
  <li>\(G = 0 \iff G \in \mathcal{P}\) (後手必勝)</li>
  <li>\(G &lt; 0 \iff G \in \mathcal{R}\) (右必勝)</li>
  <li>\(G~\|~0 \iff G \in \mathcal{N}\) (先手必勝)</li>
</ul>
<h2>ゲームの標準形</h2>
<p>全てのゲーム \(G\) について、それと等しい \(G=H\) となるような最小のゲーム \(H\) が存在し、 これを \(G\) の <strong>標準形</strong> という. \(G\) からそれの標準形を求めるための具体的な手順として <strong>片手枷原理</strong> と <strong>打ち消し原理</strong> という2つの簡約原理を考える.</p>
<h3>片手枷原理 (One-hand-tied)</h3>
<p>明らかにある手が、別な手に比べて劣位な場合、そのような手は初めから考える必要がない、という原理. 具体的には、</p>
\[G=\{A,B,C,\ldots | H,I,J,\ldots\}\]
<p>の左選択肢について \(B \geq A\) ならば</p>
\[G = \{B,C,\ldots | H,I,J,\ldots\}.\]
<p>としてよい. 同様に右選択肢についても \(I \geq J\) ならば</p>
\[G = \{A,B,C,\ldots | H,J,\ldots\}.\]
<p>であると考えてよい.</p>
<p>念の為に次を証明しておく</p>
<p><div class=thm> \(B \geq A\) のとき</p>
<ul>
  <li>\(G = \{A,B,C,\ldots | H,I,J,\ldots\}\)</li>
  <li>\(G&#x27;= \{B,C,\ldots | H,I,J,\ldots\}\)</li>
</ul>
<p>に関して \(G=G&#x27;\) である. </div></p>
<p>\(G-G&#x27;=0\) すなわち \(G-G&#x27;\) が後手必勝であることを示せば良い.</p>
<p>先手が \(A\) 以外の選択肢を \(G, G&#x27;\) の中から選んだ場合、 後手はもう一方から同じ選択肢を選べる. \(G\) と \(G&#x27;\) の符号が逆転してるので左右が同じ選択肢を選べることに注意.</p>
<p>例えば左の先手が \(G\) から \(B\) を選んだ場合、右の後手は \(G&#x27;\) から \(B\) を選ぶことができる.</p>
\[G - G&#x27; \to B - G&#x27; \to B - B = 0\]
<p>こうするとゲームは \(0\) に出来、後手必勝のゲームになることがわかる. 従って後手が勝つ.</p>
<p>次に、左の先手が \(G\) から \(A\) を選択する場合、 後手は \(G&#x27;\) から \(B\) を選択すればよい. するとゲームは \(A - B\) になるわけだが、仮定から</p>
\[A - B \leq 0.\]
<p>なので、ゲームは後手または右必勝.</p>
<p>以上から \(G-G&#x27;\) は後手必勝. 従って \(G = G&#x27;\) が得られた.</p>
<h3>打ち消し可能</h3>
<p>ゲーム \(G\) の左選択肢 \(A \in \mathcal{G}^L\) のその右選択肢に左にとって元のゲーム \(G\) よりも状況が悪くなるような右の応手 \(A^R\) があるとする. つまり、</p>
\[G \geq A^R\]
<p>のとき、 \(A^R\) を \(A\) を打ち消す (reverse) 手であるという. 逆に \(A\) を打ち消し可能な手だと言う.</p>
<p>打ち消し可能な手 \(A\) が選択肢にある場合、 \(A^R\) で即座に打ち消される. ゲームの状況は一般にはより悪くなっているのだから、 \(A\) を選択する以上、さらに \(A^R\) について何か \((A^R)^L\) で応じるつもりでいなければならない. これは即座に選択するべきで、そうでないなら初めから \(A\) を選択してはいけない.</p>
<p>以上のように</p>
\[G \to A \to A^R \to (A^R)^L\]
<p>は間に他の手を挟まずに速やかに実行される.</p>
<p>ならば初めから、 \(A\) という選択肢を \((A^R)^L\) で置き換えておいてもゲームは等価である、というのが <strong>打ち消し原理</strong> である.</p>
<p>ただし \((A^R)^L\) は一つとは限らないので、選択肢 \(A\) を消して、 左選択肢の集合を結合することになる.</p>
<ul>
  <li>\(G = \{ \mathcal{G}^L | \mathcal{G}^R \}\)</li>
  <li>
    \(G&#x27; = \{ \mathcal{G}^L \setminus \{A\} \cup \mathcal{W} | \mathcal{G}^R \}\)
    <ul>
      <li>\(I = \{ B : B \in \mathcal{G}^L\) , \(B \leq G \}\)</li>
      <li>\(\mathcal{W} = \bigcup_I \mathcal{B}^L\)</li>
    </ul>
  </li>
</ul>
<p>について \(G=G&#x27;\) が成立する.</p>
<blockquote>今更だけど記号について. <br /> ゲームを単にアルファベット (e.g. \(A, B, G\) ) と書いている. <br /> その選択肢として、右肩に \(L, R\) を載せたのは単に選択肢の中の一つ (代表) のこと (e.g. \(A^L, B^R, G^L\) ). <br /> 選択肢 <strong>全体</strong> (つまり集合) を表すのに、アルファベットをまず script alphabet にしてから右肩に \(L, R\) を載せて表していている (e.g. \(\mathcal{A}^L, \mathcal{B}^R, \mathcal{G}^L\) ). <br /> ( \(G^L \in \mathcal{G}^L, G^R \in \mathcal{G}^R\) .)</blockquote>
<h3>標準形</h3>
<p>ゲーム \(G\) が <strong>標準形 (canonical form)</strong> であるとは、 \(G\) 及び \(G\) から到達可能な全局面において、 片手枷原理で言及したような <strong>劣位な手</strong> が存在せず、また <strong>打ち消し可能な手</strong> も存在しないこと.</p>
<h4>定理</h4>
<p>\(G, H\) が共に標準形で \(G=H\) の場合、 集合 (あるいはゲーム木) として \(G \simeq H\) .</p>
<p>すなわち同型を除いて標準形は一意.</p>
<h2>誘因 (incentives)</h2>
<p>ゲーム \(G\) に対して左選択肢 \(\mathcal{G}^L\) から \(G\) を引いた 集合 \(\mathcal{G}^L \setminus G\) を左誘因という. 同様に \(G \setminus \mathcal{G}^R\) を右誘因という.</p>
<p>あるいは \(G^L \in \mathcal{G}^L\) について ゲーム \(G^L - G\) を左誘因とも言う. 同様に \(G - G^R\) を右誘因という.</p>
<p>意味としては、左にとっては左誘因が正である選択をすべき、右にとっては右誘因が正である選択をすべき (このためにマイナスが逆) で、 後述する「ゲームの値」を使うと、差が最大となる選択をすべきことが分かる.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>