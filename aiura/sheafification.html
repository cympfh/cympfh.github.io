<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="Def. 前層、層/諸定義/Def. 中間層/前層から中間層への誘導/誘導されたそれが中間層であることの確認/中間層から層への誘導/誘導されたそれが層であることの確認/" />
  <meta property="og:url" content="http://cympfh.cc/taglibro">
  <meta property="og:type" content="article">
  <meta property="og:title" content="層化 (sheafification)" />
  <meta property="og:description" content="Def. 前層、層/諸定義/Def. 中間層/前層から中間層への誘導/誘導されたそれが中間層であることの確認/中間層から層への誘導/誘導されたそれが層であることの確認/" />
  <meta property="og:image" content="http://cympfh.cc/resources/img/identicon.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@cympfh" />
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>層化 (sheafification)</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>
<header>
<h1 class="title">層化 (sheafification)</h1>
</header>
<p class="date" style="text-align: right">
2018-04-22 (Sun.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#層>層</a></p>
</div>
<p>位相空間 <span class="math inline">\(X\)</span> の上の前層について考える. 前層があるとき、以下のステップを踏むことでまず中間層に誘導し、さらにそれを層に誘導できる. この手続きを層化という.</p>
<ol type="1">
<li><a href="#step1">前層・層の定義</a></li>
<li><a href="#step2">諸定義</a></li>
<li><a href="#step3">中間層の定義</a></li>
<li><a href="#step4">前層から中間層への誘導</a></li>
<li><a href="#step5">誘導されたそれが中間層であることの確認</a></li>
<li><a href="#step6">中間層から層への誘導</a></li>
<li><a href="#step7">誘導されたそれが層であることの確認</a></li>
</ol>
<p><a name="step1"></a></p>
<h2 id="def.-前層層">Def. 前層、層</h2>
<p><a href="sheaf.html">前記事</a> に書いた.</p>
<p><a name="step2"></a></p>
<h2 id="諸定義">諸定義</h2>
<p>層 <span class="math inline">\(A\)</span> の2元 <span class="math inline">\(f,g\)</span> について <span class="math display">\[[f=g] := \bigcup \{ U : f \rceil U = g \rceil U \}\]</span> と定める. <span class="math inline">\(U\)</span> についての和を取っていることに註意. 特に <span class="math inline">\([f=f] = X\)</span> (全体) である.</p>
<p>2元 <span class="math inline">\(f,g\)</span> が互いのドメインで制限したときに等しいことを「両立している」と表現する. すなわち <span class="math display">\[f \rceil Eg = g \rceil Ef\]</span> のことである.</p>
<p><a name="step3"></a></p>
<h2 id="def.-中間層">Def. 中間層</h2>
<p>前層 <span class="math inline">\(A\)</span> について <span class="math display">\[\forall f,g \in A, Ef \cap Eg \subseteq [f=g] \implies f\rceil Eg=g\rceil Ef\]</span> が成立するものを中間層と言う. (逆は一般の前層で成立する.)</p>
<p><a name="step4"></a></p>
<h2 id="前層から中間層への誘導">前層から中間層への誘導</h2>
<p>前層 <span class="math inline">\(A\)</span> に次の同値関係を入れる. <span class="math display">\[f \equiv g \iff Ef=Eg \subseteq [f=g]\]</span> これで割って <span class="math display">\[\begin{align*}
\hat{A} = A/\!\!\equiv \\
\varphi : A \to \hat{A} \\
E \varphi(f) = Ef \\
\varphi(f) \rceil U = \varphi( f \rceil U)
\end{align*}\]</span> とする. この <span class="math inline">\(\hat{A}\)</span> が中間層になっている.</p>
<p><a name="step5"></a></p>
<h2 id="誘導されたそれが中間層であることの確認">誘導されたそれが中間層であることの確認</h2>
<p>前層であることまでは自明だとして、中間層としての条件が満たされてることだけ確認する.</p>
<p>すなわち、任意の2元 <span class="math inline">\(f,g \in A\)</span> に対する <span class="math inline">\(\varphi(f), \varphi(g) \in \hat{A}\)</span> について <span class="math display">\[E\varphi(f) \cap E\varphi(g) \subseteq [\varphi(f)=\varphi(g)] \implies \varphi(f)\rceil E\varphi(g)=\varphi(g)\rceil E\varphi(f)\]</span> であることを確認する.</p>
<p>この式は <span class="math inline">\(E\varphi\)</span> と <span class="math inline">\(\varphi \rceil\)</span> の定義から <span class="math display">\[Ef \cap Eg \subseteq [\varphi(f)=\varphi(g)] \implies \varphi(f\rceil Eg)=\varphi(g\rceil Ef)\]</span> と書き直せる.</p>
<p>さらに <span class="math inline">\(\implies\)</span> から見て右辺は <span class="math inline">\(\varphi\)</span> のイコールなので同値関係のことを言っている. <span class="math display">\[\begin{align*}
     &amp; \varphi(f\rceil Eg)=\varphi(g\rceil Ef) \\
\iff &amp; f\rceil Eg \equiv g\rceil Ef \\
\iff &amp; E(f\rceil Eg) = E(g\rceil Ef) \land E(g \rceil Ef) \subseteq [f \rceil Eg=g \rceil Ef] \\
\iff &amp; Ef \cap Eg \subseteq [f \rceil Eg=g \rceil Ef] \\
\end{align*}\]</span> と書き直せる.</p>
改めて示したい式を書き直すと
<div class="thm">
<p><span class="math display">\[
Ef \cap Eg \subseteq [\varphi(f)=\varphi(g)]
\implies
Ef \cap Eg \subseteq [f \rceil Eg=g \rceil Ef]
\]</span></p>
</div>
<p>となる.</p>
<p>背理法で示す. 右辺が <span class="math inline">\(\not\subseteq\)</span> だとすると、 <span class="math display">\[\exists x \in Ef \cap Eg, x \not\in [f \rceil Eg=g \rceil Ef]\]</span> という点 <span class="math inline">\(x \in X\)</span> があるはずである. <span class="math inline">\([- = -]\)</span> の定義まで戻れば、そのような点 <span class="math inline">\(x\)</span> に対して</p>
<p><span class="math display">\[\forall U (x \in U), f \rceil Eg \rceil U \ne g \rceil Ef \rceil U\]</span> である. さらに <span class="math inline">\(U \subseteq Ef \cap Eg\)</span> となるように小さいものに限ると右辺がすっきりして <span class="math display">\[\forall U (x \in U \subseteq Ef \cap Eg), f\rceil U \ne g\rceil U\]</span> と言える.</p>
<p>さて <span class="math inline">\(\implies\)</span> より左辺について. 今の点 <span class="math inline">\(x\)</span> がやはり <span class="math inline">\([\varphi(f) = \varphi(g)]\)</span> に含まれないために <span class="math inline">\(\not\subseteq\)</span> であることを示す.</p>
<p>とりあえず <span class="math inline">\([-=-]\)</span> を展開してく. <span class="math display">\[\begin{align*}
[\varphi(f) = \varphi(g)]
&amp; = \bigcup \{ U : \varphi(f) \rceil U = \varphi(g) \rceil U \} \\
&amp; = \bigcup \{ U : f \rceil U \equiv g \rceil U \} \\
&amp; = \bigcup \{ U : Ef \cap U=Eg \cap U \land Ef \cap U \subseteq [f\rceil U=g\rceil U] \}
\end{align*}\]</span></p>
<p>ある <span class="math inline">\(U\)</span> で <span class="math inline">\(x \in U\)</span> かつ <span class="math inline">\(Ef\cap U=Eg\cap U\)</span> だとする. このとき、いつも <span class="math display">\[Ef \cap U \not\subset [ f \rceil U = g \rceil U ]\]</span> である. なぜなら <span class="math display">\[Ef \cap U \subset [ f \rceil U = g \rceil U ]\]</span> であるとすると (背理法)、 <span class="math inline">\(x \in Ef \cap U\)</span> なので <span class="math display">\[\begin{align*}
x &amp; \in [ f \rceil U = g \rceil U ] \\
  &amp; =   \bigcup \{ V : f \rceil U \rceil V = g \rceil U \rceil V \} \\
  \iff &amp; \exists V, x \in V \land f \rceil U \rceil V = g \rceil U \rceil V \\
  \iff &amp; \exists V, x \in V \land f \rceil (U \cap V) = g \rceil (U \cap V)
\end{align*}\]</span> 最後の <span class="math inline">\((U \cap V)\)</span> に対してさらに <span class="math inline">\((U \cap V) \cap (Ef \cap Eg)\)</span> を <span class="math inline">\(W\)</span> とすれば <span class="math inline">\(x \in W \subseteq Ef \cap Eg\)</span> に対して <span class="math inline">\(f \rceil W = g \rceil W\)</span> となってしまう.</p>
<p>したがって、 <span class="math inline">\([\varphi(f) = \varphi(g)]\)</span> は点 <span class="math inline">\(x\)</span> が含まない. というわけで <span class="math display">\[
Ef \cap Eg \not\subseteq [\varphi(f)=\varphi(g)]
\]</span> である.</p>
<p>以上から対偶が示されたので順も示された.</p>
<p>というわけで、 <span class="math inline">\(\hat{A}\)</span> は中間層である. (背理法の中で更に背理法を使ってしまった.)</p>
<p><a name="step6"></a></p>
<h2 id="中間層から層への誘導">中間層から層への誘導</h2>
<p>中間層 <span class="math inline">\(A\)</span> があるとき、 <span class="math display">\[\mathcal{F} = \{ F \subseteq A | F \text{の2元は両立} \}\]</span> を定める. この上に関数 <span class="math inline">\(E, \rceil\)</span> を次のように定める.</p>
<ul>
<li><span class="math inline">\(EF = \bigcup_{f \in F} Ef\)</span></li>
<li><span class="math inline">\(F \rceil U = \{ f \rceil U | f \in F\}\)</span></li>
</ul>
<p><span class="math inline">\(\mathcal F\)</span> が層であるかなどは見ないが <span class="math inline">\(E(F \rceil U) = EF \cap U\)</span> などは成り立つ.</p>
<p><span class="math inline">\(\mathcal F\)</span> 上に同値関係を次のように定める.</p>
<p><span class="math inline">\(F_1, F_2 \in \mathcal F\)</span> について <span class="math display">\[F_1 \equiv F_2
\iff
EF_1 = EF_2
\land
F_1 \cup F_2 \in \mathcal F\]</span></p>
<p><span class="math inline">\(\mathcal F\)</span> の定義ゆえ、 <span class="math inline">\(F_1 \cup F_2 \in \mathcal F\)</span> とは、<span class="math inline">\(F_1\)</span> の任意の元と <span class="math inline">\(F_2\)</span> の任意の元とが両立することであることに註意.</p>
<p>また中間層故、この <span class="math inline">\(\equiv\)</span> は確かに同値関係になる.</p>
<p>以上から <span class="math inline">\(\def\FS{\mathcal F\!/\!\!\equiv}\FS\)</span> が定まる. <span class="math inline">\(\varphi\)</span> を商を取る関数 <span class="math display">\[\varphi : \mathcal F \to \FS\]</span> とする.</p>
<p><span class="math inline">\(\FS\)</span> 上の <span class="math inline">\(E, \rceil\)</span> は <span class="math inline">\(\varphi\)</span> によって自然に導かれる. すなわち、</p>
<ul>
<li><span class="math inline">\(E(\varphi F) = \bigcup_{f \in F} Ef\)</span></li>
<li><span class="math inline">\((\varphi F) \rceil U = \varphi (F \rceil U)\)</span></li>
</ul>
<p>このとき <span class="math inline">\(\langle \FS, E, \rceil \rangle\)</span> は層となる.</p>
<p><a name="step7"></a></p>
<h2 id="誘導されたそれが層であることの確認">誘導されたそれが層であることの確認</h2>
<p>中間層 <span class="math inline">\(A\)</span> から誘導して得た <span class="math inline">\(\langle \FS, E, \rceil \rangle\)</span> が層であることを確認する.</p>
<p>まず前層であることを簡単に見ていって、加えて、層であることを確認する</p>
<h3 id="notations">notations</h3>
<p>主に <span class="math inline">\(\varphi\)</span> を省略したいので、紛らわしくない限り次の略記法を用いる.</p>
<p><span class="math inline">\(F \in \mathcal F\)</span> について <span class="math display">\[E(\varphi F) = EF = \bigcup_f Ef\]</span> であるので、 <span class="math inline">\(E(\varphi F)\)</span> を単に <span class="math inline">\(EF\)</span> と書く.</p>
<p><span class="math inline">\(\varphi\)</span> の切断を <span class="math inline">\(\psi\)</span> とする. ここで切断とは <span class="math display">\[\forall F \in \FS,~ \varphi (\psi F) = F\]</span> となるような <span class="math inline">\(\psi : \FS \to \mathcal F\)</span> のこと. つまり、代表元を1つ取ってくるような関数のこと.</p>
<h3 id="前層であることの確認">前層であることの確認</h3>
<p>前層の公理を満たすことを実際に確かめる</p>
<ol type="1">
<li><span class="math inline">\(\forall F \in \mathcal F, (\varphi F) \rceil \emptyset = \{ \ast \}\)</span>
<ul>
<li>ただしここで <span class="math inline">\(f \in A, f \rceil \emptyset = \ast\)</span> とした</li>
</ul></li>
<li><span class="math inline">\((\varphi F) \rceil EF = \varphi \{ f \rceil EF | f \in F \} = \varphi \{ f | f \in F \} = \varphi F\)</span></li>
<li><span class="math inline">\(E(F \rceil U) = \bigcup_f E(f \rceil U) = \bigcup_f (Ef \cap U) = \bigcup_f Ef \cap U = EF \cap U\)</span></li>
<li><span class="math inline">\((F \rceil U) \rceil V = \{f \rceil U | f \in F\}=\{f \rceil U \cap V | f \in F\}=F \rceil (U \cap V)\)</span></li>
</ol>
<p>以上から前層であることが確かめられた.</p>
<h3 id="層であることの確認">層であることの確認</h3>
<p>前層であることは確かめたので、次を確かめればよい.</p>
<blockquote>
<p>任意の <span class="math inline">\(\mathcal G \subseteq \mathcal F\)</span> について、 <span class="math inline">\(\mathcal G/\!\equiv\)</span> の任意の2元が両立するならば、 唯一の和 <span class="math display">\[\bigcup \mathcal G\]</span> が存在する.</p>
</blockquote>
<p>まず、和として満たすべき性質を満たす集合が作れること (存在性) を示す. 次に、その存在が唯一なものであること (唯一性) を示す.</p>
<h4 id="存在性">1. 存在性</h4>
<p><span class="math display">\[\bar{G} = \varphi \left( \bigcup_{G \in \mathcal G} G \right)\]</span> これが和としての性質を満たすことを確かめる. 和としての性質とは次の2つである.</p>
<ol type="1">
<li><span class="math inline">\(E\bar{G} = \bigcup_{G \in \mathcal G/\!\equiv} EG\)</span></li>
<li><span class="math inline">\(G \in \mathcal G/\!\equiv \implies \bar{G} \rceil EG = G\)</span></li>
</ol>
<p>確認する. 1つ目は <span class="math inline">\(\bar{G}\)</span> の作り方から明らか.</p>
<p>2つ目. <span class="math inline">\(\varphi G_0 \in \mathcal G/\!\equiv\)</span> について、 <span class="math display">\[\begin{align*}
\bar{G} \rceil EG_0
&amp; = \varphi \left( \bigcup_{G \in \mathcal G} G \right) \rceil EG_0 \\
&amp; = \varphi \left(
    \{ g \rceil EG_0 | G \in \mathcal G, g \in G \}
\right) ~~~\text{ ...$E$ の定義より} \\
&amp; = \varphi \left(
    \bigcup_{G \in \mathcal G} (G \rceil EG_0)
\right) ~~~\text{ ...$G$ ごとにまとめた} \\
&amp; = \varphi \left(
    \bigcup_{G \in \mathcal G} (G_0 \rceil EG)
\right) ~~~\text{ ...$\varphi G$ と $\varphi G_0$ は両立してるので (ただしそんなに自明ではない)} \\
&amp; = \varphi \left(
    G_0 \cup \bigcup_{G \ne G_0} (G_0 \rceil EG)
\right) ~~~\text{ ...後の説明の便宜上 $G=G_0$ の場合とそれ以外とに分けた} \\
&amp; = \varphi G_1 \text{ とおく}
\end{align*}\]</span></p>
<p>示したいのは <span class="math inline">\(\varphi G_0 = \varphi G_1\)</span> であること. すなわち <span class="math display">\[G_0 \equiv G_1\]</span> であること. <span class="math inline">\(\equiv\)</span> であることを示すには次の2つを見れば良いのだった.</p>
<ol type="i">
<li><span class="math inline">\(EG_0 = EG_1\)</span></li>
<li><span class="math inline">\(G_0 \cup G_1 \in \mathcal F\)</span></li>
</ol>
<h5 id="i.">i.</h5>
<p><span class="math display">\[\begin{align*}
EG_1
&amp; = E\left( G_0 \cup \bigcup_{G \ne G_0} (G_0 \rceil EG) \right) \\
&amp; = EG_0 \cup \bigcup_{G \ne G_0} E(G_0 \rceil EG) \\
&amp; = EG_0 \cup \bigcup_{G \ne G_0} (EG_0 \cap EG) \\
&amp; = EG_0
    ~~~\text{... $EG_0 \supseteq (EG_0 \cap EG)$ より}
\end{align*}\]</span></p>
<h5 id="ii.">ii.</h5>
<p><span class="math display">\[\begin{align*}
G_0 \cup G_1
&amp; = G_0 \cup \left( G_0 \cup \bigcup_{G \ne G_0} (G_0 \rceil EG) \right) \\
&amp; = \left( G_0 \cup \bigcup_{G \ne G_0} (G_0 \rceil EG) \right) \\
&amp; = G_1
\end{align*}\]</span></p>
<p>というわけで <span class="math inline">\(G_0 \cup G_1 = G_1\)</span> なので <span class="math inline">\(G_1 \in \mathcal F\)</span> であることを確かめればよい. <span class="math display">\[\varphi G_1 = \varphi \left(
    \bigcup_{G \in \mathcal G} \psi(G_0 \rceil EG)
\right)\]</span> であったことを思い出すと、 2元 <span class="math inline">\(f, g \in G_1\)</span> は</p>
<ul>
<li><span class="math inline">\(\exists F \in \mathcal{G}, f \in (G_0 \rceil EF)\)</span></li>
<li><span class="math inline">\(\exists G \in \mathcal{G}, g \in (G_0 \rceil EG)\)</span></li>
</ul>
<p>と書ける. <span class="math inline">\((G_0 \rceil EF)\)</span> などは単なる集合なので更に次のように書き換えられる.</p>
<ul>
<li><span class="math inline">\(\exists F \in \mathcal{G}, \exists f&#39; \in G_0,~ f = f&#39; \rceil EF\)</span></li>
<li><span class="math inline">\(\exists G \in \mathcal{G}, \exists g&#39; \in G_0,~ g = g&#39; \rceil EG\)</span></li>
</ul>
<p>このときに <span class="math inline">\(f, g\)</span> が両立していることを見たい. ここで <span class="math inline">\(f&#39;, g&#39;\)</span> は <span class="math inline">\(G_0\)</span> の元であって <span class="math inline">\(G_0\)</span> は <span class="math inline">\(\mathcal F\)</span> の元である. <span class="math inline">\(\mathcal F\)</span> の作り方を思い出すと、 <span class="math inline">\(f&#39;, g&#39;\)</span> は両立しているのだった. これを利用する.</p>
<p><span class="math display">\[\begin{align*}
f \rceil Eg
&amp; = (f&#39; \rceil EF) \rceil Eg \\
&amp; = (f&#39; \rceil EF) \rceil Eg&#39; \rceil EG \\
&amp; = (g&#39; \rceil Ef&#39;) \rceil EF \rceil EG ~~~\text{... 両立性より} \\
&amp; = g \rceil Ef&#39; \rceil EF ~~~\text{... 戻していく} \\
&amp; = g \rceil Ef
\end{align*}\]</span></p>
<p>というわけで <span class="math inline">\(f, g\)</span> は両立している. というわけで <span class="math inline">\(G_0 \cup G_1 = G_1\)</span> の任意の2元はつねに両立している. なので <span class="math inline">\(G_0 \cup G_1 \in \mathcal F\)</span> である.</p>
<p>以上 i. ii. より、<span class="math inline">\(\varphi G_0 = \varphi G_1\)</span> である.</p>
<p>以上より <span class="math inline">\(\bar{G}\)</span> は和としての性質を満たしている.</p>
<h4 id="唯一性">2. 唯一性</h4>
<p>他に和としての性質を満たす <span class="math display">\[\varphi H \in \FS\]</span> があるとする. このとき <span class="math display">\[\varphi H = \bar{G}\]</span> であることを示すことで、和が唯一であって <span class="math display">\[\bigcup \mathcal G = \FS\]</span> であることが証明できたことになる.</p>
<p>やっていく.</p>
<h5 id="i.-1">i.</h5>
<p>どちらも和としての性質を満たすことを仮定しているので <span class="math display">\[EH = \bigcup EG = E \bar{G}\]</span></p>
<h5 id="ii.-1">ii.</h5>
<p><span class="math inline">\(H \cup \psi \bar{G} = H \cup \bigcup_{G \in \mathcal G} G\)</span> の任意の2元が両立することを見る.</p>
<h6 id="section">1.</h6>
<p><span class="math inline">\(g_1, g_2 \in \bigcup_{G \in \mathcal G} G\)</span> が両立することは、 <span class="math inline">\(\bar{G}\)</span> が和の性質を満たすことを示すときに、さっき示した.</p>
<h6 id="section-1">2.</h6>
<p><span class="math inline">\(h_1, h_2 \in H\)</span> が両立すること. これは <span class="math inline">\(H \in \mathcal F\)</span> であることから自明.</p>
<h6 id="section-2">3.</h6>
<p>というわけで本題は、</p>
<blockquote>
<p><span class="math inline">\(g \in \bigcup_{G \in \mathcal G} G\)</span> と <span class="math inline">\(h \in H\)</span> とが両立すること.</p>
</blockquote>
<p><span class="math inline">\(g\)</span> についてはある <span class="math inline">\(G \in \mathcal G\)</span> があって <span class="math inline">\(g \in G \in \mathcal G\)</span> である.</p>
<p><span class="math inline">\(H\)</span> は <span class="math inline">\(\mathcal G\)</span> の和なので、そのような <span class="math inline">\(G\)</span> を用いて、 <span class="math display">\[H \rceil EG = G\]</span> となる. 左辺は <span class="math display">\[\{ h&#39; \rceil EG | h&#39; \in H \}\]</span> なので、<span class="math inline">\(h\)</span> について <span class="math inline">\(h \rceil EG\)</span> という値は、<span class="math inline">\(H \rceil EG\)</span> に属する. 従って <span class="math inline">\(G\)</span> にも属する. というわけで、 <span class="math display">\[\exists g&#39; \in G,~ h \rceil EG = g&#39;\]</span></p>
<p>まずこの式の両辺の <span class="math inline">\(E\)</span> の値を取ることで <span class="math display">\[Eh \cap EG = Eg&#39;\]</span> を得る.</p>
<p>また両辺に <span class="math inline">\(\rceil Eg\)</span> を掛けることで <span class="math display">\[\begin{align*}
h \rceil Eg
&amp; = h \rceil EG \rceil Eg ~~~\text{... $Eg \subset EG$ なので} \\
&amp; = g&#39; \rceil Eg \\
&amp; = g \rceil Eg&#39; ~~~\text{... $G$ の2元は両立してる} \\
&amp; = g \rceil (Eh \cap EG) ~~~\text{... すぐ上で求めた値を代入した} \\
&amp; = (g \rceil EG) \rceil Eh
&amp; = g \rceil Eh
\end{align*}\]</span> というわけで <span class="math inline">\(h \rceil Eg = g \rceil Eh\)</span> が得られ、 <span class="math inline">\(g, h\)</span> も無事両立している.</p>
<p>というわけで <span class="math inline">\(H \cap \psi \bar{G}\)</span> の2元はいつも両立している.</p>
<p>というわけで <span class="math display">\[\varphi H = \bar{G}\]</span> が得られた!!</p>
<p>以上.</p>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
