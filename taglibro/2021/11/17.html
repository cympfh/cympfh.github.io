<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="description" content="商集合, 商群" />
  <meta property="og:url" content="http://cympfh.cc/taglibro">
  <meta property="og:title" content="Wed Nov 17 2021" />
  <meta property="og:description" content="商集合, 商群" />
  <meta property="og:image" content="http://cympfh.cc/resources/img/identicon.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@cympfh" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Wed Nov 17 2021</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../../resources/css/c.css" />
  <link rel="stylesheet" href="../../../resources/css/c.css" />
  <link rel="stylesheet" href="../../../resources/css/youtube.css" />
  <link rel="stylesheet" href="../../../resources/css/web_emb.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
  <div class="taglibro">
<header class="page-header">
    <a href='../../index.html'><i class="fas fa-fast-backward"></i></a>
</header>
<header>
<h1 class="title">Wed Nov 17 2021</h1>
</header>
<p><span class="math inline">\(\def\slice#1#2{#1/\!#2}\def\ker#1{\mathop{\mathrm{Ker}}{#1}}\)</span></p>
<h2 id="商集合">商集合</h2>
<p>集合 <span class="math inline">\(A\)</span> があるとき, この上に同値関係 <span class="math inline">\(\sim\)</span> を入れる. このとき <strong>商集合</strong> <span class="math inline">\(\slice A \sim\)</span> なる集合が次の通り定めることができる.</p>
<p><span class="math display">\[\slice A \sim ~ = \{ [a] \mid a \in A \}\]</span> <span class="math display">\[\text{ where } a \sim a&#39; ~( \in A) \iff [a] = [a&#39;] ~ (\in \slice A \sim)\]</span></p>
<p><span class="math inline">\(\slice A \sim\)</span> でのイコールの意味を <span class="math inline">\(\sim\)</span> が与えている. ここで <span class="math inline">\(a \in A\)</span> と区別する意味で <span class="math inline">\([a]\)</span> と書いてこれを新しく作った集合の元としているが, <span class="math inline">\([~]\)</span> 自体を写像だと思える.</p>
<p><span class="math display">\[[~] \colon A \to \slice A \sim\]</span> <span class="math display">\[a \mapsto [a]\]</span></p>
<p>しかも商集合の作り方から当たり前であるが, 全射になっている. つまり,</p>
<ul>
<li>任意に取ってきた <span class="math inline">\(m \in \slice A \sim\)</span> に対して,
<ul>
<li>ある <span class="math inline">\(a \in A\)</span> があって, <span class="math inline">\(m = [a]\)</span> と表せる</li>
</ul></li>
</ul>
<p>この <span class="math inline">\([~]\)</span> のことをよく <strong>標準全射</strong> とか自然射影とかそれらしい名前で呼ぶ. 当たり前に出来上がるものなので決まりきった名前はないようだ.</p>
<blockquote>
<p>今見たのは「同値関係があると商集合なる集合を定めることが出来, 全射が作れた」という現象. 次はその逆に「全射があれば, 同値関係と商集合が作れる」という現象を見ていく.</p>
</blockquote>
<h3 id="商対象">商対象</h3>
<p>集合 <span class="math inline">\(A\)</span> がある. 適当な集合 <span class="math inline">\(X\)</span> と, 全射 <span class="math inline">\(f \colon X \to A\)</span> があるとき, このペア <span class="math inline">\((X, f)\)</span> のことを, 或いは単に <span class="math inline">\(X\)</span> のことを <span class="math inline">\(A\)</span> の <strong>商対象</strong> という.</p>
<p><span class="math inline">\(A\)</span> の上の同値関係 <span class="math inline">\(\sim\)</span> を次の通り定義する: <span class="math display">\[a \sim a&#39; ~ (\in A) \iff f(a) = f(a&#39;) ~ (\in X)\]</span></p>
<p><span class="math inline">\(f(a)\)</span> のことを <span class="math inline">\([a]\)</span> と書くことにすれば, <span class="math inline">\(X\)</span> が先程の <span class="math inline">\(\slice A \sim\)</span> と同値であることが見てわかる. もちろんその全射性から <span class="math inline">\(x \in X\)</span> に対していつでも対応する <span class="math inline">\([a]\)</span> があることによる.</p>
<h2 id="商群">商群</h2>
<h3 id="商対象-1">商対象</h3>
<p>群 <span class="math inline">\(G\)</span> がある. また適当な群 <span class="math inline">\(X\)</span> があって全射 <span class="math inline">\(f \colon G \to X\)</span> があるとする. ただしここで全射と呼ぶのは準同型写像に限る. この <span class="math inline">\(X\)</span> のことを（或いは <span class="math inline">\((X,f)\)</span> のことを） <span class="math inline">\(G\)</span> の <strong>商群</strong> または集合の場合と同様に商対象と呼ぶ.</p>
<p>やはり集合の場合と全く同様にして, <span class="math inline">\(G\)</span> の上の同値関係を入れる: <span class="math display">\[g \sim g&#39; \iff f(g) = f(g&#39;).\]</span> さてこの <span class="math inline">\(f(g)=f(g&#39;)\)</span> であるが, 群であることと準同型写像であることから次のように言い換えられる.</p>
<ul>
<li><span class="math inline">\(f(g) = f(g&#39;)\)</span></li>
<li><span class="math inline">\(\iff f(g) - f(g&#39;) = 0\)</span></li>
<li><span class="math inline">\(\iff f(g - g&#39;) = 0\)</span></li>
</ul>
<p>準同型写像に対して核という概念があり, 今回は <span class="math inline">\(f\)</span> に対して次のようなものを <span class="math inline">\(f\)</span> の核といって <span class="math inline">\(\ker f\)</span> と書く. <span class="math display">\[\ker f = \{ g \in G \mid f(g) = 0 \} ~ (\subset G)\]</span></p>
<p>実はコレ自体が <span class="math inline">\(G\)</span> の部分群になっている.</p>
<p>これを使うと, 先程の <span class="math inline">\(f(g-g&#39;)=0\)</span> は <span class="math inline">\(g-g&#39; \in \ker f\)</span> と言える. 結局, <span class="math inline">\(G\)</span> 上の同値関係が <span class="math display">\[g \sim g&#39; \iff g-g&#39; \in \ker f\]</span> で定義されている.</p>
<p><span class="math inline">\(X\)</span> のことを <span class="math inline">\(\slice G \sim\)</span> とか <span class="math inline">\(\slice G \ker{f}\)</span> とか書く.</p>
<blockquote>
<p>全射を作ると, 同値関係や <span class="math inline">\(G\)</span> の部分群なる群が作れて, それでもって商群が構成できた. 逆に部分群を与えても商群が作れることを次に見ていく.</p>
</blockquote>
<h3 id="群論的商群">群論的商群</h3>
<p>普通はこちらを使う.</p>
<p>群 <span class="math inline">\(G\)</span> がある. これの部分群 <span class="math inline">\(H \subset G\)</span> があるとき, 商群 <span class="math inline">\(G/H\)</span> を次のように定義する.</p>
<p><span class="math display">\[G/H = \{ g+H \mid g \in G \}\]</span> ただしここで <span class="math inline">\(g+H\)</span> とは <span class="math inline">\(\{g+h \mid h \in H \}\)</span> である. また <span class="math inline">\(+\)</span> とは群 <span class="math inline">\(G\)</span> の上に定義されてる演算のこと.</p>
<p><span class="math inline">\(G/H\)</span> の上のイコールは各要素が集合なので集合的なイコールの意味. <span class="math display">\[g+H = g&#39;+H \iff \{g+h \mid h \in H\} =\{g&#39;+h \mid h \in H\}\]</span> 右辺の集合のイコールは「左から自由に取ってきたものが右にも入ってる」ということを確認すればよい. 「右から自由に取ってきたものが～」も示す必要が本当はあるが対称的なので省略する.</p>
<ul>
<li><span class="math inline">\(\forall (g+h) \in g+H, (g+h) \in g&#39;+H\)</span></li>
<li><span class="math inline">\(\iff \forall h \in H, \exists h&#39; \in H, g+h = g&#39;+h&#39;\)</span></li>
</ul>
<p>しかしながら群にはいつも逆元があってキャンセルできるので,</p>
<ul>
<li><span class="math inline">\(\iff \forall h \in H, \exists h&#39; \in H, g+h+(-h) = g&#39;+h&#39;+(-h)\)</span></li>
</ul>
<p>とすれば実は <span class="math inline">\(\forall\)</span> は関係なくて単に</p>
<ul>
<li><span class="math inline">\(\iff \exists h&#39;&#39; \in H, g = g&#39; + h&#39;&#39;\)</span></li>
</ul>
<p>とできる. <span class="math inline">\(g&#39;\)</span> を左辺に移項すれば,</p>
<ul>
<li><span class="math inline">\(\iff g-g&#39; \in H\)</span></li>
</ul>
<p>というわけで, 改めて <span class="math inline">\(G/H\)</span> の上のイコールは次の通り: <span class="math display">\[g+H = g&#39;+H \iff g-g&#39; \in H\]</span></p>
<p>さて, <span class="math inline">\(g \in G\)</span> に対して <span class="math inline">\(g+H \in G/H\)</span> を対応させる写像が集合のときの <span class="math inline">\([~]\)</span> みたいなもんで, もちろん全射になっていて, <span class="math display">\[\pi \colon G \to G/H\]</span> <span class="math display">\[\pi \colon g \mapsto g+H\]</span> これのことをやっぱり標準全射などと呼ぶ.</p>
<p>この <span class="math inline">\(\pi\)</span> の核を考えてみると, <span class="math display">\[\ker \pi = \{ g \in G \mid g+H = 0+H \}\]</span> <span class="math inline">\(g+H=0+H\)</span> の部分についてだが, これは <span class="math inline">\(\iff (g-0) \in H \iff g \in H\)</span> なので結局 <span class="math display">\[\ker \pi = \{ g \in G \mid g \in H \}\]</span> となって, <span class="math display">\[\ker \pi = H ~ (\subset G)\]</span> であることがわかる.</p>
<p>商対称と定義したものと次のように対応している.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">商対象</th>
<th style="text-align: center;">商群</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">全射 <span class="math inline">\(f\)</span></td>
<td style="text-align: center;">標準全射 <span class="math inline">\(\pi\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">核 <span class="math inline">\(\ker f\)</span></td>
<td style="text-align: center;">部分群 <span class="math inline">\(H\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">終域 <span class="math inline">\(X\)</span></td>
<td style="text-align: center;">商群 <span class="math inline">\(G/H\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">全射の先でイコール <span class="math inline">\(f(g)=f(g&#39;)\)</span></td>
<td style="text-align: center;">同値関係 <span class="math inline">\((g-g&#39;)\in H\)</span></td>
</tr>
</tbody>
</table>
<footer>
    <p class="is-pulled-right">
    @cympfh / mail@cympfh.cc
    </p>
</footer>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
  </div>
  <script src="../../../resources/js/youtube.js"></script>
  <script src="../../../resources/js/web_emb.js"></script>
</body>
</html>
