<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description" content="関手 mathcal C米田の補題/" />
  <meta property="og:url" content="http://cympfh.cc/taglibro">
  <meta property="og:type" content="article">
  <meta property="og:title" content="米田の補題" />
  <meta property="og:description" content="関手 mathcal C米田の補題/" />
  <meta property="og:image" content="http://cympfh.cc/resources/img/identicon.png" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@cympfh" />
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>米田の補題</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>
<header>
<h1 class="title">米田の補題</h1>
</header>
<p class="date" style="text-align: right">
2018-11-10 (Sat.)
</p>
<div class="is-pulled-right">
<p><a class='tag is-red' href=index.html#圏論>圏論</a></p>
</div>
<p><span class="math inline">\(\def\op#1{{#1}^{\text{op}}}\def\Nat{\mathit{Nat}}\)</span> 極力, 関数適用の括弧や関数合成の <span class="math inline">\(\circ\)</span> は省略する. 例えば <span class="math inline">\((g \circ f)(x)\)</span> は単に <span class="math inline">\(gfx\)</span> と書く. また対象 <span class="math inline">\(A\)</span> の上の恒等射を <span class="math inline">\(1_A\)</span> と書き, <span class="math inline">\(A\)</span> がどうでもいいとき単に <span class="math inline">\(1\)</span> と書く.</p>
<h2 id="関手-mathcal-c">関手 <span class="math inline">\(\mathcal C\)</span></h2>
<p>圏 <span class="math inline">\(\def\C{\mathcal C}\C\)</span> において, その2つの対象 <span class="math inline">\(A,B \in \C\)</span> の間の射を全て集めたものを <span class="math display">\[\C(A,B)\]</span> だとか <span class="math display">\[\mathrm{Hom}(A,B)\]</span> だとか書く. 今は単にこれは集合だとする. つまり <span class="math inline">\(\def\Sets{\mathrm{Sets}}\Sets\)</span> における対象であるとする.</p>
<p>だとすると, コレ自体が関手だと見なせる.</p>
<h3 id="関手-ca-">関手 <span class="math inline">\(\C(A,-)\)</span></h3>
<p>まずは <span class="math inline">\(A\)</span> の部分は固定するとして <span class="math inline">\(B\)</span> 部分を引数にする関手 <span class="math display">\[\C(A,-)\]</span> を次のように定義する. <span class="math display">\[\C(A,-) : \C \to \Sets\]</span> <span class="math display">\[\C(A,-) : B \mapsto \C(A,B)\]</span> 対象の割り当てはこのように定めるが, 射については次のようにする. <span class="math inline">\(\require{AMScd}\)</span> <span class="math display">\[\begin{CD}
B_1 @&gt;f&gt;&gt; B_2 \in \C
\end{CD}\]</span> について <span class="math inline">\(\C(A,B_1) \to \C(A,B_2)\)</span> なる射を与える必要があるが, 自明なものとして, <span class="math inline">\(f\)</span> を後ろに合成するという関数があり得る. <span class="math display">\[\C(A,f) : \C(A,B_1) \to \C(A,B_2)\]</span> <span class="math display">\[\C(A,f) : g \mapsto f \circ g\]</span></p>
<p>ただしここで <span class="math inline">\(\C(A,-)(f)\)</span> を <span class="math inline">\(\C(A,f)\)</span> と書いた.</p>
<p><span class="math display">\[\begin{CD}
B_1 @. \C(A,B_1) \ni g \\
@VfVV @V\C(A,f)VV \\
B_2 @. \C(A,B_2) \ni fg \\
\end{CD}\]</span></p>
<p>以上で定まる <span class="math inline">\(\C(A,-)\)</span> は確かに関手である. 念の為確認しておく.</p>
<h4 id="proof">Proof</h4>
<p>これが関手であるとは恒等射 <span class="math inline">\(1\)</span> が <span class="math inline">\(1\)</span> に写ることと, 合成について準同型であること.</p>
<ul>
<li><span class="math inline">\(1 \in \C\)</span> について, <span class="math inline">\(\C(A, 1) = (g \mapsto 1g) = (g \mapsto g) = 1\)</span> なので恒等射.</li>
<li><span class="math inline">\(f_1, f_2, f_1f_2 \in \C\)</span> について, <span class="math inline">\(\C(A, f_1f_2) = (g \mapsto (f_1f_2)g) = (g \mapsto f_1g) (g \mapsto f_2g) = \C(A,f_1) \C(A,f_2)\)</span> なので確かに準同型.</li>
</ul>
<p>以上よりok.</p>
<p>というわけで, 圏 <span class="math inline">\(\C\)</span> とその中の１つの対象 <span class="math inline">\(A \in \C\)</span> について, 関手 <span class="math display">\[\C(A,-) : \C \to \Sets\]</span> が定義された.</p>
<h3 id="関手-c-b">関手 <span class="math inline">\(\C(-,B)\)</span></h3>
<p>今度は逆に <span class="math inline">\(\C(A,B)\)</span> という射の集合について, <span class="math inline">\(A\)</span> だけを引数にすることで, これが関手になる. ただし今度は合成するのが前からになる都合上, <span class="math display">\[\op{\C} \to \Sets\]</span> という関手として定義する. 向きだけが逆な以外は先ほどと全く同様に定義される.</p>
<p><span class="math display">\[\begin{CD}
A_1 @. \C(A_1,B) \ni g \\
@AfAA @V\C(f,B)VV \\
A_2 @. \C(A_2,B) \ni gf
\end{CD}\]</span></p>
<h3 id="関手-c--">関手 <span class="math inline">\(\C(-,-)\)</span></h3>
<p>以上2つを組み合わせれば関手 <span class="math display">\[\C(-,-) : \op{\C} \times \C \to \Sets\]</span> が定義される.</p>
<p>対象の割り当てはやはり <span class="math inline">\((A, B)\)</span> に対して <span class="math inline">\(\C(A,B)\)</span> を射の集まり (集合) として定義する.</p>
<p>射は前後から合成する. <span class="math display">\[\begin{CD}
A_1  @. B_1   @. \C(A_1,B_1) \ni h \\
@AfAA   @VgVV    @V\C(f,g)VV \\
A_2  @. B_2   @. \C(A_2,B_2) \ni ghf \\
\end{CD}\]</span></p>
<h2 id="米田の補題">米田の補題</h2>
<p>関手 <span class="math inline">\(F : \op{\C} \to \Sets\)</span> について <span class="math display">\[\Sets^{\op{\C}} (\C(-, C), F) \simeq FC\]</span> ここで <span class="math inline">\(\Sets^{\op{\C}}\)</span> は関手圏である.</p>
<p><span class="math inline">\(F\)</span> から <span class="math inline">\(G\)</span> への自然変換の集まりを <span class="math inline">\(\Nat(F,G)\)</span> と書くことにする. また <span class="math inline">\(\Nat\)</span> はやはり <span class="math inline">\(\Nat(-,-)\)</span> という関手を定めることに注意 (<span class="math inline">\(\Nat\)</span> は適切な関手圏のこと). これを用いれば, 先ほどの主張は <span class="math display">\[\Nat(\C(-, C), F) \simeq FC\]</span> とも書ける.</p>
<p>また, これと対称的な主張として <span class="math display">\[\Sets^{\op{\C}} (\C(C,-), F) \simeq FC\]</span> または <span class="math display">\[\Nat(\C(C,-), F) \simeq FC\]</span> が成り立つ.</p>
<h3 id="proof-1">Proof</h3>
<p>一方は他方の対称なので一方だけ証明する. 同型射 <span class="math display">\[\Phi_C : \Nat(\C(-, C), F) \to FC\]</span> の存在を言うことで, 2つが同型であることを示す.</p>
<p><span class="math inline">\(s \in \Nat(\C(-,C),F)\)</span> について, <span class="math display">\[\begin{CD}
\C(C,C)     @&gt;s_C&gt;&gt; FC \\
\end{CD}\]</span> であって <span class="math inline">\(1_C \in \C(C,C)\)</span> なので, <span class="math inline">\(s_C(1_C) \in FC\)</span> である. そこで <span class="math display">\[\Phi_C(s) = s_C(1_C)\]</span> と定義すると, 実はこれが同型射になっている. 全単射であることを示す.</p>
<h4 id="phi_c-は単射"><span class="math inline">\(\Phi_C\)</span> は単射</h4>
<p><span class="math inline">\(s,t \in \Nat(\C(-,C),F)\)</span> について, <span class="math inline">\(\Phi_C(s)=\Phi_C(t)\)</span> を仮定して, <span class="math inline">\(s=t\)</span> を導く. すなわち, <span class="math display">\[\forall C, s_C(1_C)=t_C(1_C) \implies \forall D, s_D=t_D\]</span> を示す.</p>
<p><span class="math inline">\(s\)</span> の自然性より <span class="math inline">\(f \in \C(D,C)\)</span> について</p>
<p><span class="math display">\[\begin{CD}
C     @. \C(C,C)   @&gt;s_C&gt;&gt; FC \\
@AfAA    @V\C(f,C)VV       @VFfVV \\
D     @. \C(D,C)   @&gt;s_D&gt;&gt; FD \\
\end{CD}\]</span></p>
<p>この右の四角形が <span class="math inline">\(\Sets\)</span> において可換なので <span class="math display">\[s_D f = (Ff) s_C\]</span> が成り立つ. 同様に <span class="math inline">\(t_D f = (Ff) t_C\)</span> であって, 今 <span class="math inline">\(s_C=S_D\)</span> なので <span class="math display">\[s_D f = t_D f\]</span> である. 今これは任意の <span class="math inline">\(f \in \C(D,C)\)</span> について成立するので結局 <span class="math inline">\(s_D=t_D\)</span> であって, <span class="math inline">\(D\)</span> も自由に取って良いので <span class="math display">\[s=t\]</span> が導かれた.</p>
<p>というわけで <span class="math inline">\(\Phi_C\)</span> は単射.</p>
<h4 id="phi_c-は全射"><span class="math inline">\(\Phi_C\)</span> は全射</h4>
<p>任意の <span class="math inline">\(X \in FC\)</span> についてある自然変換 <span class="math inline">\(s\)</span> があって <span class="math inline">\(\Phi_C(s)=X\)</span> であることを示す. つまり, <span class="math display">\[\forall X \in FC, \exists s, s_C(1_C) = X\]</span> を示す.</p>
<p>自然変換 <span class="math inline">\(s\)</span> を定義するには任意の対象 <span class="math inline">\(D\)</span> について, 関数 <span class="math inline">\(s_D : \C(D,C) \to FD\)</span> を定義できればよい.</p>
<p>射 <span class="math inline">\(f : D \to C\)</span> について <span class="math display">\[Ff : FC \to FD\]</span> <span class="math inline">\(X \in FC\)</span> について <span class="math inline">\((Ff)X \in FD\)</span> だから, <span class="math display">\[s_D(f) = (Ff)(X)\]</span> と定義するのが自然. これによって定義される <span class="math inline">\(s\)</span> を用いると, <span class="math display">\[s_C(1_C) = (F1)(X) = 1(X)=X\]</span> なので, これが全射性の証拠になっている.</p>
<p>というわけで <span class="math inline">\(\Phi_C\)</span> は全単射. というわけで <span class="math inline">\(\Nat(\C(-,C),F)\)</span> と <span class="math inline">\(FC\)</span> は同型.</p>
<p>これとの対称性から <span class="math inline">\(\Nat(\C(C,-),F)\)</span> と <span class="math inline">\(FC\)</span> との同型も全く同様に示される.</p>
<h4 id="phi_c-の逆写像"><span class="math inline">\(\Phi_C\)</span> の逆写像</h4>
<p><span class="math inline">\(\Phi_C\)</span> が全単射であることがわかったので逆写像を作ることも出来る. それは全射性を示される中で暗に定められており, すなわち,</p>
<p><span class="math display">\[\Psi_C \colon FC \to \Nat(\C(-,C),F)\]</span> <span class="math display">\[\Psi_C(X) = s ~;~ \text{ where } s_A(f) = (Ff)(X)\]</span></p>
<p>米田の補題の証明としてはこれが逆写像であることを見る方が早いか.</p>
<h4 id="自然な同型であること">自然な同型であること</h4>
<p>ここまでで示したことは, 集合として <span class="math display">\[\Sets^{\op{\C}} (\C(-, C), F) \simeq FC\]</span> という同型関係があることにすぎない. 米田の補題は更にこれが自然な同型であることまでを言う.</p>
<p>すなわち, <span class="math inline">\(Y_\C(C) = \C(-,C)\)</span> としたとき, <span class="math inline">\(\Nat(Y_\C(-), F)\)</span> もまた <span class="math inline">\(F\)</span> と同様に <span class="math display">\[\op{\C} \to \Sets\]</span> なる関手である.</p>
<p>このとき, <span class="math display">\[\Nat(Y_\C(-),F) \simeq F\]</span> であることが言える.</p>
<p>すなわち, 互いに逆になる自然変換がある. それはちょうど今定めた <span class="math inline">\(\Phi\)</span> (<span class="math inline">\(C\)</span> に対して <span class="math inline">\(\Phi_C\)</span> を与えるもの) と <span class="math inline">\(\Psi\)</span> がそれになっている.</p>
<h4 id="系">系</h4>
<p><span class="math display">\[\Sets^{\op{\C}} (\C(-, C), F) \simeq FC\]</span> に <span class="math inline">\(F=\C(-,D)\)</span> を代入することで <span class="math display">\[\Sets^{\op{\C}} (\C(-, C), \C(-, D)) \simeq \C(C,D)\]</span> を得る.</p>
<h4 id="系-1">系</h4>
<p><span class="math display">\[\C(-, C) \simeq \C(-, D) \Rightarrow C \simeq D\]</span></p>
<h5 id="証明">証明</h5>
<p>仮定より <span class="math inline">\(s : \C(-, C) \simeq \C(-, D) : t\)</span> なる自然同型 <span class="math inline">\(s,t\)</span> がある.</p>
<p>これらを <span class="math inline">\(\Phi_C, \Phi_D\)</span> で送って出来る, <span class="math display">\[\Phi_C(s) : C \to D\]</span> <span class="math display">\[\Phi_D(t) : D \to C\]</span> がちょうど逆射になっている.</p>
<h5 id="全ての終対象は同型を除いて一意">全ての終対象は同型を除いて一意</h5>
<p>普通に証明出来る命題だが, 今の系を用いても証明できる. すなわち, 終対象の定義を思い出すと, <span class="math inline">\(C\)</span> が終対象であるとは, <span class="math inline">\(\forall A, \C(A,C) \simeq \{\ast\}\)</span> であることであった. 従って, <span class="math inline">\(C\)</span> も <span class="math inline">\(D\)</span> も終対象であるなら, 任意の <span class="math inline">\(A\)</span> について今のことが言えるので, <span class="math display">\[\C(-,C) \simeq \C(-,D)\]</span> である. よって <span class="math display">\[C \simeq D.\]</span></p>
<p>同様に他の極限 (積など) についても同じことが言える.</p>
<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>
</body>
</html>
