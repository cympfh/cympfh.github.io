<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Tue Dec 6 2016</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../../../resources/css/c.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<a href="../../">🔙 Back to Top</a>
<header>
<h1 class="title">Tue Dec 6 2016</h1>
</header>
<blockquote>
<p>この記事は <a href="http://www.adventar.org/calendars/1440"><img src="http://www.adventar.org/assets/icon200-7c9a9308860c3a9cc64fa22b75f92d1401579db156cb9eb3ac39173c31e10282.png" width="22px" /> ゆゆ式Advent Calendar 2016</a> の6日目に書かれました.</p>
</blockquote>
<h2 id="ゆゆ式-advent-calendar-2016-6日目-ゆゆ式-アニメ-における可愛いとは何か">ゆゆ式 Advent Calendar 2016 6日目: ゆゆ式 (アニメ) における可愛いとは何か</h2>
<h2 id="あらまし-4行">あらまし (4行)</h2>
<ol type="1">
<li>ゆゆ式は可愛い</li>
<li>可愛いとは何だろう?</li>
<li>言葉で説明するのは難しい</li>
<li>機械学習は実験そのものであり、人間に発見を与えてくれる</li>
</ol>
<h2 id="あらまし-長い">あらまし (長い)</h2>
<p>ゆゆ式 (マンガ) が語られるとき、しばしばそのハイコンテキストさから、哲学の視点から語られることが多い. しかし他のまんがタイムきらら作品と違わず単純にキャラの可愛らしさも言わずもがなである. 私が思うに (そしてこれはよくある話だが) ゆゆ式 (アニメ) はゆゆ式 (マンガ) に較べ、よりライト層にも受け入れられるよう、 哲学的難解さを多少取り払って、その分、 (万人受けするような) 日常アニメとしての可愛らしさに注力しているように見受けられる. というわけで、ゆゆ式 (アニメ) における可愛いについて研究する. 実際的な理由として、ゆゆ式 (マンガ) ではないのは、私がマンガを紙でしか持っていないのでコマ画像を持っていないから.</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="ja" dir="ltr">
ゆゆ式のハイコンテクストすぎる会話を翻訳してみた。 <a href="http://t.co/c2w6mdV3IG">pic.twitter.com/c2w6mdV3IG</a>
</p>
— ニカイドウレンジ (<span class="citation" data-cites="R_Nikaido">@R_Nikaido</span>) <a href="https://twitter.com/R_Nikaido/status/474875890493444096">June 6, 2014</a>
</blockquote>
<script async src="http://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>本記事の本当の目的はゆゆ式のキャラってこうだから可愛いよね (と私は考える) を万の言葉を尽くして説明することなのだが、 自分が持つ (特に非テキストから習得した) 概念を言葉で正確に説明するのは難しい. 言語ゲームの呪い (造語) から逃げられないからである. 赤色とは何かを一生懸命テキストだけで説明するのは難しい. かなり多くの共有した事前知識が必要となる. それよりも、実際に画像 (印刷した紙でもいいが) を見せて、「これが赤色です」、 微妙に薄かったり濃かったりした画像を見せて、「これもやっぱり赤色です」、 などと無限に例示を繰り返す方が早いし、それくらいしかない.</p>
<p>人間の振る舞いを見ると、 (もちろん有限回の) 例示によっていつしか、 個人個人の中にある一つの赤色という概念に収束し、 コミュニケーション間で辻褄が合っているのだ. じゃあ逆に、その獲得した概念から、「赤色の説明」に展開できるのかと言えば、それは難しいと思う.</p>
<p>現実的な方法としては、先程述べたように、「これが赤色です」の例示を十分回数、繰り返すことで、 学習者に赤色の概念を獲得させることだと思う.</p>
<p>以上述べたことはまさしく「教師あり学習」それも「完全情報からの帰納的推論 (learning from positive and negative data)」 の枠組みの話である. 私は、これが可愛い、これは可愛くない、という主観的な概念を持っている. しかし私の思う「可愛い」を正確に説明することは、きっと不可能である. それでも、人に教えることはできる. 大量の例示を使って.</p>
<p>この機械は本人に新しい発見を与えることが知られている. つまり、「私はこんな画像も可愛いと思っていたのか」という発見である. 次に紹介する kwibot ちゃんは、私の持っている可愛いという概念を移した機械である.</p>
<h2 id="kwibot">kwibot</h2>
<p>「可愛い」という概念を機械に教え込む. kawaii の概念を獲得した robot なので kwibot さんと命名.</p>
<p>概念を教えるとは、先述したように、私の教えた画像について可愛いものは可愛い、可愛くないものは可愛くないと覚えたもので、 元も子もない言い方をすると、 画像を与えると、可愛いか可愛くないかを、その度合 (範囲 <span class="math inline">\([0,1]\)</span> の実数値) で教えてくれる機械である. 仮にその度合のことをここでは <code>Kawaii level</code> と呼ぶ.</p>
<figure>
<img src="../../img/2016/1206/kwibot.png" width="400px">
<figcaption>
これ図にする必要ある？
</figcaption>
</figure>
<p>kwibot さんには私の持っている「可愛い」を正確に伝授したい. 良い教育をするには良い教材が必要である. ここで教材とは、主に次の2つのこと.</p>
<ol type="1">
<li>大量の可愛い画像 (positive data) (<code>Kawaii level</code> を 1 とする)</li>
<li>大量の可愛くない画像 (negative data) (<code>Kawaii level</code> を 0 とする)</li>
</ol>
<p>つまり可愛い画像を見せては「これは可愛いですね」、可愛くない画像を見せては「これは可愛くないですね」と教えることを大量に繰り返す.</p>
<p>有象無象の画像ならいくらでもインターネットから拾うことができる. しかし何でも良いわけではない. それが可愛いか可愛くないか、という <strong>ラベル</strong> が着いていないと教えることはできない. そして、教材となる画像の枚数は大量であることが望ましい. 感覚的には、数万以上欲しい. 数百枚でいいのなら、ラベルを付与する作業 (annotation) は人手で出来るだろう.</p>
<p>そこで某静画投稿サイトを使った. この静画投稿サイトでは、画像一枚一枚に対してタグがついていて、 そして閲覧数が報告されている. 例えばタグ <code>&quot;女子高生&quot;</code> といった可愛らしそうな画像に付与されそうなタグで選別. かつ、閲覧数がある程度あることで、イラストとしての質が担保されたものを &quot;可愛い&quot; として覚える.</p>
<p>注意点として、本来の目的は「アニメのキャプチャ画像」であるのに対して、 静画投稿サイトにあるのは、(多くは一般人が) 適当なペイントツールを使って適当な機材 (ペンタブ？とか？) で描いた「イラスト」であること.</p>
<h3 id="エッチな画像の扱い">エッチな画像の扱い</h3>
<p>問: 「エッチな画像は可愛いのか」</p>
<p>本当は、あんまりエッチな画像は可愛くないとして欲しい. kwibot さんにエッチな画像を一切見せずに教育した場合、エッチな画像はみんな可愛いと判断してしまった. エッチな画像を可愛くないと教えた場合、 <strong>可愛い</strong> 画像を <strong>可愛くない</strong> と判断することが増えた. 従って、エッチな画像は可愛くなくはないことが分かる. 妥協として、エッチな画像は少しだけ可愛い (<code>Kawaii level</code> を 0.4 とした).</p>
<h2 id="アニメキャプチャ画像への転用">アニメキャプチャ画像への転用</h2>
<p>kwibot さんはなんかすごいペイントツールでタッチペン？とか使って描かれたようなイラストだけを見て「可愛い」を学習してきた. さてしかし、今回の目標はゆゆ式 (アニメ) であって、すなわち、アニメのキャプチャ画像である. 経験的に、イラストとキャプチャ画像はまあまあ違うものであることがわかっている. (だからラベル付きのアニメのキャプチャ画像が数万枚手に入るのなら、初めからそれで学習すれば良い.)</p>
<p>例として、イラストだけから学習した kwibot さんを使って、ゆゆ式第一話で可愛いと判定したものを見てみる.</p>
<p>第一話で試してみます</p>
<p>第一話から1秒単位でキャプチャを取って</p>
<figure>
<img src="../../img/2016/1206/thumbs.png" width="500px">
<figcaption>
第一話のキャプチャ画像
</figcaption>
</figure>
<p>kwibot さんに見てもらう. <code>Kawaii level</code> が 0.9 以上あるものを「とても可愛い」ものだとして抽出する. 結果、抽出されたのは次の 17枚.</p>
<figure>
<img src="../../img/2016/1206/raw.high.png" width="500px">
<figcaption>
ファインチューニング前: 第一話で可愛い判定した 17枚
</figcaption>
</figure>
<p>「ね？全然ダメでしょう？」と言いたかったのだけど、別に悪くない. 少なくとも何かしらキャラが大きく描かれてるフレームだけが抽出された. 脚だけが映ってるフレームなんかが抽出されてるのも、個人的にはポイント高い</p>
<h2 id="アニメキャプチャ画像へのファインチューニング">アニメキャプチャ画像へのファインチューニング</h2>
<p>kwibot ちゃんには、 アニメのキャプチャ画像で、しかもゆゆ式のそれ、という狭い限定的なドメインだけで 「可愛い」 を知ってくれればそれでいい. 大量のイラストで、ある程度、2012-2016年のネット文化における「可愛い」が何かを分かってくれたと思うので、ここからはゆゆ式にだけ視野を狭めていただく.</p>
<ol type="1">
<li>ゆゆ式のキャプチャ画像の新教材を使う</li>
<li>イラストで学習した kwibot ちゃんに新教材で学習する</li>
</ol>
<p>これだけ. 新教材は手作業で作ることにする. キャプチャ画像に可愛いかどうかなんてラベルは無いからしょうがない. 第一話から 1000 枚程度のキャプチャを取って、一枚ずつ吟味して手でラベルを付与する.</p>
<h3 id="アノテーション作業-可愛いとは何かを自問する時間">アノテーション作業 (可愛いとは何かを自問する時間)</h3>
<figure>
<img src="../../img/2016/1206/annotator.png" width="500px">
<figcaption>
アノテーションツール: x/./o ボタンで判定する
</figcaption>
</figure>
<p>一枚ずつ見て、これは可愛い、これは可愛くない、を判定していく. とは言え <strong>キャラクターが描かれていれば基本的に可愛い</strong> という問題がある. となるとこれは、キャラクターが描かれているかどうかを学習してしまう. なのであくまでも厳しく、特別に可愛いときにだけ可愛いとする.</p>
<p>じゃあ、それ以外、「普通に可愛い」を「可愛くない」として教えるのは、大抵の場合良くない. 「本当に可愛い」を評価するために、 「普通に可愛い」にある要素を全て捨ててしまうからである. 妥協して、半分くらい可愛い、と教えるのが正しい.</p>
<ol type="1">
<li><code>Kawaii level</code> 0
<ul>
<li>キャラクターが一切描かれていない</li>
<li>モブ</li>
</ul></li>
<li><code>Kawaii level</code> 0.5
<ul>
<li>キャラクターが描かれている</li>
<li>もちろん可愛い</li>
</ul></li>
<li><code>Kawaii level</code> 1
<ul>
<li>本当に可愛い</li>
</ul></li>
</ol>
<p>これを1400枚程度について、アニメを見るのと同じ時系列で作業していく. 作業するにつれ、「本当に可愛い」の基準が自分の中でブレていったのは否めない.</p>
<h3 id="第一話結果">第一話結果</h3>
<p>第一話に関しては、私が kwibot ちゃんに教えたことそのままなので、いいでしょう. 下は kwibot さんが可愛いと判定するようになった画像ですが、 「私 (筆者) はこういうものを可愛いとしました」という報告だと思って眺めていただければ結構です.</p>
<figure>
<img src="../../img/2016/1206/ft.01.png" width="500px">
<figcaption>
ファインチューニング後: 第一話で可愛いと判定した 116枚
</figcaption>
</figure>
<p>先ほどと同じ基準で <code>Kawaii level</code> が0.9超えしたものを抽出した. 116枚と多くなったが、 似たキャプチャ画像が多いのでこれは当然. むしろこれはファインチューニングして良くなった結果である.</p>
<h3 id="第二話以降">第二話以降</h3>
<p>ここからは、第一話で教えた可愛いを、初めて見る画像でも正しく実践出来ているかを確かめるフェーズとなる.</p>
<p>すぐ分かることとして、第一話で可愛いとする枚数に対して、第二話以降、せいぜい多くて50枚程度と、極端に少ない. 明らかに第一話で過学習してる. まあいいや.</p>
<figure>
<img src="../../img/2016/1206/ft.02.png" width="500px">
<figcaption>
ファインチューニング後: 第2話で可愛いと判定した 16枚
</figcaption>
</figure>
<figure>
<img src="../../img/2016/1206/ft.03.png" width="500px">
<figcaption>
ファインチューニング後: 第3話
</figcaption>
</figure>
<figure>
<img src="../../img/2016/1206/ft.04.png" width="500px">
<figcaption>
ファインチューニング後: 第4話
</figcaption>
</figure>
<figure>
<img src="../../img/2016/1206/ft.05.png" width="500px">
<figcaption>
ファインチューニング後: 第5話
</figcaption>
</figure>
<figure>
<img src="../../img/2016/1206/ft.06.png" width="500px">
<figcaption>
ファインチューニング後: 第6話
</figcaption>
</figure>
<figure>
<img src="../../img/2016/1206/ft.11.png" width="500px">
<figcaption>
ファインチューニング後: 第11話
</figcaption>
</figure>
<figure>
<img src="../../img/2016/1206/ft.12.png" width="500px">
<figcaption>
ファインチューニング後: 第12話
</figcaption>
</figure>
<p>それぞれ拡大して見た頂けるとよく分かるのだが、 結局、 目が大きく白抜きの丸になってたりする絵が多く抽出されてる. これは分かりやすい特徴ではあるけど平凡な結果だ.</p>
<p>主要キャラ三人が集合してる絵は引っかかりやすい. エンドカードなんかもそう.</p>
<p>それとOPの海のシーンがよく抽出されている. そのくせ第12話が海回だというのに完全にスルーされてるな.</p>
<p><code>Kawaii level</code> の閾値を 0.8 にまで下げると、4つだけ、海のシーンが抽出された.</p>
<figure>
<img src="../../img/2016/1206/sea.png" width="500px">
<figcaption>
ファインチューニング後: 第12話. Kawaii level が 0.8 を超えた海シーン
</figcaption>
</figure>
<p>明らかに私がゆずこを贔屓してるのがバレバレだ.</p>
<h2 id="まとめ">まとめ</h2>
<p>やはり基準を守って人手でアノテーションする作業が一番、ネックだと思う. 教師データ1000枚というのも本当は少ない.</p>
<p>わたしはゆずこ贔屓.</p>
<p>今度はマンガで試したいので Kindle で買い直すか...</p>
<!--

  HTML として pandoc -B で include する.

  <H2> を列挙してそれらにリンクを貼った toc を id='toc' に埋め込む.
  markdown で書いてるだろうから例として次のような段落を書けばよい.

```
## INDEX
<div id=toc></div>
```

  used in
  - /memo/gnuplot
  - /memo/linux
  - /memo/imagemagick

-->
<script>
(function() {
  var sections = document.getElementsByTagName('h2');
  var i;
  var OL = document.createElement('ol');
  for (i=0; i < sections.length; ++i) {
    var LI = document.createElement('li');
    var A = document.createElement('a');
    A.innerHTML = sections[i].innerHTML;
    if (A.innerHTML.toUpperCase() == 'INDEX') continue;
    A.href = '#' + i;
    LI.appendChild(A);
    OL.appendChild(LI);

    var PREF = document.createElement('a');
    PREF.name = i;
    sections[i].appendChild(PREF);
  }

  var done = false;
  function work() {
    if (done) return;
    if ( document.getElementById('toc') === null) return; // no toc element
    document.getElementById('toc').appendChild(OL);
    done = true;
  };

  window.onload = work;
  setTimeout(work,800);
}());
</script>
<footer>
    <p class="is-pulled-right">
    @cympfh / mail@cympfh.cc
    </p>
</footer>
<!--

  HTML として pandoc -B で include する.

  <H2> を列挙してそれらにリンクを貼った toc を id='toc' に埋め込む.
  markdown で書いてるだろうから例として次のような段落を書けばよい.

```
## INDEX
<div id=toc></div>
```

  used in
  - /memo/gnuplot
  - /memo/linux
  - /memo/imagemagick

-->
<script>
(function() {
  var sections = document.getElementsByTagName('h2');
  var i;
  var OL = document.createElement('ol');
  for (i=0; i < sections.length; ++i) {
    var LI = document.createElement('li');
    var A = document.createElement('a');
    A.innerHTML = sections[i].innerHTML;
    if (A.innerHTML.toUpperCase() == 'INDEX') continue;
    A.href = '#' + i;
    LI.appendChild(A);
    OL.appendChild(LI);

    var PREF = document.createElement('a');
    PREF.name = i;
    sections[i].appendChild(PREF);
  }

  var done = false;
  function work() {
    if (done) return;
    if ( document.getElementById('toc') === null) return; // no toc element
    document.getElementById('toc').appendChild(OL);
    done = true;
  };

  window.onload = work;
  setTimeout(work,800);
}());
</script>
</body>
</html>
