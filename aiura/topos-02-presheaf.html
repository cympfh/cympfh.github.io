<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>トポス - 前層の圏</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">トポス - 前層の圏</h1>
<p><p class=date style='text-align: right'>2019-10-19 (Sat.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#トポス>トポス</a> <a class='tag is-red' href=index.html#圏論>圏論</a> </div></p>
\[
\require{amscd}
\def\C{\mathcal C}
\def\Sets{\mathrm{Sets}}
\def\E{\mathcal E}
\def\op{\mathrm{op}}
\def\Y{\mathcal Y}
\]
<p><a href="topos-01.html">前回</a> はトポスの定義と, トポスの最も簡単な例として \(\Sets\) があることを述べた. 今回は非自明だが典型的なトポスの例として前層を紹介する.</p>
<h2>前層の圏</h2>
<p>\(\C\) を任意の圏とする. 対象を \(\C\) から \(\Sets\) への反変関手であるような関手圏</p>
\[\E = \Sets^{\C^{\op}}\]
<p>を \(\C\) の上の <strong>前層</strong> （の圏）という.</p>
<h2>前層はトポス</h2>
<p>\(\C\) がどんなものであっても, その上の前層はトポスである. トポスには３つの要件があった. 前層がその３つを満たすことを順に見ていく.</p>
<h3>終対象（ \(1\) ）, 積, 冪の存在</h3>
<p>\(1\) 及び積の存在は \(\Sets\) のそれを使う.</p>
<h4>終対象</h4>
<p>\(1 \in \E\) は次で定まる.</p>
\[1 \colon \C^{\op} \to \Sets\]
\[1 \colon A \mapsto 1\]
<p>これが確かに終対象であることを定義通り確かめる. すなわち, 任意の \(F \in \E\) について, \(s \colon F \to 1\) が唯一あることを見ればいい.</p>
<p>ここで \(F\) は \(\E\) の対象で \(s\) は \(\E\) の射であるが, \(\E\) は関手圏であったので, \(F\) は関手 \(\C^{\op} \to \Sets\) で \(s\) は自然変換 \(F \to 1\) である. 自然変換であるとはすなわち, \(\C\) における任意の射を \(F\) および \(1\) で写したものの間にいい感じの射を与えてくれること. そして自然変換 \(s \colon F \to 1\) は対象 \(A\) には \(s_A \colon FA \to 1A\) (ここで \(1A=1\) ) を与えてくれるのだった.</p>
<p>これを図式で書くと次の通り.</p>
\[\begin{CD}
A        @.   FA      @&gt;s_A&gt;&gt;  1A       \\
@VfVV         @AFfAA           @A1fAA   \\
B        @.   FB      @&gt;s_B&gt;&gt;  1B
\end{CD}\]
<p>左の縦の \(f \colon A \to B\) は \(\C\) から任意に取ってきた射. これを \(F\) と \(1\) で \(\Sets\) に写してる. 反変なので矢印の向きが逆になっている. 横向きに \(s_A, s_B\) でこれをつないで四角形を作っているが, ここが可換であることが自然変換であることの要件. \(1A=1B=1\) , \(1f=1\) なので右の四角形だけ書き直すと,</p>
\[\begin{CD}
FA      @&gt;s_A&gt;&gt;  1    \\
@AFfAA           @|   \\
FB      @&gt;s_B&gt;&gt;  1
\end{CD}\]
<p>となる. さて \(s_A, s_B\) は結局, 終対象への射なのでそれは終対象の要件から唯一であることが分かる.</p>
\[s_A = !_A\]
<p>そしてそのとき問題なく可換でもある.</p>
<p>というわけでこのような自然変換 \(s\) は唯一存在する. 従って \(1 \in \E\) は確かに終対象.</p>
<h4>積</h4>
<p>次に積. これも \(\Sets\) の積をそのまま使う. \(F, G \in \E\) について, \(F \times G\) を次で定める.</p>
\[F \times G \colon \C^{\op} \to \Sets\]
\[(F \times G)(A) = FA \times GA\]
<p>これが積であることは明らかだよね.</p>
<h4>冪</h4>
<p>次に冪対象. これは <a href="Yoneda.html">米田の補題</a> 及びカリー化を使うと自然に出てくる. すなわち米田の補題によれば, 関手 \(F \colon \C^{\op} \to \Sets\) は</p>
\[\Sets^{\C^{\op}}(\C(-,A),F) \simeq FA\]
<p>を満たす. ここで \(\C(-,A)\) とは \(\C\) の対象 \(B\) を \(\C(B,A)\) に写すような関手 \(\C^{\op} \to \Sets\) である. 簡単に \(\Y^A\) と書くことにする. そして \(\Sets^{\C^{\op}}(\Y^A, F)\) とは \(\Y^A\) から \(F\) への自然変換全体からなる集合のことである.</p>
<p>先の \(F\) に（あるかは分からないが）冪対象 \(F^G\) を入れてみると,</p>
\[\Sets^{\C^{\op}}(\Y^A, F^G) \simeq F^G(A)\]
<p>が出てくる. この左辺にアンカリー化を施すと</p>
\[\begin{align*}
F^G(A)
&amp; \simeq \Sets^{\C^{\op}}(\Y^A, F^G)  \\
&amp; \simeq \Sets^{\C^{\op}}(\Y^A \times G, F)
\end{align*}\]
<p>が得られる. 最後のものは積しか使われていないし, 積はさっき定義したので確かに存在する. そこで</p>
\[F^G \colon \C^{\op} \to \Sets\]
\[F^G(A) := \Sets^{\C^{\op}}(\Y^A \times G, F)\]
<p>と定義すればよい.</p>
<h3>始対象, 余積</h3>
<p>結論だけ述べると</p>
<ul>
  <li>\(0(A) = 0\) ,</li>
  <li>\((F+G)(A) = FA + GA\) .</li>
</ul>
<h3>subobject classifier</h3>
<h4>部分対象（subobject）, 部分関手（subfunctor）</h4>
<p>subobject classifier を定めるに先立って部分対象（subobject）を（今頃になってようやく！）定義しておく.</p>
<p>ある圏の対象 \(A,B\) について \(A\) が \(B\) の <strong>部分対象</strong> であることを, mono 射 \(A \to B\) が存在することと定義し</p>
\[A \subset B\]
<p>と書いて表す. これは特に Sets 圏においてはいわゆる「部分集合 \((\subset)\) 」の一般化だと思える. 圏論で Sets を扱う場合, その要素までは見ないので, 例えば \(\{0\} \subset \{1,2\}\) である. あくまで単射的な対応がつけばいい.</p>
<p>関手 \(F, G \colon \C \to \mathcal D\) について \(F\) が \(G\) の <strong>部分関手</strong> であるとは, 任意の対象 \(X\) について</p>
\[FX \subset GX\]
<p>であることで, このとき</p>
\[F \subset G\]
<p>だと書く.</p>
<h4>\(\Omega \in \E\)</h4>
\[\tilde{\Omega} \colon \C^{\op} \to \Sets\]
\[\tilde{\Omega}(A) = \{ F \mid F \subset \C(-, A) \}\]
<p>ここで \(\C(-,A)\) はやはり米田の補題で出てきた関手で \(\Y^A\) などとも書いたものである. \(\Y^A\) の部分関手全体を \(\tilde{\Omega}\) と定めた. さらにその中に順序を定める.</p>
<p>\(F, G \subset \C(-, A)\) について, \(\exists ! \colon G \to F\) で</p>
\[\begin{CD}
F      @&gt;mono&gt;&gt;  \Y^A    \\
@A!AA           @|   \\
G      @&gt;mono&gt;&gt;  \Y^A
\end{CD}\]
<p>となるのを \(F \succeq G\) だと定める. そして \(F \equiv G \iff F \succeq G \land G \succeq F\) として \(\tilde{\Omega}\) の上の同値を定めることで</p>
\[\Omega(A) = \tilde{\Omega}(A) &#x2F; \!\equiv\]
<p>とする.</p>
<h4>true morphism</h4>
\[t \colon 1 \to \Omega\]
\[t_A \colon 1 \to \Omega(A)\]
\[t_A(\ast) = \Y^A\]
<p>で定める.</p>
<p>以上で定まった \((\Omega, t)\) が \(\E\) の subobject classifier である.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>