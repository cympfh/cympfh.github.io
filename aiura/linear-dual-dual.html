<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>有限次元双対線形空間の双対は元の空間と同型</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-svg-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title" id="1-有限次元双対線形空間の双対は元の空間と同型">有限次元双対線形空間の双対は元の空間と同型</h1>
<p><p class=date style='text-align: right'>2018-11-02 (Fri.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#線形代数>線形代数</a> </div></p>
<p>この文章では次の定理の説明と証明を試みる. ここではすべて体として実数全体 \(\mathbb R\) の上のベクトル空間を考える.</p>
<h2 id="2-定理">定理</h2>
<p>有限次元ベクトル空間 \(V\) についてその双対空間を \(V^*\) と書くと</p>
\[V \simeq V^{**}\]
<p>が成り立つ.</p>
<h2 id="2-定義">定義</h2>
<h3 id="3-\(n\) 次元ベクトル空間">\(n\) 次元ベクトル空間</h3>
<p>\(n\) 個の基底によって生成される空間. つまり \(e_1, e_2, \ldots, e_n\) という \(n\) 個の文字を基底だとすると</p>
\[V = \{ a^1 e_1 + \cdots + a^n e_n ~:~ a_1,\ldots,a_n \in \mathbb R\}\]
<p>が \(n\) 次元ベクトル空間.</p>
<p>特に \(a^1=\cdots=a^n=0\) とするときの \(0 e_1 + \cdots + 0 e_n\) を単に \(0 \in V\) と書く.</p>
<h3 id="3-有限次元ベクトル空間">有限次元ベクトル空間</h3>
<p>\(0 \leq n \lt \infty\) のときの (つまり \(n\) が有限のときの) \(n\) 次元ベクトル空間のこと.</p>
<h3 id="3-アインシュタインの規約">アインシュタインの規約</h3>
<p>その数式に置いて自由変数であってちょうど二度出現し, そしてそれらの一方が上付き添字で一方が下付き添字のとき, その添字に関して和を取ることにする. 例えば</p>
\[a^1 e_1 + \cdots + a^n e_n\]
<p>は</p>
\[a^i e_i\]
<p>と書く. ここで \(i=1,2,\ldots,n\) という範囲を取る添字であることはその文脈から暗黙に了解してもらう.</p>
<p>添字が上付きであるか下付きであるかは主にこの記法を用いるために決めている.</p>
<h3 id="3-双対空間">双対空間</h3>
<p>\(n\) 次元ベクトル空間 \(V\) の双対空間 \(V^*\) を \(V\) から \(\mathbb R\) への線形写像全体とする:</p>
\[V^* = \{ f : V \to \mathbb R, f \text{ is a linear function } \}.\]
<p>次のように \(+\) と実数倍を定義することで \(V^*\) はベクトル空間になる.</p>
<ul>
  <li>\(\forall v \in V, (f_1 + f_2)(v) = f_1(v) + f_2(v)\)</li>
  <li>\(\forall c \in \mathbb R, f(cv) = c f(v)\)</li>
</ul>
<p>ただし基底は次のような \(f^1, \ldots, f^n\) である:</p>
\[f^i(e_j) = \delta^i_j.\]
<p>右辺はクロネッカーのデルタ.</p>
<p>\(V^*\) の次元は \(V\) の次元に一致することに註意.</p>
<h2 id="2-定理の証明">定理の証明</h2>
<p>\(V\) が \(0\) 次元の時は \(V=\{0\}\) であるが, \(V^*\) も同様に \(0\) 次元なので \(V^* = \{0\}\) . そして同様に \(V^{**}\) も \(0\) 次元なので \(V^{**}=\{0\}\) であって明らかに定理は成り立つ.</p>
<p>\(V\) が \(1\) 次元以上のときを考える.</p>
<p>次のような関数を考える.</p>
\[\Phi : V \to V^{**}\]
\[\Phi(v) : v \mapsto (g_v = (f \mapsto f(v)))\]
<p>実はこれが同型射であることを示す. すなわち \(\Phi\) は全単射であることを示す.</p>
<h3 id="3-単射性">単射性</h3>
<p>ある \(u, v \in V\) について \(g_u = g_v\) を仮定すると,</p>
\[\forall f \in V^*, g_u(f) = g_v(f).\]
<p>すなわち</p>
\[\forall f \in V^*, f(u) = f(v).\]
<p>\(f\) は線形写像なので \(f(u) = f(v) \iff 0 = f(u-v)\) . \(u-v \in V\) は基底表示して \(u-v = b^i e_i\) とし, \(f\) として \(V^*\) の基底である \(f^j\) を入れると,</p>
\[0 = f^j(b^i e_i) = b^i f^j(e_i) = b^j f^j.\]
<p>従って \(b^j=0\) . これが全ての \(j\) について言えるので結局 \(u-v = 0 \iff u = v\) .</p>
<p>以上から \(\Phi(u) = \Phi(v) \implies u = v\) が言えた.</p>
<h3 id="3-全射性">全射性</h3>
<p>任意の線形写像 \(g : V^* \to \mathbb R\) について</p>
\[\exists v \in V, g = g_v\]
<p>を示す.</p>
<p>\(V^*\) の基底 \(f^1, \ldots, f^n\) について</p>
<ul>
  <li>\(x^1 = g(f^1) \in \mathbb R\)</li>
  <li>\(x^2 = g(f^2)\)</li>
  <li>\(\vdots\)</li>
  <li>\(x^n = g(f^n)\)</li>
</ul>
<p>とすると, 任意の \(f = a_i f^i\) について,</p>
\[\begin{align*}
g(f) &amp; = a_i g(f^i) \\
     &amp; = a_i x^i
\end{align*}\]
<p>\(g=g_v\) 即ち \(g(f)=g_v(f)\) なる \(v\) を見つければよいがそれは実は</p>
\[v = x^i e_i\]
<p>とすればよくて, このとき</p>
\[\begin{align*}
g_v(f) &amp; = f(v) \\
       &amp; = (a_i f^i)(v) \\
       &amp; = a_i f^i(x^j e_j) \\
       &amp; = a_i x^j f^i(e_j) \\
       &amp; = a_i x^i
\end{align*}\]
<p>となって \(g(f) = g_v(f)\) . これは任意の \(f\) について言えるので \(g=g_v\) .</p>
<p>以上から全射性も言えた. というわけで \(\Phi\) は確かに \(V\) と \(V^{**}\) との一対一対応を与えている.</p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>