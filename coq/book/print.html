<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Coq/SSReflect/MathComp</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="template.html"><strong aria-hidden="true">1.</strong> テンプレート</a></li><li class="chapter-item expanded "><a href="proof_handling.html"><strong aria-hidden="true">2.</strong> Proof handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="search.html"><strong aria-hidden="true">2.1.</strong> Search</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">3.</strong> Tactics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tactics/apply.html"><strong aria-hidden="true">3.1.</strong> apply - 適用</a></li><li class="chapter-item expanded "><a href="tactics/case.html"><strong aria-hidden="true">3.2.</strong> case - 条件分岐</a></li><li class="chapter-item expanded "><a href="tactics/congruence.html"><strong aria-hidden="true">3.3.</strong> congruence - 合同</a></li><li class="chapter-item expanded "><a href="tactics/discriminate.html"><strong aria-hidden="true">3.4.</strong> discriminate - 構築子の区別</a></li><li class="chapter-item expanded "><a href="tactics/injection.html"><strong aria-hidden="true">3.5.</strong> injection - 単射性</a></li><li class="chapter-item expanded "><a href="tactics/inversion.html"><strong aria-hidden="true">3.6.</strong> inversion - 単射の逆</a></li><li class="chapter-item expanded "><a href="tactics/simpl.html"><strong aria-hidden="true">3.7.</strong> simpl - 簡略化</a></li></ol></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.</strong> Use Case</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cases/intros.html"><strong aria-hidden="true">4.1.</strong> 仮定と前件の移動</a></li><li class="chapter-item expanded "><a href="cases/or.html"><strong aria-hidden="true">4.2.</strong> 選言の分解</a></li><li class="chapter-item expanded "><a href="cases/iff.html"><strong aria-hidden="true">4.3.</strong> 同値 iff の分解</a></li><li class="chapter-item expanded "><a href="cases/lemma.html"><strong aria-hidden="true">4.4.</strong> 補題の導入</a></li><li class="chapter-item expanded "><a href="cases/eqP.html"><strong aria-hidden="true">4.5.</strong> = と == の言い換え</a></li><li class="chapter-item expanded "><a href="cases/exists.html"><strong aria-hidden="true">4.6.</strong> 存在量化子</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Coq/SSReflect/MathComp</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#テンプレート" id="テンプレート">テンプレート</a></h1>
<p>以下を前提にする</p>
<pre><code class="language-coq">Require Import Arith List Omega ZArith.
From mathcomp Require Import all_ssreflect.
Import ListNotations.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
</code></pre>
<h1><a class="header" href="#proof-handling" id="proof-handling">Proof handling</a></h1>
<p>証明モード自体への操作</p>
<h2><a class="header" href="#undo" id="undo"><code>Undo</code></a></h2>
<p>1手戻す</p>
<h2><a class="header" href="#restart" id="restart"><code>Restart</code></a></h2>
<p>最初からやり直す</p>
<h2><a class="header" href="#show" id="show"><code>Show</code></a></h2>
<p>証明の状態を表示する.
コマンドをごちゃごちゃしすぎて今の状態が分からなくなったときに便利.</p>
<h2><a class="header" href="#abort" id="abort"><code>Abort</code></a></h2>
<p>証明を諦める.
未証明のままで証明モードから抜ける.</p>
<h2><a class="header" href="#search" id="search">Search</a></h2>
<p><a href="search.html">Search</a></p>
<h1><a class="header" href="#search-1" id="search-1">Search</a></h1>
<h1><a class="header" href="#cases" id="cases">cases</a></h1>
<h1><a class="header" href="#apply---適用" id="apply---適用">apply - 適用</a></h1>
<p>\(H \colon P \to Q\) が仮定または定理にあり,
\(Q\) が goal のとき,
<code>apply H</code> は goal を \(P\) にすり替える.</p>
<pre><code class="language-haskell">1 subgoal

  P : Type
  Q : Type
  H : P -&gt; Q
  ============================
  Q

pq &lt;   apply H.
1 subgoal
  
  P : Type
  Q : Type
  H : P -&gt; Q
  ============================
  P
</code></pre>
<h2><a class="header" href="#apply--with" id="apply--with">apply ... with</a></h2>
<p>適用する仮定（定理）の forall な部分は上手いこと置き換えて適用するよう試みてくれるが, 上手く置き換えを見つけてくれないことがある.
その場合には with でヒントを与えることが出来る.</p>
<pre><code class="language-haskell">1 subgoal
  
  H : forall (X : Type) (x y z : X), x = y -&gt; y = z -&gt; x = z
  a, b, c, d : nat
  ============================
  [a; b] = [b; c] -&gt; [b; c] = [c; d] -&gt; [a; b] = [c; d]

pq &lt;   apply H with (x := [a;b]) (y := [b;c]).
No more subgoals.
</code></pre>
<h1><a class="header" href="#case---条件分岐" id="case---条件分岐">case - 条件分岐</a></h1>
<h2><a class="header" href="#構造に関する条件分岐" id="構造に関する条件分岐">構造に関する条件分岐</a></h2>
<p>変数名を引数に呼ぶと, 構造に関する条件分岐を行う.</p>
<p>例えばそれが <code>nat</code> であれば <code>0</code> か <code>n.+1</code> (ssreflect の場合) かに分岐される.</p>
<pre><code class="language-haskell">1 subgoal

  m, n : nat
  H : m + n = 1
  ============================
  m = 0 \/ n = 0

solution &lt;   case m.
2 subgoals

  m, n : nat
  H : m + n = 1
  ============================
  0 = 0 \/ n = 0

subgoal 2 is:
 forall n0 : nat, n0.+1 = 0 \/ n = 0
</code></pre>
<h2><a class="header" href="#自由な条件分岐" id="自由な条件分岐">自由な条件分岐</a></h2>
<p>自由に条件式 <code>(_ == _)</code> を引数に与えると,
それが <code>true</code> の場合と <code>false</code> の場合に分岐する.</p>
<pre><code class="language-haskell">Definition fizz (n : nat) : bool :=
  if n == 3 then false
  else false.

Example ex : forall n, fizz n = false.
Proof.
  move =&gt; n.
  unfold fizz.
  - case (n == 3).
    (* n == 3 が true の場合 *)
    done.
  - (* otherwise *)
    done.
</code></pre>
<pre><code class="language-haskell">1 subgoal
  
  n : nat_eqType
  ============================
  (if n == 3 then false else false) == false

ex &lt;     case (n == 3).
2 subgoals
  
  n : nat_eqType
  ============================
  false == false

subgoal 2 is:
 false == false
</code></pre>
<p>導入した条件式は即座に apply される.
仮定として残しておきたい場合は第2引数に <code>eqn:(name)</code> で名前を与える.</p>
<pre><code>ex &lt;     case (n == 3) eqn:Is3.
2 subgoals
  
  n : nat_eqType
  Is3 : (n == 3) = true
  ============================
  false == false

subgoal 2 is:
 false == false
</code></pre>
<h1><a class="header" href="#congruence---合同" id="congruence---合同">congruence - 合同</a></h1>
<p>等式 <code>(_ = _)</code> に関するゴールをいい感じに示してくれる証明戦略.</p>
<p>\[ a=b \land b=c \implies a=c \]</p>
<pre><code class="language-haskell">1 subgoal

  ============================
  forall (X : Type) (a b c : X), a = b -&gt; b = c -&gt; a = c

three_steps &lt;   intros.
(* congruence がこれもやってくれるので実は不要 *)
1 subgoal

  X : Type
  a, b, c : X
  H : a = b
  H0 : b = c
  ============================
  a = c

three_steps &lt;   congruence.
No more subgoals.
</code></pre>
<p>不等号 <code>&lt;&gt;</code> も <code>(_ = _) -&gt; False</code> に過ぎず congruence で対処できることがある.</p>
<p>\[ n+1 \ne m+1 \implies n \ne m \]</p>
<pre><code class="language-haskell">1 subgoal
  
  ============================
  forall n m : nat, n.+1 &lt;&gt; m.+1 -&gt; n &lt;&gt; m

ex &lt; Proof.
1 subgoal
  
  ============================
  forall n m : nat, n.+1 &lt;&gt; m.+1 -&gt; n &lt;&gt; m

ex &lt;   congruence.
No more subgoals.

ex &lt; Qed.
</code></pre>
<h1><a class="header" href="#discriminate---構築子の区別" id="discriminate---構築子の区別">discriminate - 構築子の区別</a></h1>
<p><a href="tactics/./injection.html">injection</a> は構築子が単射であることを利用して, 同じ構築の仕方を行って得た値は等しいという証明を行った.
同様に構築の仕方が異なるものは等しくないということも明らかなはずである.
<code>discriminate</code> はこれを行う.</p>
<pre><code class="language-haskell">1 subgoal
  
  ============================
  true &lt;&gt; false

ex &lt;   discriminate.
No more subgoals.
</code></pre>
<pre><code class="language-haskell">1 subgoal
  
  ============================
  2 &lt;&gt; 5

ex &lt;   discriminate.
No more subgoals.
</code></pre>
<p>ちなみに十分明らかなので <code>by done.</code> でも同様に証明できる.</p>
<h1><a class="header" href="#injection---単射性" id="injection---単射性">injection - 単射性</a></h1>
<p>全てのコンストラクタ（構築子）は単射である.
例えば <code>nat</code> に対する <code>S</code> や, リスト <code>[]</code> は単射なので,
\[ n + 1 = m + 1 \implies n = m, \]
\[ [n] = [m] \implies n = m, \]
が言える.
実際にこのことを証明で使うのに <code>injection</code> を使う.</p>
<pre><code class="language-haskell">1 subgoal

  n, m : nat
  H : n.+1 = m.+1
  ============================
  n = m

ex &lt;   injection H.
1 subgoal

  n, m : nat
  H : n.+1 = m.+1
  ============================
  n = m -&gt; n = m

ex &lt;   done.
No more subgoals.
</code></pre>
<h1><a class="header" href="#inversion---単射の逆" id="inversion---単射の逆">inversion - 単射の逆</a></h1>
<p>inversion はコンストラクタに関する仮定を逆に戻す.</p>
<h2><a class="header" href="#コンストラクタに関する等式" id="コンストラクタに関する等式">コンストラクタに関する等式</a></h2>
<p>コンストラクタ <code>S</code> による等式
<code>S x = S y</code>
が仮定 <code>H</code> にあったとき, <code>inversion H</code> は新たに
<code>x = y</code>
を仮定に追加する.</p>
<pre><code>1 subgoal
  
  m, n : nat
  H : m.+1 = n.+1
  ============================
  m = n

ex &lt;   inversion H.
1 subgoal
  
  m, n : nat
  H : m.+1 = n.+1
  H1 : m = n
  ============================
  n = n
</code></pre>
<h2><a class="header" href="#命題を返すコンストラクタ" id="命題を返すコンストラクタ">命題を返すコンストラクタ</a></h2>
<p><code>_ -&gt; Prop</code> であるような帰納的コンストラクタがあるとする.
例えば,</p>
<pre><code class="language-haskell">Inductive even : nat -&gt; Prop :=
  | even_O : even 0
  | even_SS n (H : even n) : even n.+2.
</code></pre>
<p>があると, <code>even m.+2</code> という仮定を <code>even m</code> に戻すことが出来る.</p>
<pre><code class="language-haskell">1 subgoal
  
  n : nat
  H : even n.+4
  ============================
  even n

ex &lt;   inversion H.
1 subgoal
  
  n : nat
  H : even n.+4
  n0 : nat
  H1 : even n.+2
  H0 : n0 = n.+2
  ============================
  even n
</code></pre>
<p>このときやはり inversion は仮定を置き換えるのではなく, 新たに追加することしかしない.</p>
<h1><a class="header" href="#simpl---簡略化" id="simpl---簡略化">simpl - 簡略化</a></h1>
<p>自明な計算で簡略化できる部分をする.</p>
<pre><code class="language-haskell">Coq &lt; Theorem test: 1 + 1 = 2.
1 subgoal

  ============================
  1 + 1 = 2

test &lt; simpl.
1 subgoal

  ============================
  2 = 2
</code></pre>
<h1><a class="header" href="#cases-1" id="cases-1">cases</a></h1>
<h1><a class="header" href="#仮定と前件の移動" id="仮定と前件の移動">仮定と前件の移動</a></h1>
<p>\( \Gamma, P \vdash Q \)
という証明と
\( \Gamma \vdash P \implies Q \)
という証明は等しい.
Coq では仮定の中の任意の命題は Goal の一番左に前件として移動できるし,
Goal の一番左の前件を仮定に移動することが自由に出来る.</p>
<h2><a class="header" href="#intros" id="intros">intros</a></h2>
<p>引数なく呼んだ時,
前件を持ってこれるだけ全部仮定に持っていく.
このとき仮定の名前は適当に付けられるので注意.</p>
<pre><code class="language-haskell">Coq &lt; Example ex : forall P Q R, P -&gt; (P -&gt; Q) -&gt; R.
1 subgoal
  
  ============================
  forall P Q R : Type, P -&gt; (P -&gt; Q) -&gt; R

ex &lt;   intros.
1 subgoal
  
  P : Type
  Q : Type
  R : Type
  X : P
  X0 : P -&gt; Q
  ============================
  R
</code></pre>
<h2><a class="header" href="#intros-p" id="intros-p">intros P...</a></h2>
<p>1つ以上の引数を指定した時, その個数だけ順に前件を仮定に移動し,
そのとき名前を引数で与える.</p>
<pre><code class="language-haskell">1 subgoal
  
  ============================
  forall P Q R : Type, P -&gt; (P -&gt; Q) -&gt; R

ex &lt;   intros P Q.
1 subgoal
  
  P : Type
  Q : Type
  ============================
  forall R : Type, P -&gt; (P -&gt; Q) -&gt; R
</code></pre>
<h2><a class="header" href="#intro" id="intro">intro</a></h2>
<p>ちょうど一つだけを移動する intros.
引数を与えない場合名前は適当に付けられる.
ちょうど一つの引数を与える場合はそれが名前に使われる.</p>
<h2><a class="header" href="#move-" id="move-">move =&gt;</a></h2>
<p>1つ以上の引数を必要とする intros に同じ.
ssreflect のコマンド.</p>
<h2><a class="header" href="#revert" id="revert">revert</a></h2>
<p>仮定を一つ選んで, 前件に追加する.</p>
<pre><code class="language-haskell">1 subgoal
  
  P : Type
  Q : Type
  R : Type
  HP : P
  ============================
  (P -&gt; Q) -&gt; R

ex &lt;   revert R.
1 subgoal
  
  P : Type
  Q : Type
  HP : P
  ============================
  forall R : Type, (P -&gt; Q) -&gt; R
</code></pre>
<h2><a class="header" href="#move" id="move"><code>move:</code></a></h2>
<p>revert に同じ.
ssreflect のコマンド.</p>
<h1><a class="header" href="#選言の分解" id="選言の分解">選言の分解</a></h1>
<h2><a class="header" href="#left-right" id="left-right">left, right</a></h2>
<p>帰結が \(P \lor Q\) のとき, この一方だけを選んで残す戦略.</p>
<p>これは \(P \lor Q\) を示すには \(P\) だけ（あるいは \(Q\) だけ）が示されれば良いことから.</p>
<pre><code class="language-haskell">Coq &lt; Example left_is_true : 0 = 0 \/ 0 = 1.
1 subgoal

  ============================
  0 = 0 \/ 0 = 1

left_is_true &lt; left.
1 subgoal

  ============================
  0 = 0

left_is_true &lt; auto.
No more subgoals.
</code></pre>
<h1><a class="header" href="#同値-iff-の分解" id="同値-iff-の分解">同値 iff の分解</a></h1>
<h2><a class="header" href="#split" id="split">split</a></h2>
<p>Goal の帰結 \(P \iff Q\) を \(P \implies Q\) と \(Q \implies P\) とに分解する.</p>
<pre><code class="language-haskell">1 subgoal
  
  P, Q : Prop
  ============================
  P &lt;-&gt; Q

ex &lt;   split.
2 subgoals
  
  P, Q : Prop
  ============================
  P -&gt; Q

subgoal 2 is:
 Q -&gt; P
</code></pre>
<p>注意としてこれは帰結にのみ適用され, 前件は勝手に全て仮定に動かされる.</p>
<h2><a class="header" href="#intros-1" id="intros-1">intros</a></h2>
<p><a href="cases/./intros.html">intros</a> で紹介してない機能があり,
上述の split をしながら仮定に持っていくという機能がある.</p>
<p>Goal が \( ( P \iff Q ) \implies \dots \) のときに,
<code>intros [PQ QP]</code> とすると,
前件 \( P \iff Q \) を split してからそれぞれを <code>PQ</code> <code>QP</code> という名前で仮定に移動する.</p>
<pre><code class="language-haskell">1 subgoal
  
  P, Q : Prop
  ============================
  P &lt;-&gt; Q -&gt; Q &lt;-&gt; P

ex &lt;   intros PQ.
(* ただの intros だと &lt;-&gt; のまま持ってくだけ *)
1 subgoal
  
  P, Q : Prop
  PQ : P &lt;-&gt; Q
  ============================
  Q &lt;-&gt; P

ex &lt; Undo.
1 subgoal
  
  P, Q : Prop
  ============================
  P &lt;-&gt; Q -&gt; Q &lt;-&gt; P

ex &lt;   intros [PQ QP].
(* 同時に split もされる!! *)
1 subgoal
  
  P, Q : Prop
  PQ : P -&gt; Q
  QP : Q -&gt; P
  ============================
  Q &lt;-&gt; P
</code></pre>
<h1><a class="header" href="#補題の導入" id="補題の導入">補題の導入</a></h1>
<p>証明中に一時的に補題を導入することで証明自体が構造的になって楽になる.</p>
<h2><a class="header" href="#assert" id="assert">assert</a></h2>
<p>名前を付けて補題を主張する.</p>
<pre><code class="language-haskell">assert (LemmaName : LemmaProp).
</code></pre>
<p>新しい Goal としてこれを追加し, 今までの証明には <code>LemmaName</code> の名前で仮定として追加される.</p>
<pre><code class="language-haskell">1 subgoal
  
  n, m : nat
  ============================
  n = m

ex &lt;   assert (Base : 0 = 0).
(* 補題の主張, その証明が goal に追加される *)
2 subgoals
  
  n, m : nat
  ============================
  0 = 0

subgoal 2 is:
 n = m

ex &lt;   by done.
(* 証明完了. 仮定に追加された *)
1 subgoal
  
  n, m : nat
  Base : 0 = 0
  ============================
  n = m
</code></pre>
<h2><a class="header" href="#have" id="have">have</a></h2>
<p>assert と同様に,</p>
<pre><code class="language-haskell">have: LemmaProp.
</code></pre>
<p>の形式で補題を主張する.
新たに Goal としてこれが追加され,
他の証明には前件として追加される.</p>
<pre><code class="language-haskell">1 subgoal

  ============================
  1 = 1

ex &lt; have: 0 = 0.
2 subgoals

  ============================
  0 = 0

subgoal 2 is:
 0 = 0 -&gt; 1 = 1
</code></pre>
<h1><a class="header" href="#-と--の言い換え" id="-と--の言い換え">= と == の言い換え</a></h1>
<pre><code class="language-haskell">eqP
     : reflect (?x = ?y) (?x == ?y)
</code></pre>
<p>を <code>move/</code> して使う.</p>
<pre><code class="language-haskell">1 subgoal
  
  n, m : nat
  ============================
  n = m -&gt; n == m

ex &lt;   move/eqP.
1 subgoal
  
  n, m : nat
  ============================
  n == m -&gt; n == m
</code></pre>
<pre><code class="language-haskell">1 subgoal
  
  n, m : nat
  ============================
  n == m -&gt; n = m

ex &lt;   move/eqP.
1 subgoal
  
  n, m : nat
  ============================
  n = m -&gt; n = m
</code></pre>
<h1><a class="header" href="#存在量化子" id="存在量化子">存在量化子</a></h1>
<h2><a class="header" href="#仮定の存在量化子を消去する" id="仮定の存在量化子を消去する">仮定の存在量化子を消去する</a></h2>
<p>仮定 <code>H</code> が
\( \exists x, P(x) \)
であるときに, <code>destruct H</code> をすると, <code>H</code> の代わりに新しく
\( x \)
という仮定と,
\( P(x) \)
という仮定が追加される.</p>
<pre><code class="language-haskell">1 subgoal
  
  n : nat
  H : exists m : nat, n = m
  ============================
  ...

ex &lt;   destruct H.
1 subgoal
  
  n, x : nat
  H : n = x
  ============================
  ...
</code></pre>
<p>仮定に <code>x</code> と新しい <code>H</code> が追加された.</p>
<h2><a class="header" href="#goal-の存在量化子を消去する" id="goal-の存在量化子を消去する">Goal の存在量化子を消去する</a></h2>
<p>Goal が
\( \exists x, P(x) \)
という形をしている場合,
そして具体的に \(P(x)\) を満たす \(x\) の値が分かっている場合は,
<code>exists</code> コマンドでその値を代入することが出来る.</p>
<pre><code class="language-haskell">1 subgoal
  
  n : nat
  ============================
  exists m : nat, m - 1 = n

ex &lt;   exists (n + 1).
1 subgoal
  
  n : nat
  ============================
  n + 1 - 1 = n
</code></pre>
<p><code>m</code> に <code>(n+1)</code> が代入された.
証明はこの代入された後の式について続いて行われるので注意.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
