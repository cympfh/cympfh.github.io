<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>群, 環, 加群</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-svg-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title" id="1-群, 環, 加群">群, 環, 加群</h1>
<p><p class=date style='text-align: right'>2021-11-13 (Sat.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#代数>代数</a> </div></p>
<p>群がすべてのベースになってるので, 丁寧にやってく. \(\def\ker#1{\mathop{\mathrm{Ker}{#1}}}\def\im#1{\mathop{\mathrm{Im}{#1}}}\) \(\def\bar#1{\overline{#1}}\)</p>
<h2 id="2-INDEX">INDEX</h2>
<p><div id=toc-level-2></div></p>
<h2 id="2-群 (Group)">群 (Group)</h2>
<h3 id="3-群の定義">群の定義</h3>
<p>集合 \(G\) に単位元及び積という構造を入れる.</p>
<ul>
  <li>
    \(e \colon I \to G\)
    <ul>
      <li>ここで \(I\) は単集合 \(\{ \ast \}\)</li>
      <li>
        \(e\) は値 \(e(\ast) \in G\) だけを持ち, この値を \(1\) と書く
        <ul>
          <li>\(1 = e(\ast) \in G\)</li>
        </ul>
      </li>
      <li>この \(1\) のことを（あるいは \(e\) のことを） <strong>単位元</strong> と呼ぶ</li>
    </ul>
  </li>
  <li>
    \(\mu \colon G \times G \to G\)
    <ul>
      <li>\(\mu(x,y)\) のことを \(x \times y\) とか \(xy\) と書く</li>
    </ul>
  </li>
  <li>
    \(\nu \colon G \to G\)
    <ul>
      <li>\(\nu(g)\) のことを \(g^{-1}\) と書いて \(g\) の <strong>逆元</strong> という</li>
    </ul>
  </li>
</ul>
<p>ここで \(1\) と \(\mu\) ( \(\times\) ) は次を満たすことを要請する</p>
<ul>
  <li>g1) \(\forall x \in G ,~ 1 \times x = x \times 1 = x\)</li>
  <li>
    g2) \(\forall x,y,z \in G ,~ (xy)z = x(yz)\)
    <ul>
      <li>結合則という</li>
    </ul>
  </li>
  <li>g3) \(\forall x \in G,~  x^{-1} \times x = x \times x^{-1} = 1\)</li>
</ul>
<p>圏論っぽく書くと次の通り. ただしここで登場する対象はすべて集合で射は写像.</p>
<p>圏の構造とは, つぎの3つの射のこと.</p>
<p><img src="https://i.imgur.com/0skm8O8.jpg" alt="" /></p>
<p>ここで満たすべき性質は次の図式が可換であること.</p>
<p><img src="https://i.imgur.com/jpQs9nu.jpg" alt="" /></p>
<p><img src="https://i.imgur.com/N8htvdz.jpg" alt="" /></p>
<p><img src="https://i.imgur.com/f4Op9Kt.jpg" alt="" /></p>
<p>同じことだがストリング図で書くと次の通り（見やすい！）. ただし下三角は単位元.</p>
<p><img src="https://i.imgur.com/EdhnDr7.jpg" alt="" /></p>
<h3 id="3-群の準同型">群の準同型</h3>
<p>2つの群 \(G,H\) があるとする. それぞれは集合でもあるから, その間の写像</p>
\[f \colon G \to H\]
<p>を考えることが出来る. この写像が <strong>準同型 (homomorphism)</strong> であるとは, 概ねそれぞれの群としての構造を保つことを言う. 具体的には次の2つが満たされることである.</p>
<ul>
  <li>
    homo1) \(f(1) = 1\)
    <ul>
      <li>\(1 \in G\) を \(1 \in H\) に写す</li>
    </ul>
  </li>
  <li>
    homo2) \(f(xy) = f(x) f(y)\)
    <ul>
      <li>掛け算してから \(f\) するのと, \(f\) してから掛け算するのは等しい</li>
    </ul>
  </li>
  <li>
    homo3) \(f(x^{-1}) = (f(x))^{-1}\)
    <ul>
      <li>逆元を写したものは, 写してから逆元を取ったものに等しい</li>
    </ul>
  </li>
</ul>
<p>同じことであるが, せっかく先程群の構造を圏論っぽく書いたので, それに揃えたバージョンも書くと次の図式が可換であることと言い換えられる.</p>
<p><img src="https://i.imgur.com/Kd0DQ5l.jpg" alt="" /></p>
<h3 id="3-部分群">部分群</h3>
<p>群 \(G\) があるとする. これは集合でもあるから部分集合 \(H \subset G\) を考えることが出来る. この \(H\) が \(G\) と同じ構造によって群であるとき, \(H\) を <strong>部分群</strong> という. 具体的には \(H\) が次を満たすことをいう.</p>
<ul>
  <li>
    \(1 \in H\)
    <ul>
      <li>ここで \(1\) は \(G\) の単位元</li>
    </ul>
  </li>
  <li>
    \(\forall x,y \in H ,~ \mu(x,y) \in H\)
    <ul>
      <li>ここで \(\mu\) は \(G\) の演算</li>
      <li>「演算について閉じている」と表現する</li>
    </ul>
  </li>
  <li>
    \(\forall x \in H ,~ \nu(x) \in H\)
    <ul>
      <li>ここで \(\nu\) は \(G\) の逆元</li>
    </ul>
  </li>
</ul>
<h3 id="3-準同型の核と像">準同型の核と像</h3>
<p>群 \(G,H\) とその間の準同型 \(f \colon G \to H\) があるとする. このとき, \(f\) の核とは</p>
\[\ker{f} := \{ g \in G \mid f(g) = 1 \}\]
<p>のことで, \(f\) の像とは</p>
\[\im{f} := \{ f(g) \mid g \in G \}\]
<p>のこと.</p>
<ul>
  <li>\(\ker{f} \subset G\)</li>
  <li>\(\im{f} \subset H\)</li>
</ul>
<p>は集合としては自明だが, 実は群としても部分群になっている. 準同型という性質から実はほとんど自明だが, 群だけは丁寧にやろう.</p>
<p>核について,</p>
<ul>
  <li>
    \(1 \in \ker f\)
    <ul>
      <li>\(f\) が準同型なので \(f(1) = 1\) であることと \(\ker f\) の定義から</li>
    </ul>
  </li>
  <li>
    \(x,y \in \ker f \implies xy \ker f\)
    <ul>
      <li>\(f(xy) = f(x) f(y) = 1 \times 1 = 1\)</li>
    </ul>
  </li>
  <li>
    \(x \in \ker f \implies x^{-1} \in \ker f\)
    <ul>
      <li>\(f(x) = 1 \implies f(x^{-1}) = (f(x))^{-1} = (1)^{-1} = 1\)</li>
    </ul>
  </li>
</ul>
<p>像について,</p>
<ul>
  <li>
    \(1 \in \im f\)
    <ul>
      <li>やはり \(f(1)=1\) なので</li>
    </ul>
  </li>
  <li>
    \(x&#x27;,y&#x27; \in \im f \implies x&#x27;y&#x27; \in \im f\)
    <ul>
      <li>\(f\) の像にあるということは, ある \(x,y \in G\) があって \(x=f(x), y&#x27;=f(x)\)</li>
      <li>\(x&#x27;y&#x27; = f(x)f(y)=f(xy)\) より \(x&#x27;y&#x27; \in \im f\)</li>
    </ul>
  </li>
  <li>
    \(x&#x27; \in \im f \implies x&#x27;^{-1} \in \im f\)
    <ul>
      <li>\(\exists x \in G, f(x)=x&#x27; \implies f(x^{-1}) = x&#x27;^{-1}\)</li>
    </ul>
  </li>
</ul>
<h3 id="3-商群">商群</h3>
<p>群 \(G\) とその部分群 \(H \subset G\) があるとき, 商群 \(G&#x2F;H\) を次で定めることができる.</p>
\[G&#x2F;H := \{ gH \mid g \in G \}\]
<p>\(gH\) は \(H\) を単位としたそういう数と思ってもいいし, 原理通りにいうなら \(gH = \{ gh \mid h \in H \}\) という値.</p>
<p>\(g,g&#x27; \in G\) について \(gH = g&#x27;H\) とは, \(\{ gh \mid h \in H \} = \{ g&#x27;h \mid h \in H \}\) のことであるが, 次のように易しく言い換えられる. （特に逆元のおかげで \(\exists\) だけでいい.）</p>
\[gH = g&#x27;H \iff \exists h \in H, g = g&#x27;h\]
<p>ついでに \(g&#x27;\) を左に移項すれば単に</p>
\[g g&#x27;^{-1} \in H\]
<p>といえる.</p>
<h4 id="4-商群の例">商群の例</h4>
<p>典型定期な例は \(\mathbb Z &#x2F; n \mathbb Z\) だろう. \(\mathbb Z\) は整数全体であって, その \(+\) に関して群をなす. 単位元のことは普通 \(0\) とかく.</p>
<blockquote>今まで暗黙に群の演算を掛け算のようにみなして演算を \(\times\) , 単位元を \(1\) と書いたが, 足し算 \(+\) と単位元 \(0\) によって群をなすようなものも多い. 単に記号の違いであるが, このような群を加法群と呼ぶ. 逆元 \(x^{-1}\) はやはり掛け算からのアナロジーでそう書いてたから, 加法群の場合の逆元は \((-x)\) と書こう.</blockquote>
<p>\(n \mathbb Z\) は各要素を \(n\) 倍して得られる集合（つまり \(n\) の倍数） \(\{ nz \mid z \in \mathbb Z \}\) のこと. \(n\) の倍数どうしの和は \(n\) の倍数であることや単位元 \(0\) は \(n\) の倍数であることから, これもやはり（加法）群である.</p>
<p>\(a = b \in \mathbb Z &#x2F; n \mathbb Z\) とは, \(a + (-b) = a - b \in n \mathbb Z\) のこと, つまり差が \(n\) の倍数ということ. すなわち整数に \(\pmod n\) を入れた数を表す.</p>
<h4 id="4-標準全射, 自然射影">標準全射, 自然射影</h4>
<p>\(g \mapsto gH\) と写すことで, 自然に \(G \to G&#x2F;H\) という全射が作れる. これを標準全射だとか自然な射影だとかそれっぽい言葉で言う.</p>
<h3 id="3-群の準同型定理">群の準同型定理</h3>
<p>群とその間の準同型 \(f \colon G \to H\) について,</p>
\[\bar{f} \colon G&#x2F;\ker f \to \im f\]
\[(g \ker f) \mapsto f(g)\]
<p>は準同型かつ同型.</p>
<p>ここで \(\ker f\) が \(G\) の部分群であることに注意（だからこそ商群が定義できる）.</p>
<p>また, 定義域が商群な場合にはこの写像が本当に well-defined であるか注意が必要である. さしあたって, \(G&#x2F;\ker f\) がどんなものか見よう.</p>
\[\begin{align*}
     &amp; (g \ker f) = (g&#x27; \ker f)  ~~ \in G&#x2F;\ker f \\
\iff &amp; (gg&#x27;^{-1}) \in \ker f \\
\iff &amp; f(gg&#x27;^{-1}) = 1 \\
\iff &amp; f(g) f(g&#x27;^{-1}) = 1 \\
\iff &amp; f(g) f(g&#x27;^{-1}) \times f(g&#x27;) = 1 \times f(g&#x27;) \\
\iff &amp; f(g) = f(g&#x27;) \\
\end{align*}\]
<p>つまり, 商群で等しい値は同じ一つの値に \(\bar{f}\) で写されていることがわかる.</p>
<p>準同型であることを見ていく.</p>
<ul>
  <li>\(\bar f(0) = f(0) = 0\)</li>
  <li>\(\bar f((g \ker f) + (h \ker f)) = f(g+h) = f(g) + f(h) = \bar f(g \ker f) + \bar f(h \ker f)\)</li>
</ul>
<p>自明だ.</p>
<p>次に同型, つまり \(\bar f\) が全単射であることを見る.</p>
<ul>
  <li>
    全射
    <ul>
      <li>\(h \in \im f\) を任意にとってきたとき, \(f\) の像なんだから当然 \(\exists g, f(g) = h\)</li>
      <li>その \(g\) を使って, \(\bar f(g \ker f) = h\)</li>
    </ul>
  </li>
  <li>
    単射
    <ul>
      <li>\(f(g) = f(g&#x27;) \iff f(g g&#x27;^{-1}) = 1 \iff gg&#x27;^{-1} \in \ker f \iff (g \ker f) = (g&#x27; \ker f)\)</li>
    </ul>
  </li>
</ul>
<p>というわけで \(\bar f\) は同型射で,</p>
\[G &#x2F; \ker f \simeq \im f\]
<p>と言える.</p>
<p>\(G\) から商群 \(G&#x2F;\ker f\) への自然な射影を \(\pi\) と書くと, 準同型定理とは次を言っている.</p>
<p><img src="https://i.imgur.com/knrgNDR.jpg" alt="" /></p>
<h3 id="3-準同型の単射性">準同型の単射性</h3>
<p>準同型 \(f \colon G \to H\) の単射性について次が成り立つ.</p>
<ul>
  <li>\(f\) が単射 \(\iff \ker f = \{1\}\)</li>
</ul>
<p>というのも, 準同型定理の \(\bar f\) の単射性を示す際に次が出てきた.</p>
\[f(g) = f(g&#x27;) \iff gg&#x27;^{-1} \in \ker f\]
<p>これを使うと自然に出てくる.</p>
<ul>
  <li>
    \(f\) が単射と仮定する
    <ul>
      <li>
        \(g \in \ker f \implies f(g) = f(1) \implies g = 1\)
        <ul>
          <li>\(g&#x27;=1\) を代入した</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    \(\ker f = \{1\}\) を仮定する
    <ul>
      <li>\(f(g) = f(g&#x27;) \implies gg&#x27;^{-1} = 1 \implies g = g&#x27;\)</li>
    </ul>
  </li>
</ul>
<h2 id="2-環 (Ring)">環 (Ring)</h2>
<h3 id="3-環の定義">環の定義</h3>
<p>加法群 \((R,+,0)\) があるとする.</p>
<ul>
  <li>
    \(\epsilon \colon I \to R\)
    <ul>
      <li>\(\epsilon(\ast) = 0 \in R\)</li>
    </ul>
  </li>
  <li>
    \(\alpha \colon R \times R \to R\)
    <ul>
      <li>\(\alpha(x, y) = x + y\)</li>
    </ul>
  </li>
  <li>
    \(\nu \colon R \to R\)
    <ul>
      <li>\(\nu(x) = (-x)\)</li>
    </ul>
  </li>
</ul>
<p>ただし可換性</p>
<ul>
  <li>\(x + y = y + x\)</li>
</ul>
<p>を追加で仮定する. 可換性のある群を <strong>可換群</strong> とか <strong>Abel 群</strong> などという.</p>
<p>ここに演算 \(\times\) とその単位元 \(1\) を新たに導入する.</p>
<ul>
  <li>
    \(e \colon I \to R\)
    <ul>
      <li>\(e(\ast) = 1 \in R\)</li>
    </ul>
  </li>
  <li>
    \(\mu \colon R \times R \to R\)
    <ul>
      <li>\(\mu(x,y) = x \times y (= xy)\)</li>
    </ul>
  </li>
</ul>
<p>ここで \((\times, 1)\) は次を満たす.</p>
<ul>
  <li>
    \(xyz = (x \times y) \times z = x \times (y \times z)\)
    <ul>
      <li>結合則</li>
    </ul>
  </li>
  <li>\(\exists 1 \in R, x = x \times 1 = 1 \times x\)</li>
</ul>
<p>この \((R,\times,1)\) は逆元の存在だけが仮定されていない群であるが, これを <strong>モノイド</strong> ともいう.</p>
<p>というわけで, \(R\) に加法群 \((R,+,0)\) という構造と, \((R,\times,1)\) というモノイドの構造を併せて入れた.</p>
<p><img src="https://i.imgur.com/7Dlrukb.jpg" alt="" /></p>
<p>ここにさらに \((+,\times)\) の分配則を要請する.</p>
<ul>
  <li>\((x+y) \times z = xz + yz\)</li>
  <li>\(x \times (y+z) = xy + xz\)</li>
</ul>
<p><img src="https://i.imgur.com/5WzeuqP.jpg" alt="" /></p>
<p>以上を満たす \((R,+,\times)\) を <strong>環</strong> という.</p>
<h3 id="3-0倍について">0倍について</h3>
<p>分配則より,</p>
\[x \times 0 = 0 \times x = 0\]
<p>が言える. というのも</p>
<ul>
  <li>\(x \times 0 = x \times (y + (-y)) = xy - xy = 0\)</li>
</ul>
<p>であるから.</p>
<h3 id="3-環の例">環の例</h3>
<p>整数とその上の普通の足し算と掛け算がまさしく環のモデルである. 足し算は可換群であるし, 掛け算はゼロがあるために逆元が一般には存在しないモノイドになっている.</p>
<h3 id="3-環の準同型">環の準同型</h3>
<p>2つの環 \(R,S\) の間の写像 \(\varphi \colon R \to S\) が準同型であるとは, やはりすべての構造が保たれること.</p>
<p><img src="https://i.imgur.com/z6Al47F.jpg" alt="" /></p>
<p>目新しさはない.</p>
<h3 id="3-イデアル">イデアル</h3>
<p>環 \((R,+,\times)\) があるとする. この加法群 \((R,+)\) の部分群 \((I,+)\) が</p>
<ul>
  <li>\(\forall a \in R, \forall x \in I, ax \in I\)</li>
</ul>
<p>を満たすとき, \(I\) を \(R\) の <strong>左イデアル</strong> だという. 左というのは \(ax\) という掛け算の順序を言っていて, これが逆になれば右イデアルという. 特に左イデアルでかつ右イデアルであるものを <strong>両側イデアル</strong> という. \(\times\) が可換ならもちろんイデアルはいつでも両側イデアル.</p>
<h4 id="4-イデアルの例">イデアルの例</h4>
<p>整数 \((\mathbb Z, +, \times)\) に対して, \(n \mathbb Z\) は（両側）イデアルになる. これは「 \(n\) の倍数は自由に整数倍をいくらしても尚 \(n\) の倍数である」と言っている.</p>
<h3 id="3-商環">商環</h3>
<p>環 \(R\) とその両側イデアル \(I\) があるとき, 商群と同じノリで, 商環 \(R&#x2F;I\) を定義できる.</p>
\[R&#x2F;I := \{ a+I \mid a \in R \}\]
\[(a+I) = (b+I) \iff (a-b) \in I\]
<p>ここで環としての構造は次の通り.</p>
<ul>
  <li>\(0 = (0+I)\)</li>
  <li>\((a+I) + (b+I) = ((a+b) + I)\)</li>
  <li>\(1 = (1+I)\)</li>
  <li>\((a+I) \times (b+I) = (ab + I)\)</li>
</ul>
<h3 id="3-準同型の核と像">準同型の核と像</h3>
<p>環の間の準同型 \(f \colon R \to S\) の核とは, 加法群に関する核のことで,</p>
\[\ker f := \{ x \in R \mid f(x) = 0 \}\]
<p>で定められる. \(f\) の像とは,</p>
\[\im f := \{ f(x) \mid x \in R \}\]
<p>のこと.</p>
<p>\(\ker f\) は \(R\) の両側イデアル. \(x \in R, y \in \ker f\) を自由にとってきたとき, \(f(xy) = f(x) f(y) = f(x) \times 0 = 0\) から \(xy \in \ker f\) が言える. \(0\) の掛け算は左右関係ないので両側イデアルになる.</p>
<h3 id="3-環の準同型定理">環の準同型定理</h3>
<p>式としては全く群の場合と同じことを書く.</p>
<p>環の間の準同型 \(f \colon R \to S\) があるとき,</p>
\[\bar f \colon R &#x2F; \ker f \to \im f\]
\[(x + \ker f) \mapsto f(x)\]
<p>は準同型でかつ同型を与える.</p>
<p>同型であることは群の場合の話と同じ. 準同型であることも \(+\) については群の話そのままなので \(\times\) だけ考える.</p>
<ul>
  <li>\(\bar f(1) = f(1) = 1\)</li>
  <li>\(\bar f( (x + \ker f) \times (y + \ker f) ) = \bar f(xy + \ker f) = f(xy) = f(x) \times f(y) = \bar f(x+\ker f) + \bar f(y+\ker f)\)</li>
</ul>
<p>自明なじゃないところがない.</p>
<h2 id="2-加群 (Module)">加群 (Module)</h2>
<h3 id="3-加群の定義">加群の定義</h3>
<p>加法群への環の作用のことを加群という.</p>
<p>環 \(R\) , 加法群 \((M,+)\) とその間の作用</p>
\[\lambda \colon R \times M \to M\]
\[(a, x) \mapsto ax\]
<p>が定められていて, 次を満たすとする.</p>
<ul>
  <li>m1) \(a(x+y) = ax+ay ,~ a \in R ,~ x,y \in M\)</li>
  <li>m2) \((a+b)x = ax+bx ,~ a,b \in R ,~ x \in M\)</li>
  <li>m3) \((ab)x = a(bx) ,~ a,b \in R ,~ x \in M\)</li>
  <li>m4) \(1x = x ,~ 1 \in R ,~ x \in M\)</li>
</ul>
<p>\(M\) を <strong>\(R\) -左加群</strong> という. この左とは作用の定義域 \(R \times M\) の順序を言っていて, 同様に \(M \times R \to M\) な作用を考えることで右加群を定義できる. その場合 m1-m4 はすべて逆にすればいいだけだが, 特に \(x(ab) = (xa)b\) は作用させる順番が逆になることに注意. 作用の順序が逆になっても構わない場合, 左加群であってかつ右加群になるわけだが, そのようなものは <strong>双加群</strong> という.</p>
<h3 id="3-加群の例">加群の例</h3>
<p>加群の作用のことを特に <strong>スカラー倍作用</strong> などと呼ぶが, これは次を見ると納得する.</p>
<p>環 \(R\) の上の線形空間 \(V\) は \(k\) -加群. ただし \(V\) は加算 \(+\) とゼロベクトル \(0\) によって加法群としている. 特に \(R\) の掛け算が可換なら双加群.</p>
\[\lambda \colon R \times V \to V\]
\[(x,v) \mapsto xv\]
<p>ベクトル \(v \in V\) を \(x\) 倍する作用.</p>
<h3 id="3-加群の準同型">加群の準同型</h3>
<p>環 \(R\) に対する2つの \(R\) -加群 \(M\) と \(N\) があって, この間の写像 \(f \colon M \to N\) を考える. これがやはりすべての構造を保つとき, 準同型であるという.</p>
<p>加法群 \((M,+,0)\) の群としての準同型はそのまま同じ. これに加えて作用も保っていないといけない. 次が可換であればよい.</p>
<p><img src="https://i.imgur.com/ms3AJsj.jpg" alt="" /></p>
<h3 id="3-部分加群">部分加群</h3>
<p>\(R\) -加群 \(M\) があって, これを単に加法群 \((M,+)\) と見たときのその部分群 \((N,+)\) があるとする. 元の作用が \(N\) の中で閉じているとき, つまり</p>
<ul>
  <li>\(\forall a \in R ,~ \forall n \in N ,~ an \in N\)</li>
</ul>
<p>とあるとき, \(N\) を部分加群という.</p>
<h4 id="4-部分加群の例">部分加群の例</h4>
<p>環 \(R\) 自体がその掛け算を作用とみなすことで \(R\) -加群である. 作用が対称なので, 左加群としても右加群としても定めることが出来るが仮に左加群ということにする.</p>
\[\lambda \colon R \times R \to R\]
\[(x,y) \mapsto x \times y\]
<p>\(R\) が左イデアル \(I\) を持つとき, これが加群 \(R\) の部分加群になる. 作用が閉じているということがイデアルの定義そのままになっている.</p>
\[\forall x \in R ,~ \forall y \in I ,~ xy \in I\]
<h3 id="3-商加群">商加群</h3>
<p>\(R\) -加群 \(M\) とその部分加群 \(N\) があるとする. このときに商加群 \(M&#x2F;N\) を定義する.</p>
<p>まず加法群としての商群</p>
\[M&#x2F;N := \{ (m+N) \mid m \in M \}\]
<p>を定める. ここにスカラー倍作用を</p>
\[\lambda(a, (m+N)) = a(m+N) = (am)+N\]
<p>で与える. こうするとこれは \(R\) -加群.</p>
<h3 id="3-加群の核と像">加群の核と像</h3>
<p>\(R\) -加群 \(M, N\) の間の準同型 \(f \colon M \to N\) があるときに,</p>
<ul>
  <li>\(\ker f := \{ m \in M \mid f(m)=0 \}\)</li>
  <li>\(\im f := \{ f(m) \mid m =in M \}\)</li>
</ul>
<p>これらはそれぞれ, 加法群としての \(M,N\) の部分群であることはすでに見た. ここに元のスカラー倍作用を入れれば, 部分化群でもある.</p>
<ul>
  <li>
    \(\ker f \subset M\)
    <ul>
      <li>\(\forall a \in R ,~ \forall x \in \ker f ,~ ax \in \ker f\)</li>
    </ul>
  </li>
  <li>
    \(\im f \subset N\)
    <ul>
      <li>\(\forall a \in R ,~ \forall f(m) \in \im f ,~ af(m) = f(am) \in \im f\)</li>
    </ul>
  </li>
</ul>
<h3 id="3-加群の準同型定理">加群の準同型定理</h3>
<p>\(R\) -加群の間の準同型 \(f \colon M \to N\) があるとき,</p>
\[\bar f \colon M &#x2F; \ker f \to \im f\]
\[(m + \ker f) \mapsto f(m)\]
<p>は準同型でかつ同型を与える.</p>
<p>加法群としての準同型, 同型であることは今まで見てきたとおり. 作用としての準同型も見ればよいが, これは次の通り.</p>
<ul>
  <li>\(a \bar{f}(m + \ker f) = a f(m) = f(am) = \bar f (am + \ker f)\)</li>
</ul>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>