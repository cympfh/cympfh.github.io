# 数列 - セグメントツリー

## 概要

[モノイド](algebra.monoid) $(X, \times, 1)$ と $X$ 上の数列
$$(x_1, \ldots, x_N \mid x_i \in X)$$
について, 次の操作がそれぞれ $O(\log N)$ で出来る.

- 区間積の計算
    - 添字区間 $I$ について $\prod_{i \in I} x_i$
- 一点更新
    - $x_i \leftarrow x_{\mathrm{new}}$

## 手法の概略

区間とその積をノードに持つ (完全) 二分木を構成する.
つまり, 区間 $I$ に対応するノード $\mathcal{N}_I$ があって, その積
$p_I = \prod_{i \in I} x_i$
を **予め** 計算しておく.

区間 $I$ が空でないならば,
それを左右に分割した区間 $J_1$ と $J_2$ に分割できるだろう（二等分が望ましい）.
という訳で $\mathcal{N}_I$ の子ノードとして
$\mathcal{N}_{J_1}$ と $\mathcal{N}_{J_2}$ を持たせる.
もちろん $p_{J_1}, p_{J_2}$ も予め計算しておく.

根を全体区間 $[0, N)$ とし,
葉を一つの要素からなる区間 $\{ x_i \}$ とする二分木が構成できたら,
これがセグメントツリーである.
セグメントツリーが持つノード数（つまり区間数）は $2N$ 程度.

予め計算しておきたい $p$ は再帰的に

$$p_I = p_{J_1} \times p_{J_2}$$

とできるので, 葉から辿ってくことで, 積演算を $2N$ 回すればよく, 木の構築は $O(N)$ で出来る.

任意の区間積の計算は, 求めたい区間をちょうど被覆するノード $O(\log N)$ 個程度に必ず分解できる.
（これは $N$ 程度の自然数は二進数で $\log_2 N$ 桁で表せることに対応している.）
含むノードを大きいものから貪欲に選んでいけばよい.

更新は, 葉ノードを更新した後に, その親ノードを辿っていき $p$ を更新していけばよい.
このとき辿るノード数は木の高さなので $O(\log N)$ である.

## 実装

コンストラクタとして, 長さだけ指定して単位元で初期化する `new` と,
数列を `vec` で与える `from` とがある.

@[rust](procon-rs/src/sequence/tree/segment_tree.rs)
