<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dosoku/</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body class="rust">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="intro.html"><strong aria-hidden="true">1.</strong> What is this?</a></li><li><a href="SUMMARY.html"><strong aria-hidden="true">2.</strong> 量子計算</a></li><li><ol class="section"><li><a href="quantum/model.html"><strong aria-hidden="true">2.1.</strong> 計算モデル</a></li><li><a href="quantum/deutsch.html"><strong aria-hidden="true">2.2.</strong> 量子並列性, ドイチュのアルゴリズム</a></li><li><a href="quantum/unitary.html"><strong aria-hidden="true">2.3.</strong> ユニタリー変換</a></li><li><a href="quantum/algorithm_exact_threshold.html"><strong aria-hidden="true">2.4.</strong> EXACT, THRESHOLD アルゴリズム</a></li></ol></li><li><a href="SUMMARY.html"><strong aria-hidden="true">3.</strong> ラムダ計算</a></li><li><ol class="section"><li><a href="lambda/basic.html"><strong aria-hidden="true">3.1.</strong> 計算モデル</a></li><li><a href="lambda/ski.html"><strong aria-hidden="true">3.2.</strong> SKIコンビネータ</a></li><li><a href="lambda/fixed.html"><strong aria-hidden="true">3.3.</strong> 不動点コンビネータ</a></li></ol></li><li><a href="SUMMARY.html"><strong aria-hidden="true">4.</strong> ゲーム理論</a></li><li><ol class="section"><li><a href="SUMMARY.html"><strong aria-hidden="true">4.1.</strong> 組み合わせゲーム</a></li><li><ol class="section"><li><a href="game/comb/alg.html"><strong aria-hidden="true">4.1.1.</strong> ゲームの代数</a></li><li><a href="game/comb/grundy.html"><strong aria-hidden="true">4.1.2.</strong> グランディ数 (ニム数)</a></li></ol></li><li><a href="SUMMARY.html"><strong aria-hidden="true">4.2.</strong> 行列ゲーム</a></li></ol></li><li><a href="SUMMARY.html"><strong aria-hidden="true">5.</strong> 形式言語</a></li><li><ol class="section"><li><a href="formallang/limit_identification.html"><strong aria-hidden="true">5.1.</strong> 極限同定</a></li><li><a href="formallang/kmmg.html"><strong aria-hidden="true">5.2.</strong> 汎化システムと極小言語</a></li></ol></li><li><a href="SUMMARY.html"><strong aria-hidden="true">6.</strong> 圏論</a></li><li><ol class="section"><li><a href="cat/basic.html"><strong aria-hidden="true">6.1.</strong> 基礎</a></li><li><a href="cat/f-alg.html"><strong aria-hidden="true">6.2.</strong> F代数</a></li><li><a href="cat/adj_monado.html"><strong aria-hidden="true">6.3.</strong> 随伴, モナド</a></li><li><a href="cat/eval.html"><strong aria-hidden="true">6.4.</strong> 冪対象, eval</a></li></ol></li><li><a href="SUMMARY.html"><strong aria-hidden="true">7.</strong> 群論</a></li><li><ol class="section"><li><a href="group/basic.html"><strong aria-hidden="true">7.1.</strong> 基礎</a></li></ol></li><li><a href="SUMMARY.html"><strong aria-hidden="true">8.</strong> 線形代数</a></li><li><ol class="section"><li><a href="linearalg/tensor.html"><strong aria-hidden="true">8.1.</strong> テンソルとはなにか</a></li></ol></li><li><a href="SUMMARY.html"><strong aria-hidden="true">9.</strong> 位相空間</a></li><li><ol class="section"><li><a href="topological/basic.html"><strong aria-hidden="true">9.1.</strong> 基礎</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">dosoku/</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-this" id="what-is-this">What is this?</a></h1>
<p>Blog style <a href="http://cympfh.cc/aiura">aiura/</a> \( \to \) Book style <a href="http://cympfh.cc/dosoku">dosoku/</a></p>
<p>Using <a href="https://github.com/rust-lang-nursery/mdBook">mdbook</a></p>
<hr />
<p>Author: <code>@cympfh</code>,
Mail: <code>cympfh@gmail.com</code></p>
<h1><a class="header" href="#summary" id="summary">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#計算モデル" id="計算モデル">計算モデル</a></h1>
<p>\[ \newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\true}{\mathrm{true}}
\newcommand{\false}{\mathrm{false}}
\newcommand{\exact}{\mathrm{EXACT}}
\newcommand{\threshold}{\mathrm{THRESHOLD}}
\newcommand{\concat}{+\!\!\!+} \]</p>
<p>ここではあくまでも計算モデルとして量子計算を眺め, なにが実現出来るかを調べる.
物理学的な視点にはあまり興味がない.</p>
<p>まず量子計算を支える qbit (量子ビット) がどのような性質を持つかを説明する.
次にどのようなゲート (回路) が実現可能で qbit を操作できるかを紹介する.
ただしいずれも物理的原理までは立ち入らず紹介するだけに留める.</p>
<h2><a class="header" href="#qbit-量子ビット-qbit-qubit" id="qbit-量子ビット-qbit-qubit">qbit (量子ビット, Qbit, qubit)</a></h2>
<p>古典コンピュータにおける計算にはbitを用いる.
これは \( 0 \) または \( 1 \) のいずれかの状態を取るものである.
対して qbit はこの2つの状態を確率的に持つ.
具体的には2つの状態の線型結合として記述される.</p>
<p>qbit が \( 0 \) である状態を \( \ket{0} \),
qbit が \( 1 \) である状態を \( \ket{1} \) と書く (bra-ket 記法という) ことにし,
一般の状態はこの2つの重ねあわせ (線型結合):
\[ \alpha \ket{0} + \beta \ket{1} \]
で表される.
ここで \( \alpha, \beta \) は複素数を取り \( (\alpha, \beta \in \mathbb C) \),
また物理学の要請から
\[ |\alpha|^2 + |\beta|^2 = 1 \]
という制約を要請される.</p>
<blockquote>
<p><strong>復習</strong>: 複素数 \( z \in \mathbb C \) は, 実数 \( x, y \in \mathbb R \) によって
\( z = x + y i \) で一意に表現される値で,
これについて共役数 \( \bar{z} = x - y i (\in \mathbb C) \) と
\( |z|^2 = \bar{z} \cdot z = x^2 + y^2 (\in \mathbb R) \) を定めるのだった.</p>
</blockquote>
<blockquote>
<p><strong>補足</strong>: 係数の制約を無視すれば, qbit の取り得る空間というのは
2つの基底 \( \ket{0}, \ket{1} \) からなる二次元の複素数上のベクトル空間である.
制約があるので実際にはこれの部分空間であっても, 部分ベクトル空間ではないが.</p>
</blockquote>
<h3><a class="header" href="#観測" id="観測">観測</a></h3>
<p>qbit は状態の重ね合わせだと言ったが実は実際に観測をすると,
\( \ket{0} \) または \( \ket{1} \) のどちらかに見える.</p>
<p>先程, 係数には制約 \( |\alpha|^2 + |\beta|^2 = 1 \) があると述べたが,
実はこれらはどちらに観測されるかの確率になっている.</p>
<p>すなわち, ある qbit, \( \alpha \ket{0} + \beta \ket{1} \) を実際に観測すると,
確率 \( |\alpha|^2 \) で \( \ket{0} \) を得,
確率 \( |\beta|^2 \) で \( \ket{1} \) を得る.
(確率の和はちょうど \( 1 \) になっており不都合はない.)</p>
<p>そして観測という行為は qbit に干渉する.
一度状態が確定すると, 以降何度観測をしても初めに得た結果を得るだけである.
即ち, 一度 \( \ket{0} \) を観測したならば, その qbit は
\( \ket{0} = 1 \cdot \ket{0} + 0 \cdot \ket{1} \)
に <strong>収束</strong> したと言える.</p>
<h3><a class="header" href="#-n--qbit" id="-n--qbit">\( n \) qbit</a></h3>
<p>bit を \( n \) 個並べたものを \( n \) bit と言うように,
qbit を \( n \) 個並べたものを \( n \) qbit と呼ぶことにする.</p>
<ul>
<li>\( n \) qbit は
<ul>
<li>自由に一列に並べられる</li>
<li>自由に一部を取り出せる</li>
<li>自由に一部だけを観測できる</li>
</ul>
</li>
</ul>
<p>特に <strong>並べる</strong> という操作を二項演算子 \( \otimes \) で表すことにする.
\( n \) qbit \( x \) と \( m \) qbit \( y \) を並べることで
\( n+m \) qbit \( x \otimes y \) を得る.
ここで並べる場合には順序があるので \( x \otimes y \ne y \otimes x \) であることに註意.</p>
<p>簡単に \( 2 \) qbit について考える.
\( \ket{0} \) の右に \( \ket{1} \) を並べて得る 2 qbit を
\[ \ket{01} := \ket{0} \otimes \ket{1} \]
と書くことにする.
すると 2 qbitは
\[ \ket{00}, \ket{01}, \ket{10}, \ket{11} \]
の4通りの状態を取り得る.
実際にはそれぞれの qbit は重ね合わせであるから, 2 qbit はこの4通りの重ね合わせになる:
\[ \alpha_{00} \ket{00} + \alpha_{01} \ket{01} + \alpha_{10} \ket{10} + \alpha_{11} \ket{11} \]</p>
<p>2 qbit のそれぞれが \( \beta_0 \ket{0} + \beta_1 \ket{1} \) と \( \gamma_0 \ket{0} + \gamma_1 \ket{1} \) だったとするとき, 形式的に</p>
<p>\[ (\beta_0 \ket{0} + \beta_1 \ket{1}) \otimes (\gamma_0 \ket{0} + \gamma_1 \ket{1}) =
\beta_0 \gamma_0 \ket{00} +
\beta_0 \gamma_1 \ket{01} +
\beta_1 \gamma_0 \ket{10} +
\beta_1 \gamma_1 \ket{11} \]</p>
<p>という掛け算をすればよい.
係数はただの掛け算で \( \ket{\cdot} \) は横に結合させるだけ.
実際,
\( \ket{00} \) を観測する確率は, 同時確率なので
\( |\beta_0|^2 |\gamma_0|^2 = |\beta_0 \gamma_0|^2 \)
となっていて,
\( \alpha_{00} = \beta_0 \gamma_0 \) とすれば都合がよい.
同様に \( \alpha_{ij} = \beta_i \gamma_j \) とすればよく,
\( \ket{ij} \) を観測する確率は \( |\alpha_{ij}|^2 \) だと言える.
\( \sum_{i,j} |\alpha_{ij}|^2 = 1 \) は各 qbit の係数の制約から従う.</p>
<h4><a class="header" href="#部分的観測" id="部分的観測">部分的観測</a></h4>
<p>\( n \) qbit の内 1 qbit だけを観測した結果,
その qbit の状態は先述したとおり, 観測された状態に確定して固定されるが,
残りの \( n-1 \) qbit についてはなおも重ね合わせの状態を保ったままで観測が干渉することはない.</p>
<p>例として, 2 qbit
\[ \alpha_{00} \ket{00} + \alpha_{01} \ket{01} + \alpha_{10} \ket{10} + \alpha_{11} \ket{11} \]
を考える.
これの 1 qbit 目を観測した結果 \( \ket{0} \) を得たとする.
1 qbit 目は \( 0 \) で固定されるので,
観測しうる状態は \( \ket{00} \) または \( \ket{01} \) だけであるので,
観測後の 2 qbit は,
\[ \alpha_{00}' \ket{00} + \alpha_{01}' \ket{01} \]
で表される.</p>
<p>\( \alpha_{00}' \), \( \alpha_{01}' \) はどうなるかと言うと, これらは結局, 2 qbit 目が
\( \ket{0} \), \( \ket{1} \) で観測される確率 (の平方根) であって,
(それは観測の前後で変化しない)</p>
<p>元の 2 qbit が
\( \beta_0 \ket{0} + \beta_1 \ket{1} \)
と
\( \gamma_0 \ket{0} + \gamma_1 \ket{1} \)
だったとすると,
観測後の事後確率なので</p>
<ul>
<li>\( \alpha_{00}' = \gamma_0 \)</li>
<li>\( \alpha_{01}' = \gamma_1 \)</li>
</ul>
<p>と言える.
また先程見たように \( \alpha_{00} = \beta_0 \gamma_0 \)
なので,
\( \alpha_{00} = \beta_0 \alpha_{00}' \).
同様に
\( \alpha_{01} = \beta_0 \alpha_{01}' \).</p>
<p>従って \( \beta_0 \) の逆数を単に定数 \( \kappa \) と書くことにすると,
事後の 2 qbit は
\[ \kappa \alpha_{00} \ket{00} + \kappa \alpha_{01} \ket{01} \]
と書ける.</p>
<p>さて係数の自乗和が \( 1 \) である性質から実は \( \kappa \) は決まる.
即ち,
\[ |\kappa|^2 (|\alpha_{00}|^2 + |\alpha_{01}|^2) = 1 \]
があるので \( \kappa \) の大きさは決まる.</p>
<h2><a class="header" href="#量子ゲート" id="量子ゲート">量子ゲート</a></h2>
<p>qbit に対する実現可能な操作で次のようなゲートを作成することが理論上可能である.</p>
<h3><a class="header" href="#量子not" id="量子not">量子NOT</a></h3>
<p>次のような操作 \( X \) が存在する:</p>
<ul>
<li>\( X \ket{0} = \ket{1} \)</li>
<li>\( X \ket{1} = \ket{0} \)</li>
</ul>
<p>この操作 \( X \) は線形写像のように働く.
即ち,
\[ X (\alpha \ket{0} + \beta \ket{1}) = \alpha \ket{1} + \beta \ket{0} \]
となる.</p>
<h3><a class="header" href="#制御-controlled-not" id="制御-controlled-not">制御 (controlled) NOT</a></h3>
<p>次のような 2 qbit に対する操作 \( X \) が存在する:</p>
<ul>
<li>\( X \ket{i, j} = \ket{i, i \oplus j} \)</li>
</ul>
<p>ここで \( \oplus \) は排他的論理和で,
\( 0 \oplus j = j \),
\( 1 \oplus j = 1 - j \).</p>
<h3><a class="header" href="#アダマール-hadamard-ゲート" id="アダマール-hadamard-ゲート">アダマール (Hadamard) ゲート</a></h3>
<p>次のような \( H \) が存在する:</p>
<ul>
<li>\( H \ket{0} = \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1} \)</li>
<li>\( H \ket{1} = \frac{1}{\sqrt{2}} \ket{0} - \frac{1}{\sqrt{2}} \ket{1} \)</li>
</ul>
<p>\( H \) は二回通すことで恒等写像になる.</p>
<p>\( H \ket{0} \) のことを \( \ket{+} \),
\( H \ket{1} \) のことを \( \ket{-} \) と書くことにする.
この符号はもちろん2つの状態が和になってるか差になってるかを意味している.</p>
<blockquote>
<p><strong>補足</strong>:
これも重ね合わせの状態については線形写像のように働く.
ところで, 重ね合わせられてない状態というのは, 実際に観測すれば容易に手に入る.
それをアダマールゲートに通すと,
2つの状態が同確率で観測されるような状態の qbit が手に入る.
また \( H \) を組み合わせることで,
全ての \( 2^n \) 状態が等確率で観測できる \( n \) qbit を作ることができる.</p>
</blockquote>
<h1><a class="header" href="#量子並列性とドイチュのアルゴリズム" id="量子並列性とドイチュのアルゴリズム">量子並列性とドイチュのアルゴリズム</a></h1>
<p>\[ \newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\true}{\mathrm{true}}
\newcommand{\false}{\mathrm{false}}
\newcommand{\exact}{\mathrm{EXACT}}
\newcommand{\threshold}{\mathrm{THRESHOLD}}
\newcommand{\concat}{+\!\!\!+} \]</p>
<h2><a class="header" href="#量子並列性" id="量子並列性">量子並列性</a></h2>
<p>\( n \) qbit の基底の状態 \( \ket{ij\ldots k} \) を普通の古典 \( n \) bit \( i,j,\ldots,k \) と同一視する.
\( n \) bit を入力にして 1 bit を出力する古典回路 \( f \) について,
同程度の効率で計算できる次のような量子ゲート \( U_f \) が存在する:
\[ U_f (x \otimes \ket{i}) = x \otimes \ket{i \oplus f(x)} \]
ここで \( x \) は \( n \) qbit.
\( i \) は \( 0 \) または \( 1 \) (もちろん) で, \( \oplus \) は排他的論理和.</p>
<p>さて, アダマールゲートを用いれば2つの状態を全く同等に含んだ量子を作れるのだった.
それを \( U_f \) に通すことで,
<strong>実質的に</strong> \( f(0) \) と \( f(1) \) を並列に計算するようなことができる.
具体的には次を実行する.</p>
<ol>
<li>\( H \ket{0} \) に \( \ket{0} \) を並べる
<ul>
<li>\( (H \ket{0}) \otimes \ket{0} = \frac{1}{\sqrt{2}} \ket{00} + \frac{1}{\sqrt{2}} \ket{10} \)</li>
</ul>
</li>
<li>これを \( U_f \) に通す
<ul>
<li>\( \frac{1}{\sqrt{2}} \ket{0, f(0)} + \frac{1}{\sqrt{2}} \ket{1, f(1)} \)</li>
</ul>
</li>
</ol>
<p>一度の \( U_f \) の計算で \( f(0) \) と \( f(1) \) が行われているのが分かる.
この性質を <strong>量子並列性</strong> という.
ただし, これをこのまま観測するだけでは結局そのどちらか
\( \ket{x, f(x)} \)
しか得られない.
並列性のメリットを享受するには工夫が必要である.
その古典的な一例であるドイチュのアルゴリズムを次に見る.</p>
<h2><a class="header" href="#ドイチュのアルゴリズム-deutschs-algorithm" id="ドイチュのアルゴリズム-deutschs-algorithm">ドイチュのアルゴリズム (Deutsch's algorithm)</a></h2>
<p>1 bit から 1 bit を出力する古典回路 \( f \) について,
\( f(0) \oplus f(1) \) を一度の \( U_f \) (\( f \) 相当の計算) で計算することができる.</p>
<p>アルゴリズムは次の通り:</p>
<ol>
<li>\( \ket{+} = H \ket{0} \) と \( \ket{-} = H \ket{1} \) を得る
<ul>
<li>これを並べたものを \( \ket{+-} = \ket{+} \otimes \ket{-} \) とする</li>
</ul>
</li>
<li>\( \ket{\phi_1, \phi_2} = U_f \ket{+-} \)</li>
<li>\( H \ket{\phi_1, \phi_2} = H \ket{\phi_1} \otimes H\ket{\phi_2} \) を計算して 1 qbit 目を観測する</li>
</ol>
<p>具体的に計算を追う.</p>
<ol>
<li>\( \ket{+-} = \ket{+} \otimes \ket{-} = \frac{1}{2} (\ket{00} - \ket{01} + \ket{10} - \ket{11}) \)</li>
<li>\( U_f \ket{+-} = \frac{1}{2} (\ket{0,f(0)} - \ket{0,1-f(0)} + \ket{1,f(1)} - \ket{1,1-f(1)}) \)</li>
<li>\( H(U_f \ket{+-}) = \frac{1}{2} \left[ (\ket{+} \otimes H\ket{f(0)}) - (\ket{+} \otimes H\ket{1 - f(0)}) + (\ket{-} \otimes H\ket{f(1)}) + (\ket{-} \otimes H\ket{1 - f(1)}) \right] \)</li>
</ol>
<p>最期の式を更に詳細に計算する.</p>
<p>初めの2項
\( (\ket{+} \otimes H\ket{f(0)}) - (\ket{+} \otimes H\ket{1 - f(0)}) \)
を調べる.
\( f(0), 1-f(0) \) はちょうど一方が 0 なら他方は 1 である.</p>
<p>\( f(0) = 0 \) のとき,</p>
<p>\[ \begin{align*}
(\ket{+} \otimes H\ket{f(0)}) - (\ket{+} \otimes H\ket{1 - f(0)})
&amp; = \ket{+} \otimes (\ket{+} - \ket{-}) \\\
&amp; = \ket{+} \otimes (\sqrt{2} \ket{1}) \\\
&amp; = \sqrt{2} (\ket{+} \otimes \ket{1})
\end{align*} \]</p>
<p>同様に \( f(0)=1 \) のとき,</p>
<p>\[ \begin{align*}
(\ket{+} \otimes H\ket{f(0)}) - (\ket{+} \otimes H\ket{1 - f(0)})
&amp; = - \sqrt{2} (\ket{+} \otimes \ket{1})
\end{align*} \]</p>
<p>である. この2つの場合をまとめて
\[ (\ket{+} \otimes H\ket{f(0)}) - (\ket{+} \otimes H\ket{1 - f(0)}) = (-1)^{f(0)} \sqrt{2} \ket{+1} \]
と書ける.
ここで \( \ket{+} \otimes \ket{1} \) を \( \ket{+1} \) と書いた.</p>
<p>また残りの2項についても同様に
\[ (\ket{-} \otimes H\ket{f(1)}) - (\ket{-} \otimes H\ket{1 - f(1)})
= (-1)^{f(1)} \sqrt{2} \ket{-1} \]
となる.</p>
<p>というわけで
\[ \begin{align*}
H(U_f\ket{+-})
&amp; = \frac{1}{2} \left[
(-1)^{f(0)} \sqrt{2} \ket{+1} + (-1)^{f(1)} \sqrt{2} \ket{-1}
\right] \\\
&amp; = \frac{1}{\sqrt{2}} \left[
(-1)^{f(0)} \ket{+1} + (-1)^{f(1)} \ket{-1}
\right]
\end{align*} \]</p>
<p>を得る.</p>
<p>2 qbit 目は常に \( 1 \) であることがわかる.
さて 1 qbit 目にだけ注目すると
\[ \frac{1}{\sqrt{2}}\left[ (-1)^{f(0)} \ket{+} + (-1)^{f(1)} \ket{-} \right] \]
である.
\( f(0), f(1) \) によって4通りに場合分けをすると,</p>
<ol>
<li>case \( f(0)=0, f(1)=0 \)
<ul>
<li>\( \frac{1}{\sqrt{2}} (\ket{+} + \ket{-})) = \ket{0} \)</li>
</ul>
</li>
<li>case \( f(0)=0, f(1)=1 \)
<ul>
<li>\( \frac{1}{\sqrt{2}} (\ket{+} - \ket{-})) = \ket{1} \)</li>
</ul>
</li>
<li>case \( f(0)=1, f(1)=0 \)
<ul>
<li>\( \frac{1}{\sqrt{2}} (- \ket{+} + \ket{-})) = - \ket{1} \)</li>
</ul>
</li>
<li>case \( f(0)=1, f(1)=1 \)
<ul>
<li>\( \frac{1}{\sqrt{2}} (- \ket{+} - \ket{-})) = - \ket{0} \)</li>
</ul>
</li>
</ol>
<p>観測する場合にはその係数の大きさの自乗の確率で状態を得る.
係数はそれぞれ \( +1 \) または \( -1 \) になっているから結局必ず \( \ket{0} \) または \( \ket{1} \) を得ることになり, それは \( f(0) \oplus f(1) \) と一致している.
例えば \( f(0)=1, f(1)=0 \) の場合は \( -\ket{1} \) を得, 観測した結果 \( (-1)^2 \) の確率で \( \ket{1} \) を得る.</p>
<h1><a class="header" href="#ユニタリー変換" id="ユニタリー変換">ユニタリー変換</a></h1>
<p>\[ \newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\true}{\mathrm{true}}
\newcommand{\false}{\mathrm{false}}
\newcommand{\exact}{\mathrm{EXACT}}
\newcommand{\threshold}{\mathrm{THRESHOLD}}
\newcommand{\concat}{+\!\!\!+} \]</p>
<h2><a class="header" href="#qbit-の数ベクトル表示" id="qbit-の数ベクトル表示">qbit の数ベクトル表示</a></h2>
<p>\( n \) qbit が取り得る状態は \( 2^n \) つの基底
\[ \ket{0\ldots 000},~
\ket{0\ldots 001},~
\ket{0\ldots 010},~
\ldots ,~
\ket{1\ldots 111} \]
の線型結合
\[ \sum \alpha_{i_1,i_2,\ldots,i_n} \ket{i_1 i_2 \cdots i_n} \]
で表される.
ここでこの qbit の状態を
\[ \left[\begin{array}{c}
\alpha_{0\ldots 000} \\
\alpha_{0\ldots 001} \\
\alpha_{0\ldots 010} \\
\vdots \\
\alpha_{1\ldots 111}
\end{array}\right] \in \mathbb C^{2^n} \]
で表示する.</p>
<h2><a class="header" href="#ユニタリ変換" id="ユニタリ変換">ユニタリ変換</a></h2>
<p>複素正方行列 \( U \) で
\[ U^\dagger U = UU^\dagger = I \]
を満たす行列をユニタリ行列という.
ここで \( I \) は単位行列,
\( U^\dagger \) は成分の共役を取って転置した行列のこと \( (U^\dagger = (U^*)^T) \).</p>
<h3><a class="header" href="#性質" id="性質">性質</a></h3>
<p>2つのユニタリ行列 \( U,V \) の積 \( UV \) もユニタリ行列.</p>
<h3><a class="header" href="#定理" id="定理">定理</a></h3>
<p>任意のユニタリ変換を再現する量子ゲートが存在する.</p>
<p>ここでユニタリ変換とは, qbit を数ベクトル表示したときに右からユニタリ行列を掛ける操作のことを言う.
\[ 
\left[\begin{array}{c}
\beta_{0\ldots 000} \\
\beta_{0\ldots 001} \\
\beta_{0\ldots 010} \\
\vdots \\
\beta_{1\ldots 111}
\end{array}\right] =
U
\left[\begin{array}{c}
\alpha_{0\ldots 000} \\
\alpha_{0\ldots 001} \\
\alpha_{0\ldots 010} \\
\vdots \\
\alpha_{1\ldots 111}
\end{array}\right] \]
は qbit \( \alpha \) を量子ゲート \( U \) に通した結果 qbit \( \beta \) を得る操作を表す.
逆に \( U \) がユニタリ行列であるならば, 量子ゲートで必ず再現できる.</p>
<p>このような行列 \( U \) の大きさは \( 2^n \times 2^n \) と, 2のべき乗でないといけないが,
実際には気にする必要はない.
一般の \( m \) (\( 2^{n-1} \lt m \leq 2^n \)) について,
ユニタリー行列 \( U \in \mathbb{C}^{m\times m} \) に \( 2^n-m \) 個, サイズを広げて,
\[ U' = \left[\begin{array}{ccccc}
&amp; &amp; &amp; &amp; \\
&amp; U &amp; &amp; &amp; \\
&amp; &amp; &amp; &amp; \\
&amp; &amp; &amp; 1 &amp; \\
&amp; &amp; &amp; &amp; 1
\end{array}\right] \]</p>
<p>広げた部分は対角に \( 1 \) を置いてできる行列 \( U' \) も問題なくユニタリー行列.</p>
<p>\( n \) qbit であるが実際には \( 2^n \) 状態の内 \( m \) 状態しか取り得ないようなもの長さ \( m \) の列ベクトルで表現でき, \( m \times m \) 行列 \( U \) で, 操作を記述すればよい.
実際には余白を \( 0 \) で埋めた長さ \( 2^n \) の列ベクトルを \( 2^n \times 2^n \) 行列 \( U' \) で操作したものだとすれば問題ない.</p>
<h3><a class="header" href="#例-量子-not" id="例-量子-not">例: 量子 NOT</a></h3>
<p>量子NOTというゲート \( X \) は
\( \alpha \ket{0} + \beta \ket{1} \) を
\( \beta \ket{0} + \alpha \ket{1} \) に写す.</p>
<p>即ち
\[ \left[\begin{array}{c}
\beta \\
\alpha
\end{array}\right] =
X
\left[\begin{array}{c}
\alpha \\
\beta
\end{array}\right] \]
となれば良いが, これは
\[ X = \left[\begin{array}{cc} 0 &amp; 1 \\ 1 &amp; 0 \end{array}\right] \]
であってユニタリ行列になっている.</p>
<h3><a class="header" href="#例-制御-not" id="例-制御-not">例: 制御 NOT</a></h3>
<p>次のようになっていることがすぐ分かる.
ただし基底として, 順に
\( \ket{00}, \ket{01}, \ket{10}, \ket{11} \).</p>
<p>\[ \left[\begin{array}{cc}
1 &amp; &amp; &amp; \\
&amp; 1 &amp; &amp; \\
&amp; &amp; &amp; 1 \\
&amp; &amp; 1 &amp;
\end{array}\right] \]
これもやはりユニタリー行列である.</p>
<h1><a class="header" href="#exact-threshold-アルゴリズム" id="exact-threshold-アルゴリズム">EXACT, THRESHOLD アルゴリズム</a></h1>
<p>\[ \newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\true}{\mathrm{true}}
\newcommand{\false}{\mathrm{false}}
\newcommand{\exact}{\mathrm{EXACT}}
\newcommand{\threshold}{\mathrm{THRESHOLD}}
\newcommand{\concat}{+\!\!\!+} \]</p>
<h2><a class="header" href="#紹介する論文" id="紹介する論文">紹介する論文</a></h2>
<ul>
<li>&quot;Exact quantum query complexity of EXACT and THRESHOLD&quot;</li>
<li>Andris Ambainis, Jānis Iraids, Juris Smotrovs</li>
<li><a href="https://arxiv.org/abs/1302.1235">arxiv.org/abs/1302.1235</a></li>
</ul>
<p>与えられた \( n \) bit (qbit ではない) について立ってる (\( 1 \) である) ビットの数を数えるアルゴリズム.
正確に述べると,
立ってるビットの数がちょうど \( k \) であるか判定する \( \exact^n_k \) と,
\( k \) 以上であるか判定する \( \threshold^n_k \) の2つのアルゴリズムを与える.</p>
<blockquote>
<p>もちろん量子計算を用いない古典コンピュータなら全てのビットをチェックする必要がある.</p>
</blockquote>
<h2><a class="header" href="#notation" id="notation">notation</a></h2>
<p>\( n \) qbit の基底の内, \( i \) 番目 (\( 0 \)-indexed) の qbit だけが立ってるもの
\( \ket{0\cdots 0 1 0 \cdots 0} \)
を
\[ \ket{i} \]
と書くことにする (\( i=0,1,\ldots,n-1 \)).</p>
<p>2つの \( n \) qbit \( \ket{i} \) と \( \ket{j} \) とを並べたものを
\[ \ket{i, j} := \ket{i} \otimes \ket{j} \]
と書く.</p>
<p>更にそれが \( 2n \) qbit であることが紛らわしく無ければ,
\[ \ket{i} := \ket{i, i} \]
と書く.</p>
<blockquote>
<p><strong>補足</strong>: 実際には, 中身の表現はどうでもよくて, 要するに区別できる状態であればよい.
つまり \( \ket{\cdot} \) の中に書く数字は単なるラベルだとしか思ってない.</p>
</blockquote>
<p>1 qbit \( \ket{x} \) (\( x=0,1 \)) に対して
\( (-1)^x \) を \( \hat{x} \) と書く (\( \hat{x}=1,-1 \)).</p>
<h2><a class="header" href="#query-量子クエリ" id="query-量子クエリ">Query (量子クエリ)</a></h2>
<p>これから EXACT と THRESHOLD という2つのアルゴリズムを説明するが,
共に \( Q \) という操作が登場する.
これは入力 \( x_1, x_2,\ldots , x_n \) に依存する写像であって,</p>
<ul>
<li>\( Q \ket{i} = \hat{x}_i \ket{i} \)</li>
</ul>
<p>で定めるものである.
このように入力に依存する操作をクエリと呼ぶ.</p>
<p>1回のクエリの処理 (\( Q \) の適用) のたびに, 入力 \( x_i \) を一回読む必要がある.
アルゴリズムの複雑性として, クエリを処理する回数を指標とする.
これを量子クエリ計算量という.</p>
<h2><a class="header" href="#exact" id="exact">EXACT</a></h2>
<p>\( n \) qbit
\[ x=(x_0 x_1 \cdots x_{n-1}) \]
の内, ちょうど \( k \) 個が立ってるか判定するアルゴリズムを
\( \exact^n_k \)
とする.</p>
<p>\[ \exact^n_k : \{0,1\}^n \to \{\true, \false\} \]</p>
<p>今から述べる彼らのアルゴリズムでは \( 2n \) qbit を用意する.
取り得る状態は
\( \ket{i} \) と \( \ket{i,j} \) \( (0 \leq i,j \lt n; i \lt j) \)
の \( n(n+1)/2 \) 個だけとし, 初め \( \ket{0} \) であるとする.
従って, 長さ \( n(n+1)/2 \) の複素ベクトルで状態は表現される.</p>
<p>さていきなり一般の \( \exact^n_k \) を考えるのは難しいので,
まずは \( \exact^{2k}_k \) の場合を考える.</p>
<h3><a class="header" href="#-exact2k_k-" id="-exact2k_k-">\( \exact^{2k}_k \)</a></h3>
<p>全体が偶数ビットで, 内のちょうど半分のビットが立ってるかを判定する.
このことは,
ビットそれぞれを \( x \mapsto \hat{x} \) としたときのその和 \( \sum_i \hat{x}_i \) がゼロになることと等しいことを利用する.
\[ \exact^{2k}_k(x) = \true \iff \sum_i \hat{x}_i = 0 \]</p>
<p>次の3つの操作を用いる:</p>
<ol>
<li>\( U_1 \ket{0} = \frac{1}{\sqrt{2k}} \sum_{i=0}^{2k-1} \ket{i} \)</li>
<li>クエリ \( Q \)</li>
<li>\( U_2 \ket{i} = \frac{1}{\sqrt{2k}} \left( \sum_{i \lt j} \ket{i,j} - \sum_{i \gt j} \ket{j,i} + \ket{0} \right) \)</li>
</ol>
<p>ここで未定義な値 (e.g. \( U_1\ket{1} \)) はどう定義してもいいので \( U_1, U_2 \) をユニタリー行列になるようにする.</p>
<p>\( \ket{0} \) にこれらを順に通す:</p>
<ol>
<li>初期状態
<ul>
<li>\( \ket{0} \)</li>
</ul>
</li>
<li>\( U_1 \)
<ul>
<li>\( \frac{1}{\sqrt{2k}} \sum_{i=0}^{2k-1} \ket{i} \)</li>
</ul>
</li>
<li>\( Q \)
<ul>
<li>\( \frac{1}{\sqrt{2k}} \sum_{i=0}^{2k-1} \hat{x}_i \ket{i} \)</li>
</ul>
</li>
<li>\( U_2 \)
<ul>
<li>\( \frac{1}{2k} \left( (\hat{x}_i - \hat{x}_j) \ket{i,j} + \sum_{i=0}^{2k-1} \hat{x}_i \ket{0} \right) \)</li>
</ul>
</li>
</ol>
<p>で, 最後の量子を観測したときに得られうる状態は</p>
<ol>
<li>\( \ket{i,j} \) (ただし \( i \lt j \) )</li>
<li>\( \ket{0} \)</li>
</ol>
<p>の2種類がある.</p>
<p>もし \( \ket{0} \) を観測したならば, \( \sum_i \hat{x}_i \) がゼロでないことがわかる.
なぜなら, \( \ket{0} \) を観測する確率は \( (\frac{1}{2k}\sum\hat{x}_i)^2) \) であるから.
従って,
\[ \exact^{2k}_k(x) = \false \]
であることがわかる.</p>
<p>次に \( \ket{i,j} \) を観測したときを考えると,
この係数について
\( \hat{x}_i - \hat{x}_j \ne 0 \)
であることがわかる.
即ち, ビット \( x_i \) とビット \( x_j \) とが異なることを示してる.
今, \( \exact^{2k}_k \) はビットが立っているものの数と立っていないものの数が <strong>等しい</strong> かどうかにだけ興味があるので, 次が言える.</p>
<p>\[ \exact^{2k}_{k}(\{ x_0, x_1, \ldots , x_{n-1} \}) =
\exact^{2k-2}_{k-1}(\{ x_0, x_1, \ldots , x_{n-1}\} \setminus \{x_i, x_j\}). \]
(ビットの列を集合に書き換えているので註意.)</p>
<p>このことはビットに関する帰納法を示唆している.
その基底状態として,
\[ \exact^0_0~\{\} = \true \]
がある.</p>
<p>帰納部分は, (\( \false \) であれば) 運が良ければさっさと終わるが, 最悪 (\( \true \) なら必ずそうで) \( \frac{2k}{2} \) 回繰り返す必要がある.</p>
<h3><a class="header" href="#-exactn_k-" id="-exactn_k-">\( \exact^n_k \)</a></h3>
<p>入力 \( x = (x_0 \cdots x_{n-1}) \) に余計にビットを付け足せば \( \exact^{2k}_k \) に出来る.
具体的に, \( \exact^n_k(x) \) は次に等しい:</p>
<ul>
<li>case \( n = 2k \)
<ul>
<li>\( \exact^{2k}_k(x) \)</li>
</ul>
</li>
<li>case \( n \gt 2k \)
<ul>
<li>\( \exact^{2n-2k}_{n-k}(x \concat (1 \ldots 1)) \)</li>
<li>\( n-2k \) 個の 1 bit 列を連結</li>
</ul>
</li>
<li>case \( n \lt 2k \)
<ul>
<li>\( \exact^{2k}_{k}(x \concat (0 \ldots 0)) \)</li>
<li>\( 2k-n \) 個の 0 bit 列を連結</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#クエリ計算量" id="クエリ計算量">クエリ計算量</a></h3>
<p>\( \exact^{2k}_k \) のクエリ計算量は, 再帰の回数なので, 最悪 \( k \).
したがって, \( \exact^{n}_k \) のクエリ計算量は, 最悪</p>
<p>\[ \max\{k, n-k\} \]</p>
<p>となる.</p>
<h2><a class="header" href="#threshold" id="threshold">THRESHOLD</a></h2>
<p>\( n \) bit
\[ x = (x_0 x_1 \cdots x_{n-1}) \]
の内, \( k \) 個 <strong>以上</strong> が立ってるか判定するアルゴリズムを
\[ \threshold^n_k \colon \{0,1\}^n \to \{\true, \false\} \]
とする.</p>
<h3><a class="header" href="#-threshold2k1_k1-" id="-threshold2k1_k1-">\( \threshold^{2k+1}_{k+1} \)</a></h3>
<p>まず初めに
\( \threshold^{2k+1}_{k+1} \)
を考える.
これは即ち過半数ビットが立ってるかを判定する手続きである.</p>
<p>入力は \( x_0, x_1, \ldots , x_{2k} \) の \( 2k+1 \) ビット.
これに関して</p>
<ul>
<li>\( S_0 = \{ i \mid 0 \leq i \lt 2k+1, x_i = 0 \} \)</li>
<li>\( S_1 = \{ i \mid 0 \leq i \lt 2k+1, x_i = 1 \} \)</li>
</ul>
<p>とする.
それぞれのサイズ (要素数) を \( \#S_0, \#S_1 \) と書くことにして,
全体は奇数ビットなので, 必ず \( \#S_0 \ne \#S_1 \).
今 \( \#S_0 \gt \#S_1 \) とする.
逆の場合も同様であるので省略する.</p>
<p>次のことが言える:</p>
<ul>
<li>when \( i \in S_0 \),
<ul>
<li>when \( \#S_0 = \#S_1 + 1 \)
<ul>
<li>\( \sum_{j \ne i} \hat{x}_j = 0 \)</li>
</ul>
</li>
<li>when \( \#S_0 \gt \#S_1 + 1 \)
<ul>
<li>\( \threshold^{2k+1}_{k+1}(x) = \threshold^{2k-1}_{k-1}(x \setminus \{x_i, x_j\}) \) (\( \forall j \ne i \))</li>
</ul>
</li>
</ul>
</li>
<li>when \( i \in S_1 \)
<ul>
<li>\( \threshold^{2k+1}_{k+1}(x) = \threshold^{2k-1}_{k-1}(x \setminus \{x_i, x_j\}) \) (\( \forall j \ne i \))</li>
</ul>
</li>
</ul>
<p>THRESHOLD では次の3つの操作を用いる:</p>
<ol>
<li>\( U_1 \)
<ul>
<li>\( \exact \) のときと同様</li>
</ul>
</li>
<li>\( Q \)
<ul>
<li>\( \exact \) のときと同様</li>
</ul>
</li>
<li>\( U_3 \)
<ul>
<li>\( U_3 \ket{i} = \frac{\sqrt{2k+1}}{2k} \left( \sum_{i \lt j} \ket{i,j} - \sum_{i&gt;j} \ket{j,i} + \frac{1}{2k} \ket{j} \right) \)</li>
<li>ユニタリ変換になるように</li>
</ul>
</li>
</ol>
<p>EXACT と同様に \( \ket{0} \) から初めてこれらに順に通す.</p>
<ul>
<li>初期状態
<ul>
<li>\( \ket{0} \)</li>
</ul>
</li>
<li>\( U_1 \)
<ul>
<li>\( \frac{1}{\sqrt{2k}} \sum_{i=0}^{2k-1} \ket{i} \)</li>
</ul>
</li>
<li>\( Q \)
<ul>
<li>\( \frac{1}{\sqrt{2k}} \sum_{i=0}^{2k-1} \hat{x}_i \ket{i} \)</li>
</ul>
</li>
<li>\( U_3 \)
<ul>
<li>\( \frac{\sqrt{2k-1}}{2k \sqrt{2k+1}} \sum_{i \lt j} (\hat{x}_i - \hat{x}_j) \ket{i,j} + \frac{1}{2k\sqrt{2k+1}} \sum_{i=0}^{2k} \sum_{i \ne j} \hat{x}_i \ket{j} \)</li>
</ul>
</li>
</ul>
<p>これを測定すると</p>
<ol>
<li>\( \ket{i,j} \) または</li>
<li>\( \ket{j} \)</li>
</ol>
<p>のいずれかを得る.</p>
<h4><a class="header" href="#1--ketij--を得た時" id="1--ketij--を得た時">1. \( \ket{i,j} \) を得た時,</a></h4>
<p>\( \hat{x}_i - \hat{x}_j \ne 0 \)
であるから, \( x_i \ne x_j \).
従って
\[ \threshold^{2k+1}_{k+1}(x) = \threshold^{2k+1}_{k+1}(x \setminus \{x_i, x_j\}) \].</p>
<h4><a class="header" href="#2--ketj--を得た時" id="2--ketj--を得た時">2. \( \ket{j} \) を得た時,</a></h4>
<p>\( \sum_{i \ne j} \hat{x}_i \ne 0 \).
先ほどの性質を思い出せば,
\[ \threshold^{2k+1}_{k+1}(x) = \threshold^{2k+1}_{k+1}(x \setminus \{x_i, x_j\}). \]</p>
<p>以上から, ちょうど \( k \) 回, 再帰的に \( U_1, Q, U_2 \) を適用することで</p>
<p>\[ \threshold^1_0(x_0) = x_0 \]</p>
<p>というわけで
\( \threshold^{2k+1}_{k+1} \)
はクエリ計算量 \( k+1 \) で解ける.</p>
<h3><a class="header" href="#-thresholdn_k-" id="-thresholdn_k-">\( \threshold^n_k \)</a></h3>
<p>一般の場合はやはり EXACT と同様に余分にビットを付け足してやれば結局
\( \threshold^{2k+1}_{k+1} \)
に帰着でき, クエリ計算量は,
\[ \max \{k+1, n-k+1\}. \]</p>
<h1><a class="header" href="#summary-1" id="summary-1">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#計算モデル-1" id="計算モデル-1">計算モデル</a></h1>
<h1><a class="header" href="#skiコンビネータ" id="skiコンビネータ">SKIコンビネータ</a></h1>
<h1><a class="header" href="#不動点コンビネータ" id="不動点コンビネータ">不動点コンビネータ</a></h1>
<h1><a class="header" href="#summary-2" id="summary-2">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#summary-3" id="summary-3">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#ゲームの代数" id="ゲームの代数">ゲームの代数</a></h1>
<h1><a class="header" href="#グランディ数-ニム数" id="グランディ数-ニム数">グランディ数 (ニム数)</a></h1>
<h1><a class="header" href="#summary-4" id="summary-4">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#summary-5" id="summary-5">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#形式言語の極限同定" id="形式言語の極限同定">形式言語の極限同定</a></h1>
<p>\( \def\PAT{\mathrm{PAT}}\def\content{\mathrm{content}} \)</p>
<h2><a class="header" href="#参考文献" id="参考文献">参考文献</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Language_identification_in_the_limit">wikipedia/Language_identification_in_the_limit</a></li>
<li><a href="https://en.wikipedia.org/wiki/Grammar_induction">wikipedia/Grammar_induction</a></li>
<li><a href="http://web.mit.edu/6.863/www/spring2010/readings/gold67limit.pdf">paper/gold67limit.pdf</a></li>
<li><a href="http://www.sciencedirect.com/science/article/pii/0022000080900410">paper/Angluin80</a></li>
<li><a href="http://repository.kulib.kyoto-u.ac.jp/dspace/bitstream/2433/103408/1/0482-7.pdf">paper/Shinohara83.pdf</a></li>
<li><a href="http://www-ikn.ist.hokudai.ac.jp/%7Earim/papers/arimura_stacs94.pdf">paper/Arimura94.pdf</a></li>
</ul>
<h2><a class="header" href="#諸定義" id="諸定義">諸定義</a></h2>
<ul>
<li>アルファベットとはシンボルの有限集合
<ul>
<li>文脈によってはシンボルは2つ以上に限ることがある</li>
<li>\( \Sigma = \{ 0, 1, \cdots \} \)</li>
</ul>
</li>
<li>テキストとはアルファベットの上の文字列
<ul>
<li>\( \Sigma^* = \{ \epsilon, 0, 1, \cdots, 00, 01, 10, 11, \cdots, 010, \cdots \} \)
<ul>
<li>空文字列を \( \epsilon \) と書く</li>
</ul>
</li>
<li>1文字以上に限ったテキストを次の記号で表す
<ul>
<li>\( \Sigma^+ = \{ 0, 1, \cdots, 00, 01, 10, 11, \cdots, 010, \cdots \} \)</li>
</ul>
</li>
</ul>
</li>
<li>言語とはテキストの集合
<ul>
<li>\( L \subseteq \Sigma^* \)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#e-mark-gold" id="e-mark-gold">E. Mark Gold</a></h1>
<ul>
<li>&quot;Language Identification in the Limit&quot;, 1967</li>
</ul>
<h2><a class="header" href="#動機" id="動機">動機</a></h2>
<ul>
<li>AIに言葉を話させたい (作文をさせたい)</li>
<li>言葉を話すためにはその言語を学習しなければならない
<ol>
<li>AI (計算機) は言語を学習できるか</li>
<li>どの時点で学習したと言えるか</li>
</ol>
</li>
</ul>
<h2><a class="header" href="#言葉を話せるai" id="言葉を話せるai">言葉を話せるAI</a></h2>
<ul>
<li>人間の場合は, 英語のルールを正しく書き下せなくても, &quot;英語を話せる&quot; と言う</li>
<li>AI の場合でも, 同様の &quot;英語を話せる&quot; とかいえるようなモデルが作れるはず (模倣)
<ul>
<li>すなわち言語のルールを書き下すことなく学習ができるはず</li>
<li>英語に限らず自然言語一般のルールを学習させたい
<ul>
<li>人間は任意の自然言語を学習可能</li>
</ul>
</li>
<li>自然言語をよりも単純な言語はより用意に学習できる
<ul>
<li>自然言語を lower bound とする</li>
<li>より複雑な言語は別にどうでもいい</li>
</ul>
</li>
<li>少なくとも自然言語を含むような単純な言語の枠組みを設定する</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#言語の枠組み-言語クラス" id="言語の枠組み-言語クラス">言語の枠組み: 言語クラス</a></h2>
<p>何の枠組みもなしに言語を学習するってのは難しすぎる</p>
<p>個々の言語を考える代わりに言語の族, 言語クラスを考える.
\[ C = \{ L_1, L_2, \ldots \} \]
(実際には添字付きなものに限らない)</p>
<ul>
<li>言語クラス \( C \)
<ul>
<li>例えば「ありえる自然言語全体」を設定する</li>
<li>例えば「文脈自由文法全体」を設定する
<ul>
<li>その中には実在する自然言語 (英語など) が含まれる</li>
</ul>
</li>
</ul>
</li>
<li>言語の学習とは言語クラス \( C \) からそれっぽい言語を選ぶことだとする</li>
</ul>
<h2><a class="header" href="#情報提示-information-presentation" id="情報提示-information-presentation">情報提示 (information presentation)</a></h2>
<p>何はともあれ, 情報を提示されないと学習できない</p>
<p>Gold は Text , Informant の2つがあると考えた</p>
<p>現代語訳すると</p>
<ul>
<li>Text \( \Rightarrow \) 正提示</li>
<li>Informant \( \Rightarrow \) 完全提示</li>
</ul>
<p>紛らわしいので現代語を使います</p>
<h3><a class="header" href="#正提示" id="正提示">正提示</a></h3>
<p>言語 \( L \) の正提示とは, その言語に出現するテキストの (無限) 列のこと
\[ w_1, w_2, \ldots \]
この列には重複などがあってもいいが, 言語に含まれる任意のテキストはこの列のどこかではいつか必ず出現することを要請する.
すなわち,
\[ \forall v \in L, \exists i \in \mathbb{N}, w_i = v \]
これは結構強い性質である.</p>
<p>気持ちとして, 正提示とは次のような状況に相当する.
すなわち「子供が大人から常に正しいテキストを一つずつ聞く」</p>
<h4><a class="header" href="#def-content" id="def-content">Def. content</a></h4>
<p>無限列を集合に変換する操作を \( \content \) と呼ぶことにする.
例えば \( \content \{ 0,1,2,\ldots \} = \mathbb N \) みたいに使う.</p>
<p>こうすると正提示で要求してる性質は,
正提示 \( I = ( w_1, w_2, \ldots ) \) に対して
\[ \content(I) = L \]
だと書ける.</p>
<h3><a class="header" href="#完全提示" id="完全提示">完全提示</a></h3>
<p>言語 \( L \) の完全提示とは, 何でもいいから任意のテキストの列であって, そのテキストが言語に含まれるかのラベル (\( \mathrm{Bool} = \{0,1\} \)) が付いているもの
\[ (w_1, I_1), (w_2, I_2), \ldots \]</p>
<ul>
<li>\( (w_i, I_i) \) は次を満たす
<ul>
<li>\( I_i = 1 \iff w_i \in L \)</li>
<li>\( I_i = 0 \iff w_i \not\in L \)</li>
</ul>
</li>
<li>ただし任意のテキストがいつかは出現する
<ul>
<li>\( \forall v \in \Sigma^*, \exists i \in \mathbb N, w_i = v \)</li>
</ul>
</li>
</ul>
<p>そして完全提示の気持ちはこういうもの:</p>
<ul>
<li>次に相当
<ul>
<li>子供が大人から常に正しいテキストを聞く (\( I_i = 1 \))</li>
<li>子供はたまに作文をする (話す)
<ul>
<li>文法エラーをすると, リアクションから誤りだと知る (\( I_i = 0 \))</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#言語学習モデル-guessing-machine" id="言語学習モデル-guessing-machine">言語学習モデル (guessing machine)</a></h2>
<ol>
<li>正提示または完全提示により, 学習者は \( i_1, i_2, \ldots \) を逐次的に受け取る
<ul>
<li>時刻 \( t \) に情報 \( i_t \) を受け取る</li>
</ul>
</li>
<li>学習者はその時点までに受け取った情報から, 何らかの手続き \( G \) によって言語を推論する</li>
</ol>
<p>時刻 \( t \) における推論:
\[ g_t = G(i_1, i_2, \ldots, i_t) \]</p>
<p>\( g_t \) は特定の1つの言語を説明するもの, 或いは, 言語そのもの</p>
<h2><a class="header" href="#極限における同定" id="極限における同定">極限における同定</a></h2>
<p>原理的に有限個の情報からは学習できない, という言語クラスはいくらでもあるので極限を考える</p>
<p>\[ g_t = G(i_1, i_2, \cdots, i_t) \]</p>
<p>が極限 \( t \rightarrow \infty \) で同定してかつ正しい言語を指し示すことを
<strong>極限同定</strong>
という.
注意として, 学習者は「いつ自分は正しく言語を学習できたか」を知る必要はない.</p>
<h2><a class="header" href="#言語クラスの学習可能性" id="言語クラスの学習可能性">言語クラスの学習可能性</a></h2>
<p>Gold が提示した枠組みにおける <strong>学習可能性</strong> とは次のこと.</p>
<p>「ある言語クラス \( C \) が学習可能である」とは,
任意の言語 \( L \in C \) とその任意の情報提示 \( I \) について,
ある guessing machine \( G \) を構成することができて \( I \) によって \( L \) を極限同定できること.</p>
<h3><a class="header" href="#例-完全提示から正規言語は学習可能" id="例-完全提示から正規言語は学習可能">例: 完全提示から正規言語は学習可能</a></h3>
<p>正規言語全体のクラスを考えるこれは完全提示によって学習可能であることが知られている.
正規言語とはオートマトン (或いは正規表現) に対応するからそれを復元出来れば良い.
guessing machine \( G \) の出力はオートマトン \( g_t \)</p>
<p>ただしこれは完全提示を要求していて, したがって無限のテキストについてそれが言語に含まれるか (つまりオートマトンに受理されるか, 或いは正規表現にマッチするか) を神託する必要がある.</p>
<h3><a class="header" href="#libalf-automata-learning-framework" id="libalf-automata-learning-framework">libalf: Automata Learning Framework</a></h3>
<p>完全提示からオートマトンを復元してくれるツール
<a href="http://libalf.informatik.rwth-aachen.de/index.php?page=about">libalf</a>
というものがある.
これがまさに今欲しかった guessing machine である.</p>
<p><img src="https://i.imgur.com/Z2wOh8V.png" alt="" /></p>
<h2><a class="header" href="#正提示から正規言語を極限同定することは不可能" id="正提示から正規言語を極限同定することは不可能">正提示から正規言語を極限同定することは不可能</a></h2>
<p>正提示だけからは正規言語のクラスは極限同定が不可能であることも知られている.</p>
<ul>
<li>正規言語全体は大きすぎる (超有限)</li>
<li>正提示が完全提示に比べて弱すぎる (それはそう)</li>
</ul>
<h2><a class="header" href="#子供の言語学習-acquisition-of-grammar-by-children" id="子供の言語学習-acquisition-of-grammar-by-children">子供の言語学習 (acquisition of grammar by children)</a></h2>
<p>ちょいちょい「子供が学習するときは〜」という話が出るが, 実際はどうなのか</p>
<p>psycholinguist 曰く [McNeill, 1966]:
「子供が文法誤りをしたとき, それを指摘することは滅多にない」</p>
<p>つまり完全提示は仮定が強すぎて現実的には正提示しか無い.
そしてその中でも人間は自然言語を学習することが出来る.</p>
<h3><a class="header" href="#自然言語は正提示から学習可能説" id="自然言語は正提示から学習可能説">自然言語は正提示から学習可能説</a></h3>
<ul>
<li>多くの自明な言語クラスなら正提示から学習可能であることを Gold は示した</li>
<li>英語は文脈自由文法だと言われているが, 実際には, 全ての文脈自由文法が自然言語になるわけではない
<ul>
<li>もっと制限がある (もっと小さなクラスである)</li>
<li>例えば, 学習可能性の結論として:
あり得る自然言語のクラスは, 無限言語を少なくともひとつは含み,
全ての有限言語を含むことはない (超有限ではない)</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#子供は-我々がわからない方法で負例を学習する説" id="子供は-我々がわからない方法で負例を学習する説">子供は, 我々がわからない方法で負例を学習する説</a></h3>
<ul>
<li>例えば, 発言をして, 思ったような反応が得られなかったとき
<ul>
<li>だとすると完全提示からの学習をしてもいい</li>
</ul>
</li>
<li>原始再帰的言語は完全提示から学習可能であることをGoldは示している
<ul>
<li>文脈依存文法も原始再帰的言語の一つ</li>
<li>英語は完全提示から学習可能</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#dana-angluin" id="dana-angluin">Dana Angluin,</a></h1>
<ul>
<li>&quot;On the Complexity of Minimum Inference of Regular Sets&quot;, 1978</li>
<li>&quot;Finding Patterns Common to a Set of Strings&quot;, 1979</li>
</ul>
<p>この人は正提示から学習可能な非自明な言語クラスを発見した.
それが <strong>パターン言語</strong>.</p>
<h2><a class="header" href="#パターン--pat-" id="パターン--pat-">パターン: \( \PAT \)</a></h2>
<p>有限アルファベット \( \Sigma = \{ 0, 1, \cdots \} \) と
無限変数 \( X = \{ x_1, x_2, \cdots \} \) の列としてパターンは定義される.</p>
<p>\[ \PAT = (\Sigma \cup X)^+ \]</p>
<p>パターンに対しては次の操作と関係が定義される.</p>
<h3><a class="header" href="#代入--preceq--less-general-than" id="代入--preceq--less-general-than">代入, \( \preceq \) (less-general-than)</a></h3>
<p>代入 \( [x_i/p] \) とは, パターン中に出現する <strong>全ての</strong> 変数 \( x_i \) を <strong>空でない</strong> パターン \( p \) に置き換える操作.</p>
<p>\begin{align*}
x_1 x_1 &amp; \succeq \underline{x_2} ~ \underline{x_2} &amp; [x_1/x_2] \\
&amp; \succeq \underline{a x_1} ~ \underline{a x_1} &amp; [x_2/a x_1] \\
&amp; \succeq a \underline{b c} a \underline{b c} &amp; [x_1/b c] \\
\end{align*}</p>
<p>ただし空は代入できないことに注意.
\[ a x_1 a x_1 \not\succeq a a \]</p>
<h2><a class="header" href="#パターン言語" id="パターン言語">パターン言語</a></h2>
<p>パターンに対応して言語を構成することが出来る.
すなわち,
\[ L(p) = \{ w \in \Sigma^* \mid w \preceq p \}. \]</p>
<p>(正規表現に対して正規言語があるようなもの.)</p>
<p>例えば,
\[ L(x_1 x_1) = \{ w w \mid w \in \Sigma^+ \} \]</p>
<h2><a class="header" href="#定理-パターン言語は正提示から学習可能" id="定理-パターン言語は正提示から学習可能">定理: パターン言語は正提示から学習可能</a></h2>
<p>パターン言語のクラス
\[ C = \{ L(p) \mid p \in \PAT \} \]
は正提示で学習可能.</p>
<h3><a class="header" href="#学習過程-推論機械--g-" id="学習過程-推論機械--g-">学習過程 (推論機械 \( G \))</a></h3>
<p>学習ターゲットが \( L = L(p) \in C \) であって,
その正提示として \( s_1, s_2, \cdots (s_i \in L) \) を受け取るとする.</p>
<p>推論機械は言語そのものの代わりにパターンを出力すればよい:
\[ p_t = G(s_1 \cdots s_t) \]</p>
<p>さて推論機械の構成方法であるが, それは大雑把に述べると</p>
<ul>
<li>\( \forall t, \content(s_1, \cdots, s_t) \subseteq L(p_t) \) （無矛盾）</li>
<li>\( L(p_1) \subseteq L(p_2) \subseteq \cdots \) （保守的）</li>
<li>上2つを満たす為には次のようにすれば十分 （極小言語戦略）
<ul>
<li>\( p_t = \mathop{\rm argmin}\limits_p L(p) ~s.t.~ \content \subseteq L(p) \)</li>
</ul>
</li>
</ul>
<p>ってやると,
\[ L = L(\lim_t p_t) \]
になる.</p>
<h2><a class="header" href="#def-有限の厚み" id="def-有限の厚み">Def. 有限の厚み</a></h2>
<p>言語クラスが有限の厚みを持つとは \( \iff \)
任意のテキストの有限集合 \( S \) について
\( \{ L \mid S \subseteq L \} \)
が有限であること</p>
<h3><a class="header" href="#prop-有限の厚みを持つ言語クラスは極小言語によって極限同定可能である" id="prop-有限の厚みを持つ言語クラスは極小言語によって極限同定可能である">Prop. 有限の厚みを持つ言語クラスは極小言語によって極限同定可能である</a></h3>
<ol>
<li>無矛盾かつ保守的な推論による推論の列: \( g_1, g_2, ... \)
は収束する
<ol>
<li>有限の厚みより, 正提示の1つ目を含む言語は有限個しかない
<ol>
<li>推論も有限個しかない</li>
</ol>
</li>
<li>保守性より \( L(g_1) \subseteq L(g_2) \subseteq \cdots \) (\( g_i \) に半順序がつく)</li>
<li>推論列はどこかで停まるか, 極大を定める</li>
</ol>
</li>
</ol>
<h3><a class="header" href="#thm-パターン言語は正提示から学習可能" id="thm-パターン言語は正提示から学習可能">Thm. パターン言語は正提示から学習可能</a></h3>
<ol>
<li>先に挙げた極小言語戦略による推論機械を構成する</li>
<li>パターン言語クラスは有限の厚みを持つことを示す
<ul>
<li>\( \forall w, \{ p \mid w \preceq p \} \) が有限であることを言えばよい</li>
<li>hint: \( q \preceq p \Rightarrow |q| \geq |p| \)</li>
</ul>
</li>
<li>先の Prop. から極限同定可能</li>
</ol>
<h1><a class="header" href="#その他の話題" id="その他の話題">その他の話題</a></h1>
<h2><a class="header" href="#shinohara" id="shinohara">Shinohara</a></h2>
<ul>
<li>Shinohara: &quot;Polynomial Time Inference of Extended Regular Pattern Languages&quot;, 1991</li>
</ul>
<p>パターン言語を消去可能パターン言語に拡張した.
消去可能であるとは空文字列の代入を許すこと.</p>
<p>例えば:
\[ a x_1 a x_1 \succeq a a \]</p>
<p>Shinohara は消去可能パターン言語であって正則なものは, 正提示から学習可能であることを示した.</p>
<blockquote>
<p>N.B. パターン言語が正則 \( \iff \) 一つのパターンに出現する同じ変数 \( x_i \) は高々一つ (出現する変数が全て異なる)</p>
</blockquote>
<h2><a class="header" href="#arimura-shinohara-finding-minimal-generalizations-of-unions-of-pattern-languages-and--1994" id="arimura-shinohara-finding-minimal-generalizations-of-unions-of-pattern-languages-and--1994">Arimura, Shinohara: &quot;Finding Minimal Generalizations of Unions of Pattern Languages and ...&quot;, 1994</a></h2>
<p>パターンの和言語も正提示から学習可能であることを示した.
和言語とは, \( k \) 個のパターン \( p_1, p_2, \ldots, p_k \) について
\[ L(p_1, \cdots, p_k) = L(p_1) \cup \cdots \cup L(p_k) \]
と定められるもの.
ただしこの個数 \( k \) について上限を設けたりする.</p>
<h2><a class="header" href="#takeuchi-sato-誤情報を含む正則パターン言語の多項式時間推論-1998" id="takeuchi-sato-誤情報を含む正則パターン言語の多項式時間推論-1998">Takeuchi, Sato: &quot;誤情報を含む正則パターン言語の多項式時間推論&quot;, 1998</a></h2>
<p>タイトルの通り</p>
<ul>
<li>学習したい言語からちょっとくらいズレた提示があっても良いようにする</li>
<li>言語の「近傍系」を学習していく
<ul>
<li>パターンの上の一種のハミング距離を取る</li>
</ul>
</li>
</ul>
<p>(一定の) 誤情報を含む正提示から学習可能</p>
<h2><a class="header" href="#ng-shinohara-inferring-unions-of-the-pattern-languages-by-the-most-fitting-covers-2005" id="ng-shinohara-inferring-unions-of-the-pattern-languages-by-the-most-fitting-covers-2005">Ng, Shinohara: &quot;Inferring Unions of the Pattern Languages by the Most Fitting Covers&quot;, 2005</a></h2>
<ul>
<li>今見てきた極小言語戦略は提示 \( s_1, \cdots, s_t \) を含む中で極小な言語を推論として出力する
<ul>
<li>極小とは言語の包含関係に関する</li>
<li>言語は無限集合なので大きさを比較するのは難しい</li>
</ul>
</li>
<li>要するに小さければ良い
<ul>
<li>実際の言語ではテキストの長さには上限が (たぶん) ある
<ul>
<li>\( \Rightarrow \) 任意の自然言語は有限集合である</li>
<li>大きさに関する極小を取ることができる</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>性質を調べたものであって, この場合の推論方法を示したわけでも学習可能性を言ったものでもない</p>
<h2><a class="header" href="#おわりに" id="おわりに">おわりに</a></h2>
<ul>
<li>誰も自然言語のことを忘れてパターン言語だけをやっている</li>
<li>完全提示からの学習なんて誰もやってない (ことはないけど)</li>
<li>というか確率を導入すべきだ</li>
<li>もはや誰も手をつけない分野
<ul>
<li>ちょっと古ければ論文は大量にある</li>
<li>2000年以降もたま〜にぽつぽつ出てる</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#汎化システムと極小言語" id="汎化システムと極小言語">汎化システムと極小言語</a></h1>
<h2><a class="header" href="#参考文献-1" id="参考文献-1">参考文献</a></h2>
<ol>
<li>T.Shinohara: &quot;Polynomial Time Inference of Extended Regular Pattern Languages&quot;
<ul>
<li>Regular Pattern の minimal common genelization (mcg) を多項式時間で求める</li>
</ul>
</li>
<li>Arimura+: &quot;Finding Minimal Generalizations for Unions of Pattern Languages and its Application to Inductive Inference from Positive Data&quot;
<ul>
<li><a href="http://www-ikn.ist.hokudai.ac.jp/%7Earim/papers/arimura_stacs94.pdf">www-ikn.ist.hokudai.ac.jp/~arim/papers/arimura_stacs94.pdf</a></li>
<li>k-mmg を多項式時間で求める</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#概要" id="概要">概要</a></h2>
<p>言語の獲得を考える.
(言語に限りたくないという気持ちからか, 代わりに concept ということもある.)</p>
<blockquote>
<p>description (pattern) \( \simeq \) Language (concept) \( L \) \( \supset \) given string set \( S \)</p>
</blockquote>
<p>言語はテキストの集合と考えられる.
獲得したい言語を推測するためのヒントとして, 正しいテキストをいくつか与えられるとする.
今言語は集合だから, 与えられるヒントとは \( L \) の部分集合であると表現できる (\( S \subset L \)).
言語の獲得とは \( S \) から \( L \) を推測する行為だと言える.</p>
<p>さて現実的には \( L \) は無限集合で \( S \) は有限集合である.
無限集合をいきなり考えるのは難しいので, 代わりに, 言語に一対一対応してくれて何か扱いやすい description というものを考える.
例えば \( L \) として正規言語を考えるなら, その description として正規表現（パターン）がある.
すなわち正規表現 \( p \) にマッチするテキスト全体が正規言語 \( L_p \) であるし,
逆に正規言語 \( L \) があれば必ずそのような正規表現 \( p \) が存在する.
\( L \) が無限集合である一方で一つの正規表現とは有限の長さの文字列一つであるので扱いやすい.</p>
<p>正規表現から言語を再構成するのにパターンマッチという関係を使った.
<strong>汎化システム</strong> はまさにこれを一般化した概念である.
これによって表現出来る言語のクラス及びその上の言語の推論を考える.</p>
<h2><a class="header" href="#言語の推論" id="言語の推論">言語の推論</a></h2>
<p>初めに言語の「獲得」だと言ったが, 考えている枠組みはむしろ「推論」である.
すなわち, ありえる言語のクラスが与えられ, 証拠 \( S \) を元に, 最も適切と思われる言語 \( L \) をクラスの中から選択する行為を「言語の推論」と呼んで, これを研究する.</p>
<h2><a class="header" href="#汎化システム" id="汎化システム">汎化システム</a></h2>
<p>\( D \) を description の集合とし, 半順序 \( \preceq \) を入れる.
\( D \) は最大限 \( \top \) を持つとする.
このとき
\( (D, \preceq) \) を汎化システムと呼ぶ.</p>
<h3><a class="header" href="#汎化" id="汎化">汎化</a></h3>
<p>半順序 \( \preceq \) を汎化関係と呼ぶ.
\( p \preceq q \) のとき,
\( q \) は \( p \) の generalization であるといい,
また \( p \) から \( q \) を構成することを generalize という.
逆に \( p \) は \( q \) の instance であるといい,
\( q \) から \( p \) を構成することを refine という.</p>
<p>\( p \in D \) が極小元であるとき, \( p \) は object であるという.
\[ p \text{ is object } \iff \forall q \in D, q \not\prec p \]
すなわちそれ以上 refine できないものを object というのである.</p>
<h3><a class="header" href="#言語-concept" id="言語-concept">言語 (Concept)</a></h3>
<p>\( p \in D \) で表現される言語とは
\[ L(p) = \{ q \preceq p \mid q \text{ is object } \} \]
のこと.</p>
<h3><a class="header" href="#定理-1" id="定理-1">定理</a></h3>
<p>\[ p \preceq q \implies L(p) \subseteq L(q) \]</p>
<h4><a class="header" href="#証明" id="証明">証明</a></h4>
<p>\[ \begin{align*}
s \in L(p)
&amp; \iff s \preceq p ~~\text{(言語の定義)} \\
&amp; \implies s \preceq q ~~\text{(推移律)} \\
&amp; \iff s \in L(q) ~~\text{(言語の定義)}
\end{align*} \]</p>
<h3><a class="header" href="#汎化システムの完全性" id="汎化システムの完全性">汎化システムの完全性</a></h3>
<p>先の定理の逆
\[ L(p) \subset L(q) \implies p \preceq q \]
は一般には成立 <strong>しない</strong>.
これが常に成り立つような汎化システムは <strong>完全 (complete) である</strong> という.</p>
<h3><a class="header" href="#正規パターン-regular-pattern" id="正規パターン-regular-pattern">正規パターン (Regular Pattern)</a></h3>
<p><strong>パターン</strong> を次のように定義する</p>
<ul>
<li>大きさ 2 以上の有限集合: \( \Sigma = \{0,1,\ldots\} \)
<ul>
<li>\( \Sigma \) の元を <strong>アルファベット</strong> という</li>
<li>文字列 (object): \( \Sigma^+ \)</li>
<li>空文字列: \( \Sigma^0 = \{ \epsilon \} \)</li>
</ul>
</li>
<li>無限集合 \( X = \{x,y,z,\ldots\} \)
<ul>
<li>この元を <strong>変数</strong> という</li>
</ul>
</li>
<li>パターンとはアルファベットと変数からなる列
<ul>
<li>\( (\Sigma \cup X)^+ \) の元</li>
<li>e.g. \( x \), \( 0x2xy \), \( 01214 \)</li>
</ul>
</li>
<li><strong>正規パターン</strong> とはパターンであって, 一つの変数は高々一度しか出現しないもの
<ul>
<li>パターン全体を RP と書くことにする</li>
<li>e.g. \( x \), \( 0x2yz \), \( 01234 \)</li>
</ul>
</li>
</ul>
<h4><a class="header" href="#代入" id="代入">代入</a></h4>
<p>正規パターン \( p \) について, その中に現れる変数一つをまた別な正規パターンで置き換える操作を <strong>代入</strong> という.
ただし置き換えてできたパターンも正規であるために, 変数が衝突しないようにだけ注意する.</p>
<blockquote>
<p>正規とは限らない一般のパターンでも同様に代入を定義できる.
その場合は同じ変数には同じパターンを代入することを要請する.
例えば \( xx \) というパターンの \( x \) に \( 0 \) を代入して出来るパターンは \( 00 \) である.</p>
</blockquote>
<p>今パターンは1文字以上であると定義したので, 変数への代入によって全体の文字数は減らない.
変数をただ消すだけのことができないのでこれを <strong>消去不能 (non-erasing)</strong> パターンと呼ぶ.</p>
<p>バリエーションとして, 特別に空文字列の代入も許す代入もあり, それは <strong>消去可能 (erasing)</strong> パターンと呼ぶ.
当然表現力としてはこちらのほうが豊かである.</p>
<blockquote>
<p>代入の例:
\( x \mapsto 0123 \).
\( x \mapsto xy \).
\( xy \mapsto x \) (消去可能な場合).</p>
</blockquote>
<h4><a class="header" href="#正規パターンの汎化システム" id="正規パターンの汎化システム">正規パターンの汎化システム</a></h4>
<p>正規パターンを description とし, これに上手く \( \preceq \) を入れると汎化システムになる.</p>
<p>\( q \) にある代入を行うと \( p \) になるとき,
\[ p \preceq q \]
と定める.
代入は消去可能でも不能でもどちらでもいい.
このとき \( (RP, \preceq) \) は汎化システムである.</p>
<h4><a class="header" href="#同値関係" id="同値関係">同値関係</a></h4>
<p>普通の順序の場合と同様に
\[ p = q \iff p \preceq q \land q \preceq p \]
と定義する.</p>
<p>これによって同値になるのは全く見た目が同じ場合の他に, 変数の置換がある.
例えば \( x = y \) である.
これは変数一つに変数一つを代入した場合.</p>
<p>消去可能パターンの場合はそれに加えて, 変数一つに1つ以上の変数を代入するのも同値関係である.
例えば \( x = xy = xyz \) である.
0個にしちゃうと戻せないのでだめ.
\( 0 \preceq 0x \) だが \( 0 \succeq 0x \) ではない.</p>
<h3><a class="header" href="#正規パターン言語" id="正規パターン言語">正規パターン言語</a></h3>
<p>RP に対して汎化システムを定義したので言語を定義出来る.
それを正規パターン言語と呼ぶ.
以下に例を示す.</p>
<ul>
<li>\( L(0x01y0) = \{ 0x01y0 \mid x \in \Sigma^+, y \in \Sigma^+ \} \) (消去不能の場合)</li>
<li>\( L(0x01y0) = \{ 0x01y0 \mid x \in \Sigma^*, y \in \Sigma^* \} \) (消去可能の場合)</li>
</ul>
<p>さて \( \preceq \) の極小元のことを object と呼ぶと先に延べたが,
明らかに object とは \( \Sigma^+ \) のことであり, 言語の元のことである.</p>
<h3><a class="header" href="#正規パターン言語の完全性" id="正規パターン言語の完全性">正規パターン言語の完全性</a></h3>
<p>\( |\Sigma| &gt; 2 \) のとき以下は成り立つ.
\( |\Sigma| = 2 \) のときは凡例があり成り立たない.
\[ L(p) \subseteq L(q) \implies p \preceq q \]</p>
<h2><a class="header" href="#汎化システムの上の言語推論" id="汎化システムの上の言語推論">汎化システムの上の言語推論</a></h2>
<p>object の有限の集合 \( S \) が与えられたときに,
これがどの言語 \( L \) から来たかを推論したい.</p>
<p>ここで \( p \in D \) について
\( S \subset L(p) \) であることを「\( p \) は \( S \) を被覆する (covering)」ということにする.
言語を推論するには \( S \) を被覆するような description \( p \) を推論することに相当する.</p>
<h3><a class="header" href="#自明な推論" id="自明な推論">自明な推論</a></h3>
<p>\( D \) の最大限 \( \top \) を使えば任意の object はこれの instance なので,
\( L(\top) \) は \( S \) を被覆する.</p>
<p>RP で言えば \( \top = x \) であり, \( L(\top) = \Sigma^+ \) である.
これはもちろん自明すぎて面白くない.</p>
<h3><a class="header" href="#言語の大きさ" id="言語の大きさ">言語の大きさ</a></h3>
<p>自明なものがあるので \( S \) を被覆する description を見つけるだけなら簡単である.
何かしら推論する言語の良さのようなものを考える必要があるだろう.
そこで言語が小さいほど良いことにする.
ここで言語の大きさを包含関係で決める.</p>
<p>従って欲しい言語とは
\( \{ L(p) \mid p \in D, S \subset L(p) \} \)
の中で極小なもの（最小とは限らないので）.
そのような言語を <strong>極小言語</strong> という.</p>
<h3><a class="header" href="#正提示からの帰納的推論-極限同定" id="正提示からの帰納的推論-極限同定">正提示からの帰納的推論 (極限同定)</a></h3>
<p>ある汎化システム \( D \) によって作られる全ての言語からなるクラス
\[ C = \{ L(p) \mid p \in D \} \]
と書く.
今この \( C \) は既知だが未知の \( p \) 及び \( L(p) \in C \) があって, これを推論したい.</p>
<p>\( L(p) \) の元からなる無限列
\( \sigma = (s_1, s_2, \ldots) \)
を正提示という.
時刻 \( t \) に \( s_t \) を受け取るイメージ.
これの初めの \( t \) 個を断片 \( \sigma[t] \) という.
時刻 \( t \) の時点で手に入れた \( S \) である.</p>
<p>テキストの集合 \( \sigma[t] \) から description \( p \in D \) を推論する機械 \( M \) を考える.
\[ M : 2^L \mapsto D \]
\[ M : \sigma[t] \mapsto p_t \]</p>
<p>この推論の成功を次で定義する:
\[ \exists N, \forall n &gt; N, p_n = p \]
すなわちいつかは真の \( p \) で収束すること.
この定義による推論のことを <strong>極限同定 (identification in the limit)</strong> という.</p>
<p>言語クラス \( C \) の言語がある推論機械 \( M \) によっていつも推論できるとき, 推論可能なクラスであるという.</p>
<h3><a class="header" href="#正規パターン言語は推論可能" id="正規パターン言語は推論可能">正規パターン言語は推論可能</a></h3>
<p>すなわち上手く推論機械を構成すると必ず推論が成功する.</p>
<h1><a class="header" href="#summary-6" id="summary-6">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#基礎概念" id="基礎概念">基礎概念</a></h1>
<h1><a class="header" href="#f代数" id="f代数">F代数</a></h1>
<h1><a class="header" href="#随伴-モナド" id="随伴-モナド">随伴, モナド</a></h1>
<h1><a class="header" href="#冪対象-eval" id="冪対象-eval">冪対象, eval</a></h1>
<h1><a class="header" href="#summary-7" id="summary-7">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#基礎" id="基礎">基礎</a></h1>
<h1><a class="header" href="#summary-8" id="summary-8">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#テンソルとはなにか" id="テンソルとはなにか">テンソルとはなにか</a></h1>
<h1><a class="header" href="#summary-9" id="summary-9">SUMMARY</a></h1>
<ul>
<li><a href="./intro.html">What is this?</a></li>
<li><a href="./SUMMARY.html">量子計算</a>
<ul>
<li><a href="./quantum/model.html">計算モデル</a></li>
<li><a href="./quantum/deutsch.html">量子並列性, ドイチュのアルゴリズム</a></li>
<li><a href="./quantum/unitary.html">ユニタリー変換</a></li>
<li><a href="./quantum/algorithm_exact_threshold.html">EXACT, THRESHOLD アルゴリズム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ラムダ計算</a>
<ul>
<li><a href="./lambda/basic.html">計算モデル</a></li>
<li><a href="./lambda/ski.html">SKIコンビネータ</a></li>
<li><a href="./lambda/fixed.html">不動点コンビネータ</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">ゲーム理論</a>
<ul>
<li><a href="./SUMMARY.html">組み合わせゲーム</a>
<ul>
<li><a href="./game/comb/alg.html">ゲームの代数</a></li>
<li><a href="./game/comb/grundy.html">グランディ数 (ニム数)</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">行列ゲーム</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">形式言語</a>
<ul>
<li><a href="./formallang/limit_identification.html">極限同定</a></li>
<li><a href="./formallang/kmmg.html">汎化システムと極小言語</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">圏論</a>
<ul>
<li><a href="./cat/basic.html">基礎</a></li>
<li><a href="./cat/f-alg.html">F代数</a></li>
<li><a href="./cat/adj_monado.html">随伴, モナド</a></li>
<li><a href="./cat/eval.html">冪対象, eval</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">群論</a>
<ul>
<li><a href="./group/basic.html">基礎</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">線形代数</a>
<ul>
<li><a href="./linearalg/tensor.html">テンソルとはなにか</a></li>
</ul>
</li>
<li><a href="./SUMMARY.html">位相空間</a>
<ul>
<li><a href="./topological/basic.html">基礎</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#基礎-1" id="基礎-1">基礎</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
