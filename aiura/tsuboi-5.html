<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="unidoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>坪井 多様体 &amp;sect;5 - 多様体上の関数</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="https://cympfh.cc/resources/css/youtube.css" />
  <link href="https://unpkg.com/prismjs@1.x.0/themes/prism.css" rel="stylesheet" />
  <script id="MathJax-script" async src="https://unpkg.com/mathjax@3/es5/tex-chtml-full.js"></script>
  <link href="../resources/css/c.css" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />

</head>
<body>
<header class="page-header">
    <a href='index.html'><i class="fa fa-stumbleupon"></i></a>
</header>

<h1 class="title">坪井 多様体 &sect;5 - 多様体上の関数</h1>
<p><p class=date style='text-align: right'>2017-05-20 (Sat.)</p> <div class='is-pulled-right'> <a class='tag is-red' href=index.html#幾何学>幾何学</a> <a class='tag is-red' href=index.html#微分幾何>微分幾何</a> </div></p>
<h2>index</h2>
<p><div id=toc></div></p>
<h2>notation</h2>
<p>多様体 \(M\) から \(N\) への \(C^\infty\) 級関数全体を \(C^\infty(M,N)\) と書く. またユークリッド空間への関数全体 \(C^\infty(M, \mathbb{R})\) を単に \(C^\infty(M)\) と書く. 本章では主にこのユークリッド空間への関数を取り扱う.</p>
<p>関数 \(f \in C^\infty(M)\) の台 (support) とは</p>
\[\mathrm{supp} f = \overline{\{x \in M : f(x) \ne 0 \}}\]
<p>のことと定義する. ただしここで、位相空間の集合 \(X\) に対して \(\overline{X}\) とは \(X\) の閉包 (極大の閉集合, \(X \subseteq \overline{X}\) ).</p>
<p>集合 \(X\) に対して \(\mathrm{int}X\) で \(X\) の内部 (極大の開集合, \(\mathrm{int}X \subseteq X\) ) を表す.</p>
<h2>定理</h2>
<p><div class=thm> 多様体 \(M\) とその上の任意の点 \(x_0\) 及び \(x_0\) の任意の近傍 \(V\) に対して、 次のような関数 \(\mu \in C^\infty(M)\) がある.</p>
<ul>
  <li>\(\forall x \in M, \mu(x) \geq 0\)</li>
  <li>\(\mu(x_0) &gt; 0\)</li>
  <li>
    \(\mathrm{supp}\mu \subseteq V\)
    <ul>
      <li>\(\iff \forall x \not\in V, \mu(x) = 0\)</li>
    </ul>
  </li>
</ul>
<p></div></p>
<p>すなわち任意の点の周りでだけ正でその他でゼロであるような関数であって、 かつその台は望むだけ狭くできるような関数を作る方法が存在する.</p>
<p>台の領域に関しては局所座標に関して作ればよく (連続関数なので)、 \(\varphi(V) \to M \to \mathbb{R}\) の関数として</p>
\[\rho(x) = \begin{cases}
\exp(-\frac{1}{x}) &amp; \text{ when } x&gt;0 \\
0
\end{cases}\]
<p>これを使う. \(x\) 軸と傾きゼロで接しているのが大事. 左に \(\varphi^{-1}\) を合成して、 \(x=0\) が \(x_0 \in M\) に写るようにして、 \(\mu(x) = \rho(1 - \|x\|_2)\) みたいに使う.</p>
<p><center><img src="http://i.imgur.com/mCS1Pwt.png" /></center></p>
<p>上図の緑色. \(\|x\| \geq 0\) であって、この領域では問題なく \(C^\infty\) 級. この図では \(\|x\| &lt;1 \iff \mu(x) &gt; 0\) . これを適当にスケーリングすることで、台を十分狭く出来る.</p>
<h2>定理</h2>
<p>先の \(\mu\) は台にいわば上限を与える制約しかない. 次の定理はより強い関数があることを言う.</p>
<p><div class=thm> 多様体 \(M\) のある近傍 \(U\) とその部分集合でコンパクトな \(K (\subseteq U)\) があるとする. 次のような \(C^\infty\) 級関数 \(\nu_1: M \to \mathbb{R}\) がある.</p>
<ul>
  <li>\(\nu_1(x) \geq 0\)</li>
  <li>
    \(\mathrm{supp}f \subseteq U\)
    <ul>
      <li>\(\iff \forall x \not\in V, \mu(x) = 0\)</li>
    </ul>
  </li>
  <li>\(\forall x \in K, \nu_1(x) &gt; 0\)</li>
</ul>
<p></div></p>
<p>一番最後の要請によって台の下限が \(K\) として与えられている.</p>
<p>\(K\) をコンパクトとしてるのが肝で、有限個の \(\mu\) を足し合わせることで実現できる.</p>
<h2>定理</h2>
<p>更に強く出来る.</p>
<p><div class=thm> 先ほどと同様に、近傍 \(U\) とそのコンパクト部分集合 \(K\) について、次の関数 \(\nu\) がある.</p>
<ul>
  <li>\(0 \leq \nu(x) \leq 1\)</li>
  <li>
    \(\mathrm{supp}f \subseteq U\)
    <ul>
      <li>\(\iff \forall x \not\in V, \mu(x) = 0\)</li>
    </ul>
  </li>
  <li>\(\forall x \in K, \nu(x) = 1\)</li>
</ul>
<p></div></p>
<p>次のように作れる.</p>
<p>\((U, K)\) に関して先ほどの \(\nu_1\) を作り、 \((U \setminus K, \mathrm{supp} \nu_1 \setminus \mathrm{int}(\mathrm{supp} \nu_1))\) に関して作った \(\nu_1\) を \(\nu_2\) と名付ける. \(K_2 = \mathrm{supp} \nu_1 \setminus \mathrm{int}(\mathrm{supp} \nu_1)\) はコンパクトであることに註意.</p>
<p>こうすると、</p>
<ul>
  <li>\(\forall x \not\in \mathrm{supp} \nu_1, \nu_1(x) = 0 \land \nu_2(x)=0\)</li>
  <li>\(\forall x \in K_2, \nu_1(x) &gt; 0 \land \nu_2(x) &gt; 0\)</li>
  <li>\(\forall x \in K \setminus K_2, \nu_1(x) &gt; 0 \land \nu_2(x) = 0\)</li>
</ul>
<p>とできる. というわけで、</p>
\[\nu(x) = \begin{cases}
\frac{\nu_1(x)}{\nu_1(x) + \nu_2(x)} &amp; \text{ when } x \in \mathrm{int}(\mathrm{supp}(\nu_1 + \nu_2)) \\
0 &amp; \text{ otherwise}
\end{cases}\]
<p>によって実現できる.</p>
<h2>微分 (ライプニッツ則)</h2>
<p>ある多様体 \(M\) の上の関数全体 \(C^\infty(M)\) は自然にベクトル空間と見做すことが出来る. すなわち、 \(f, g \in C^\infty(M)\) と実数 \(\alpha, \beta\) について</p>
\[(\alpha f + \beta g)(x) = \alpha f(x) + \beta g(x)\]
<p>とすればよい.</p>
<p>また関数の乗算を次のように値の乗算として定義しておく.</p>
\[(f \cdot g)(x) = f(x) \cdot g(x)\]
<p>さて線形関数 \(D : C^\infty \to \mathbb{R}\) について次の性質 (これをライプニッツ則と呼ぶ) が成り立つと仮定する.</p>
\[D (f \cdot g) = Df \cdot g(p) + f(p) \cdot Dg\]
<p>ここで \(p\) は適当な点. \(Df, Dg\) は実数であることに註意. ライプニッツ則が成立する \(D\) 全体を \(\mathcal{D}_p\) と書く.</p>
<h3>\(\mathcal{D}_p\) は線形空間</h3>
<p>\(D_1, D_2 \in \mathcal{D}_p\) について、 \(\alpha D_1 + \beta D_2\) もまた、ライプニッツ則を満たすことから \(\mathcal{D}_p\) に属する. 従って \(\mathcal{D}_p\) は線形空間である.</p>
<h3>微分はライプニッツ則を満たす</h3>
<p>ライプニッツ則がいかにもそういう形をしてたから当然だけど.</p>
<p><div class=thm> 関数 \(f : M \to \mathbb{R}\) に対して、ある \(M\) 上の曲線 \(c\) を用いて</p>
\[f \mapsto \frac{d f \circ c}{dt}(t=t_0)\]
<p>はライプニッツ則を満たす線形関数である. </div></p>
<p>微分に関して親しんだいくつかの性質は実はライプニッツ則さえ成立すれば成り立つ.</p>
<h3>命題</h3>
<p><div class=thm> \(M\) 上の関数 \(f\) がある開集合 \(U\) の上で \(f|_U=0\) だったとき、 点 \(p \in U\) に対して、 任意の \(D \in \mathcal{D}_p\) を用いて</p>
\[Df = 0\]
<p>が成立する. </div></p>
<p>前章で示したことから、 \(\mathrm{supp}(g) \subseteq U\) なる関数 \(g\) が存在して、 \(f \cdot g = 0\) となる. \(D\) の線形性から \(D(fg)=0\) である.</p>
<p>ライプニッツ則から \(D(fg) = Df \cdot g(p) + f(p) \cdot Dg\) であるが、左辺は0、 \(f(p)=0\) より、 \(Df \cdot g(p) = 0\) を得、今 \(g(p)\) は一般に非ゼロなので結局 \(Df=0\) を得る.</p>
<h2>方向微分</h2>
<p>点 \(p\) の周りの局所座標 \((U, \varphi)\) に対して、曲線</p>
\[c_i : t \mapsto \varphi^{-1}(0,\ldots,0,t,0,\ldots,0)\]
<p>による微分</p>
\[D_{c_i} = \left(f \mapsto \frac{d f\circ c_i}{dt}(t=0)\right)\]
<p>これのことを</p>
\[\frac{\partial}{\partial x_i}\]
<p>と名付け、 <strong>方向微分</strong> と呼ぶ.</p>
<h3>命題</h3>
<p><div class=thm> \(\frac{\partial}{\partial x_i}\) と \(\frac{\partial}{\partial x_j}\) ( \(i \ne j\) ) とは一次独立である. </div></p>
<p><div class=thm> 多様体 \(M\) の次元が \(m\) で \(\varphi : x \mapsto (x_1, x_2, \ldots, x_m)\) に対して \(m\) 個の方向微分</p>
\[\left\{
\frac{\partial}{\partial x_i}
\right\}_{i=1,2,\ldots,m}\]
<p>が \(\mathcal{D}_p\) の基底になっている. </div></p>

<!--

  以下を埋め込むと H2 タグを列挙してそれぞれへのリンクにする.
  ただし "INDEX" は除外する.

    <div id=toc></div>


  H2, H3 タグまでを列挙するには以下を埋め込む.

    <div id=toc-level-2></div>

-->
<script>
(function() {

  function naming(obj, name) {
      var PREF = document.createElement('a');
      PREF.name = name;
      obj.appendChild(PREF);
  }

  function level1() {

    var sections = document.getElementsByTagName('h2');
    var OL = document.createElement('ol');
    for (var i=0; i < sections.length; ++i) {
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = sections[i].innerHTML;
      if (A.innerHTML.toUpperCase() == 'INDEX') continue;
      A.href = '#' + i;
      LI.appendChild(A);
      OL.appendChild(LI);
      naming(sections[i], i);
      // var PREF = document.createElement('a');
      // PREF.name = i;
      // sections[i].appendChild(PREF);
    }

    return OL;
  }

  function level2() {

    var sections = document.querySelectorAll('h2,h3');
    var tree = [];
    for (var i = 0; i < sections.length; ++i) {
      if (sections[i].tagName == 'H2') {
        if (sections[i].innerHTML.toUpperCase() === 'INDEX') continue;
        tree.push([sections[i]]);
      } else {
        if (tree.length > 0) {
          tree[tree.length-1].push(sections[i]);
        } else {
          tree.push([sections[i]]);
        }
      }
    }

    var OL = document.createElement('ol');
    for (var i = 0; i < tree.length; ++i) {

      // h2-level
      var LI = document.createElement('li');
      var A = document.createElement('a');
      A.innerHTML = tree[i][0].innerHTML;
      A.href = '#' + i;
      naming(tree[i][0], i);
      LI.appendChild(A);

      // h3-level
      if (tree[i].length > 1) {
        var OL_sub = document.createElement('ol');
        for (var j = 1; j < tree[i].length; ++j) {
          var LI_sub = document.createElement('li');
          var A = document.createElement('a');
          A.innerHTML = tree[i][j].innerHTML;
          A.href = `#${i}-${j}`;
          naming(tree[i][j], `${i}-${j}`);
          LI_sub.appendChild(A);
          OL_sub.appendChild(LI_sub);
        }
        LI.appendChild(OL_sub);
      }

      OL.appendChild(LI);
    }

    return OL;
  }

  function append_toc() {
    if (document.getElementById('toc')) {
      document.getElementById('toc').appendChild(level1());
    }
    if (document.getElementById('toc-level-2')) {
      document.getElementById('toc-level-2').appendChild(level2());
    }
  }

  window.addEventListener('DOMContentLoaded', append_toc, false);
}());
</script>

  <script src="https://cympfh.cc/resources/js/youtube.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script>
  <script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>