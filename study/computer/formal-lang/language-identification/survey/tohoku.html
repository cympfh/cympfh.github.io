<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>2006年度 計算機数学B 講義資料</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../../../../../resources/css/c.css">
  <link rel="stylesheet" href="./c.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">2006年度 計算機数学B 講義資料</h1>
</header>
<section>
<div class="author">
東北大学 赤間陽二
</div>
<div class="title">
2006年度 計算機数学B 講義資料
</div>
<div class="public">
<a href="http://www.math.tohoku.ac.jp/akama/Jugyou.html" class="uri">http://www.math.tohoku.ac.jp/akama/Jugyou.html</a>
</div>
<div class="note">
<a href="tohoku.html">tohoku.md</a>
</div>
</section>
<p>ググっていたら偶然見つけたもので、 東北大学の先生が講義のレジュメとしてpdfファイルをネットの上で公開された状態で置いてあったので読ませてもらう. 9年前のものなので (2015.6.4 Thu) いつまで置いてあるかわからない.</p>
<p><span class="date">0508</span></p>
<ol class="incremental" type="1">
<li>正規言語</li>
<li>帰納的言語</li>
<li>帰納的可算言語</li>
</ol>
<p>を考える.</p>
<p>これらは階層構造をしていて <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>正</mi><mi>規</mi><mi>言</mi><mi>語</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mo stretchy="false" form="prefix">(</mo><mi>帰</mi><mi>納</mi><mi>的</mi><mi>言</mi><mi>語</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mo stretchy="false" form="prefix">(</mo><mi>帰</mi><mi>納</mi><mi>的</mi><mi>可</mi><mi>算</mi><mi>言</mi><mi>語</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(正規言語) \subseteq (帰納的言語) \subseteq (帰納的可算言語)</annotation></semantics></math> とある. 例えば、反復補題の格好の例として、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{a^n b^n : n\in\mathbb{N}\}</annotation></semantics></math> は正規言語には含まれないが、帰納的言語である.</p>
<h2 id="正規言語の定義">正規言語の定義</h2>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> が正規言語である <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇔</mo><annotation encoding="application/x-tex">\iff</annotation></semantics></math><br />
ある決定性有限オートマトン (DFA) によって受理できる文字列全体と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>が一致すること.</p>
<h2 id="帰納的言語の定義">帰納的言語の定義</h2>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> が帰納的言語である <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇔</mo><annotation encoding="application/x-tex">\iff</annotation></semantics></math><br />
文字列が与えられたとき、これが言語<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>に含まれるかの判定をある帰納関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mo>:</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo accent="false">→</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\chi (: \Sigma^* \rightarrow \{0,1\})</annotation></semantics></math> でできること. <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo accent="false">⇔</mo><mi>w</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\chi(w) \iff w \in L</annotation></semantics></math></p>
<h2 id="帰納的可算言語の定義">帰納的可算言語の定義</h2>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> が帰納的可算である <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇔</mo><annotation encoding="application/x-tex">\iff</annotation></semantics></math> 帰納関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><mo accent="false">↦</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">e : \mathbb{N} \mapsto \Sigma^*</annotation></semantics></math> を用いて <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>e</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>n</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L = \{ e(n) : n \in \mathbb{N}\}</annotation></semantics></math> とできること.<br />
あと空な言語も特殊に帰納的可算とする.<br />
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> は列挙関数と呼ばれる.</p>
<h3 id="prop.-帰納的言語の補言語は帰納的言語">Prop. 帰納的言語の補言語は帰納的言語</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mi>′</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\chi&#39;(w) = 1 - \chi(w)</annotation></semantics></math></p>
<h2 id="認識可能性">認識可能性</h2>
<p>プラグラム <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> がその言語を<em>認識</em>するとは、 言語が含む任意の文字列を入力すると停止すること.</p>
<p>次に見るように、認識可能であることと、帰納的可算言語であることとは、同値.</p>
<h3 id="prop.-帰納的可算言語-rightarrow-認識可能">Prop. 帰納的可算言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> 認識可能</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> P(w):
  e <span class="op">=</span> enumerator <span class="cf">for</span> L
  <span class="cf">for</span> i <span class="kw">in</span> [<span class="dv">0</span>..]
    <span class="cf">if</span> w <span class="kw">is</span> e(i):
      <span class="cf">return</span> i</code></pre></div>
<h3 id="prop.-認識可能-rightarrow-帰納的可算言語">Prop. 認識可能 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> 帰納的可算言語</h3>
<p>まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mo stretchy="false" form="prefix">(</mo><mi>ℕ</mi><mo>,</mo><mi>ℕ</mi><mo stretchy="false" form="postfix">)</mo></mstyle><annotation encoding="application/x-tex">\mathbb{(N, N)}</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math> とは準同型だから <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i, j) = f(t)</annotation></semantics></math> という準同型写像が存在する.<br />
具体的には、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mi>/</mi><mn>2</mn><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f^{-1}(n, m) = (n+m) (n+m+1)/2 + n</annotation></semantics></math> の逆像である.</p>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> について,</p>
<ol class="incremental" type="1">
<li>これを認識する <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>が空でないのなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in L</annotation></semantics></math> な <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> を持っておく</li>
<li>なんでもいいから <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Σ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math> についての列挙 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><msub><mo stretchy="false" form="postfix">)</mo><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">(w_i)_i</annotation></semantics></math></li>
</ol>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の列挙 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">e(t)</annotation></semantics></math> は次のようにする.</p>
<ol class="incremental" type="1">
<li>let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i, j) = f(t)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math> を 時間 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math> の制限つきで <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> に認識させる</li>
<li>制限時間未満に停止したなら <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w_i \in L</annotation></semantics></math> なので <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e(t) = w_i</annotation></semantics></math></li>
<li>さもなくば, よくわからないので <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">e(t) = w</annotation></semantics></math></li>
</ol>
<p>すべての <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>w</mi><mi>i</mi></msub><annotation encoding="application/x-tex">w_i</annotation></semantics></math> についてすべての制限時間で認識するのでいつかは言語すべてを列挙できる</p>
<h2 id="帰納的言語-subseteq-帰納的可算言語">帰納的言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊆</mo><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math> 帰納的可算言語</h2>
<p>帰納的言語は、帰納的可算言語である.</p>
<p>Proof.<br />
帰納的言語ならば、 membership 関数 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math> があって、 それを用いて、停止するかしないか選ぶプログラムを書ける.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> P(w):
  <span class="cf">if</span> chi(w):
    <span class="cf">return</span>
  <span class="cf">else</span>
    loop</code></pre></div>
<h2 id="プログラムの表現">プログラムの表現</h2>
<p>プログラムの文字列による表現を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> とする.<br />
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> が表現するプログラムによって認識される言語を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">L(p)</annotation></semantics></math> と書く.</p>
<p>帰納的可算言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> について、 これを認識するプログラムの表現 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> が存在する.</p>
<h3 id="定理">定理</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>Γ</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\Gamma^*</annotation></semantics></math> をプログラム全体、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>L</mi><mi>c</mi></msup><annotation encoding="application/x-tex">L^c</annotation></semantics></math> を 言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の補言語とするとき、 <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>p</mi><mo>∈</mo><msup><mi>Γ</mi><mo>*</mo></msup><mo>:</mo><msup><mi>L</mi><mi>c</mi></msup><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>∋</mo><mi>p</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">J = \{ p \in \Gamma^* : L^c(p) \ni p \}</annotation></semantics></math> は帰納的可算ではない. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math> とは自身を認識できないプログラム全体の集合.</p>
<h3 id="補題">補題</h3>
<p>集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math> からその 冪集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="script"><mi>𝒫</mi></mstyle><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{P}(R)</annotation></semantics></math> への全射というものは存在しない</p>
<h3 id="定理-1">定理</h3>
<p>自身を認識できるプログラムの集合: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>p</mi><mo>∈</mo><msup><mi>Γ</mi><mo>*</mo></msup><mo>:</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>∋</mo><mi>p</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">K = \{ p \in \Gamma^* : L(p) \ni p \}</annotation></semantics></math> これは帰納的ではく、帰納的可算である (もちろん <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math> の補集合である).</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math> を認識するプログラムは次を実行すればよい: 入力 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> を解釈することで、プログラム <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> を得る. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(p)</annotation></semantics></math> を実行したとき、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">p \in K</annotation></semantics></math> ならば、これは停止する. さもなくば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> は停止しない.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># K を認識するプログラム</span>
<span class="kw">def</span> PK(p):
  P <span class="op">=</span> <span class="bu">eval</span>(p)
  P(p)</code></pre></div>
<p><span class="date">0515</span></p>
<h1 id="推論機械">推論機械</h1>
<h2 id="言語の完全提示">言語の完全提示</h2>
<p>語と二値のペアの無限列 <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><msub><mi>I</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>w</mi><mn>2</mn></msub><mo>,</mo><msub><mi>I</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\sigma = (w_1, I_1), (w_2, I_2), ...</annotation></semantics></math> であって、次を満たすものを、 言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の完全提示という.</p>
<ol class="incremental" type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><msub><mi>w</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="postfix">}</mo><mo>=</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">\{ w_1, w_2, ... \} = \Sigma^*</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>i</mi></msub><mo>∧</mo><msub><mi>w</mi><mi>i</mi></msub><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">I_i \land w_i \in L</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>¬</mi><msub><mi>I</mi><mi>i</mi></msub><mo>∧</mo><msub><mi>w</mi><mi>i</mi></msub><mo>∉</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\lnot I_i \land w_i \not\in L</annotation></semantics></math></li>
</ol>
<p>無限列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> に対して、その断片 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>,</mo><msub><mi>I</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>,</mo><msub><mi>I</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma[i] = (w_1, I_1) ... (w_i, I_i)</annotation></semantics></math> を入力として受け取ったときに、 推測 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>i</mi></msub><annotation encoding="application/x-tex">g_i</annotation></semantics></math> を出力するものを推論機械という.</p>
<h3 id="極限同定の定義">極限同定の定義</h3>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の任意の完全提示 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> についての推論 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>i</mi></msub><annotation encoding="application/x-tex">g_i</annotation></semantics></math> が極限で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math> を定めて <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L(g) = L</annotation></semantics></math> であること</p>
<p>言ってしまえば、 推論機械というのは、</p>
<ol class="incremental" type="1">
<li>新しい例が提示されるたびに、</li>
<li>過去に提示されたものに矛盾しない、</li>
<li>表現クラスの枚挙の中で最初の表現を</li>
<li>仮説として出力する</li>
</ol>
<h3 id="枚挙による学習機械">枚挙による学習機械</h3>
<p>帰納的可算な表現(言語)クラス <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math> を持つ、<br />
添字付き帰納的言語クラス <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math> の下で極限同定する<br />
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi><mo>,</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>r</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r \in R, L(r) = C_i</annotation></semantics></math>)</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">r \in R</annotation></semantics></math> は可算だからそれを列挙しておいて、<br />
提示に対して無矛盾なものの最初の一つを推測することをひたすらする</p>
<p><span class="date">0522</span></p>
<p>枚挙による学習機械は一般に効率的 (多項式時間) ではない<br />
正規言語については効率的な方法がある、という話</p>
<h3 id="無矛盾">無矛盾</h3>
<p>断片 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\sigma[i]</annotation></semantics></math> を受け取ったときの推測 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>i</mi></msub><annotation encoding="application/x-tex">g_i</annotation></semantics></math> について、 いつも <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo><mo>⊆</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\sigma[i] \subseteq L(g_i)</annotation></semantics></math> が成立するように推測すること.</p>
<p>ここで、断片は本来列だけど、集合であるかのように書いた.</p>
<h3 id="保守">保守</h3>
<p>推測の列 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>,</mo><msub><mi>g</mi><mn>2</mn></msub><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">g_1, g_2 ...</annotation></semantics></math> について <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>⊇</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>⊇</mo><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">L(g_1) \supseteq L(g_2) \supseteq ...</annotation></semantics></math> とあるように推測すること.</p>
<p><span class="date">0529</span></p>
<p>正規言語の学習とは即ち、言語から有限オートマトンを復元することにほかならない. 完全提示からは、無矛盾かつ保守的に推論が可能. 詳しくは、 &quot;Regular Positive Negative Inference (RPNI) アルゴリズム&quot; でググること.</p>
<p><span class="date">0605</span></p>
<h2 id="言語の正提示">言語の正提示</h2>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の正提示とは、<br />
語の無限列 <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><msub><mi>σ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>σ</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\sigma = \sigma_1, \sigma_2, ...</annotation></semantics></math> であって、 <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>σ</mi><mi>i</mi></msub><mo>:</mo><mi>i</mi><mo stretchy="false" form="postfix">}</mo><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\{\sigma_i:i\} = L</annotation></semantics></math> を満たすようなものを言う.</p>
<h3 id="正提示の学習機械">正提示の学習機械</h3>
<p>完全提示を考えていたのを、 正提示の断片を入力にし、 極限において同定する問題に変形する</p>
<h3 id="超有限">超有限</h3>
<p>言語クラス <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> が超有限であるとは、</p>
<ol class="incremental" type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∃</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> infinite </mtext><mspace width="0.333em"></mspace></mrow><mi>L</mi><mo>,</mo><mi>L</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\exists \text{ infinite } L, L \in C</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> finite </mtext><mspace width="0.333em"></mspace></mrow><mi>L</mi><mi>′</mi><mo>,</mo><mi>L</mi><mi>′</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\forall \text{ finite } L&#39;, L&#39; \in C</annotation></semantics></math></li>
</ol>
<p>こういうのは、簡単に言えば大きすぎるクラスである.</p>
<h3 id="prop.-超有限な言語クラスは正提示から極限同定不能">Prop. 超有限な言語クラスは正提示から極限同定不能</h3>
<p>無限な方の言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> を正提示から学習できない. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の任意の正提示の断片 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\sigma[i]</annotation></semantics></math> について、 これを被覆する有限の言語が常に、言語クラスに持つからである.</p>
<h3 id="prop.-正規言語全体は超有限である">Prop. 正規言語全体は超有限である</h3>
<p>有限な言語というのは常に正規言語であるから.</p>
<h2 id="言語クラスの階層">言語クラスの階層</h2>
<ol class="incremental" type="1">
<li>超有限は完全提示で学習可能</li>
<li>正規言語全体のクラスは超有限</li>
<li>パターン言語全体のクラスは正提示から学習可能</li>
<li>ゼロリバーシブル言語は正提示から学習可能</li>
</ol>
<p>もちろん、パターン言語と正規言語はオーバーラップ (正規パターン) があるがな.</p>
<h1 id="パターン">パターン</h1>
<h2 id="パターンの定義">パターンの定義</h2>
<ul class="incremental">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>: 大きさ2以上</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>V</mi><annotation encoding="application/x-tex">V</annotation></semantics></math>: 変数の無限集合</li>
</ul>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Σ</mi><mo>,</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">\Sigma, V</annotation></semantics></math> の元からなる空でない語をパターンという</p>
<p>代入とは変数をパターンで置き換える操作</p>
<p>普通、同時に置き換えを1つ以上行ってよいが、 変数は無限にあるんだから一旦別なものに置き換えることで一つずつ行っても同値だよなぁ</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">↦</mo><mi>y</mi><mo>,</mo><mi>y</mi><mo accent="false">↦</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\theta = \{ x \mapsto y, y \mapsto x \}</annotation></semantics></math> によって <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mi>x</mi><mi>x</mi><mi>y</mi><mi>y</mi><mo accent="false">↦</mo><mi>y</mi><mi>y</mi><mi>x</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">p = xxyy \mapsto yyxx</annotation></semantics></math> であるけど</p>
<ol class="incremental" type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo accent="false">↦</mo><mi>z</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\theta_1 = \{x \mapsto z\}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>y</mi><mo accent="false">↦</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\theta_2 = \{y \mapsto x\}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>3</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>z</mi><mo accent="false">↦</mo><mi>y</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\theta_3 = \{z \mapsto y\}</annotation></semantics></math></li>
</ol>
<p>を順に適用してもいいよな</p>
<h2 id="汎化関係-less-general-than-relation-preceq">汎化関係 (Less-general-than relation) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≼</mo><annotation encoding="application/x-tex">\preceq</annotation></semantics></math></h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≼</mo><mi>q</mi><mo accent="false">⇔</mo><mo>∃</mo><mi>θ</mi><mi>.</mi><mspace width="0.222em"></mspace><mi>p</mi><mo>=</mo><mi>q</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">p \preceq q \iff \exists \theta .~ p = q\theta</annotation></semantics></math></p>
<h2 id="パターン言語">パターン言語</h2>
<p>パターン <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> に対して、 言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>+</mo></msup><mo>:</mo><mi>w</mi><mo>≼</mo><mi>p</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L(p) = \{ w \in \Sigma^+ : w \preceq p\}</annotation></semantics></math></p>
<ul class="incremental">
<li>長さについて <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">L(p)</annotation></semantics></math> の最小値は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">|</mo><mi>p</mi><mo stretchy="false" form="prefix">|</mo></mrow><annotation encoding="application/x-tex">|p|</annotation></semantics></math> と一致する</li>
<li>同じ変数が高々一回しか出現しないパターン言語は正規言語である</li>
</ul>
<h2 id="lpp-は添字付き帰納的言語クラス"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>p</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{L(p):p\}</annotation></semantics></math> は添字付き帰納的言語クラス</h2>
<p><span class="date">0612</span></p>
<p>表現クラスをパターン全体とする言語クラスを <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="script"><mi>𝒫</mi><mi>𝒜</mi><mi>𝒯</mi></mstyle><annotation encoding="application/x-tex">\mathcal{PAT}</annotation></semantics></math> (パターン言語全体) と書くことにする</p>
<p>これは帰納的言語クラスであって:<br />
任意のパターン <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> について 次のようなプログラム <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math> が存在する <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>,</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo accent="false">⇔</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>∈</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">\chi(p, w) \iff L(p) \in w</annotation></semantics></math></p>
<p>じゃあこの <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math> を構成してみる</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>∈</mo><mi>Σ</mi><mo>,</mo><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup><mo>,</mo><mi>x</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">a, b \in \Sigma, w \in \Sigma^*, x \in V</annotation></semantics></math>, パターン <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math></p>
<ul class="incremental">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>w</mi><mo>≠</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\chi(x, w) = w \ne \lambda</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> は空列)</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mo>≡</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\chi(a, b) = a \equiv b</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>p</mi><mo>,</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo>∃</mo><mi>u</mi><mo>,</mo><mi>v</mi><mi>.</mi><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mi>v</mi><mo>≡</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>∧</mo><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo>≠</mo><mi>λ</mi><mo stretchy="false" form="postfix">)</mo><mo>∧</mo><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mi>/</mi><mi>u</mi><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\chi(xp, w) = \exists u, v .~ (uv \equiv w) \land (u \ne \lambda) \land \chi(p[x/u], v)</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mi>p</mi><mo>,</mo><mi>b</mi><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>≡</mo><mi>b</mi><mo>∧</mo><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>,</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\chi(ap, bw) = (a \equiv b \land \chi(p, w))</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>χ</mi><mo stretchy="false" form="prefix">(</mo><mi>_</mi><mo>,</mo><mi>_</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">\chi(\_, \_) = false</annotation></semantics></math> otherwise</li>
</ul>
<p>まあ当たり前のこと書いてるだけだ</p>
<h2 id="標準形パターン">標準形パターン</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>≼</mo><mi>q</mi><mo>∧</mo><mi>p</mi><mo>≽</mo><mi>q</mi><mo accent="false">⇔</mo><mi>p</mi><mo>≡</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \preceq q \land p \succeq q \iff p \equiv q</annotation></semantics></math> とすると、 変数のリネームは等価</p>
<p>パターン <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> 中で出現する変数を左から <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">x_1, x_2, ..., x_k</annotation></semantics></math> としたものを標準形という</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≤</mo><mo stretchy="false" form="prefix">|</mo><mi>p</mi><mo stretchy="false" form="prefix">|</mo></mrow><annotation encoding="application/x-tex">k \leq |p|</annotation></semantics></math> であって、言語は標準形にしても変わらないこと</p>
<h2 id="極小学習戦略">極小学習戦略</h2>
<p>正提示の断片 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\sigma[i]</annotation></semantics></math> に対して <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>σ</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo><mo>⊆</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{L(p) : \sigma[i] \subseteq L(p)\}</annotation></semantics></math> は有限であって空ではない</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>⊤</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\top = x_1</annotation></semantics></math> があるだからまぁ、な</p>
</blockquote>
<p>というわけで 言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">L(g_i)</annotation></semantics></math> の中で <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊆</mo><annotation encoding="application/x-tex">\subseteq</annotation></semantics></math> に関して極小な <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>i</mi></msub><annotation encoding="application/x-tex">g_i</annotation></semantics></math> が存在する</p>
<p>これを計算する戦略を極小学習戦略と呼ぶ</p>
<ul class="incremental">
<li>最長のパターンが最小の言語を生成する</li>
</ul>
<p><span class="date">0619</span></p>
<h1 id="kmp言語">KMP言語</h1>
<h2 id="部分列">部分列</h2>
<p>アルファベット集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math> の上の文字列の関係を次のように定義する</p>
<center>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>⊲</mo><mi>v</mi><mo accent="false">⇔</mo></mrow><annotation encoding="application/x-tex">u \lhd v \iff</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math> は <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math> の部分文字列である (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∃</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup><mi>.</mi><mspace width="0.222em"></mspace><mi>x</mi><mi>u</mi><mi>y</mi><mo>≡</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">\exists x, y \in \Sigma^* .~ xuy \equiv v</annotation></semantics></math>)
</center>
<ul class="incremental">
<li>反射律</li>
<li>推移律</li>
</ul>
<h2 id="kmp言語-1">KMP言語</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><msup><mi>Σ</mi><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">w \in \Sigma^*</annotation></semantics></math> の生成するKMP言語とは</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>w</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>v</mi><mo>:</mo><mi>w</mi><mo>⊲</mo><mi>v</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L(w) = \{ v : w \lhd v \}</annotation></semantics></math></p>
<p>定義から <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>⊲</mo><mi>v</mi><mo accent="false">⇔</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo stretchy="false" form="postfix">)</mo><mo>⊆</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>u</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">u \lhd v \iff L(v) \subseteq L(u)</annotation></semantics></math> であることは明らか</p>
<h2 id="極小学習">極小学習</h2>
<p>KMP言語は<em>有限の厚さ (finite thickness)</em> を持って、 極小言語学習の戦略で学習可能</p>
<p>有限証拠の最長共通部分文字列(連続列)をとればいいだけ</p>
<p><em>有限の厚さ</em> の定義を実のところ未だ知らない</p>
<p><span class="date">0626</span></p>
<ol class="incremental" type="1">
<li>有限の厚さを持つ</li>
<li>特徴例集合を持つ</li>
<li>有限証拠を持つ</li>
</ol>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo accent="false">⇒</mo><mn>2</mn><mo accent="false">⇒</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1 \Rightarrow 2 \Rightarrow 3</annotation></semantics></math> であって逆は成り立たない<br />
1.2. はMINLで正提示から学習が可能</p>
<h2 id="minl">MINL</h2>
<p>復習になるけど、言語クラス <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> 中のある言語の有限部分証拠 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math> があるときに</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∈</mo><mi>M</mi><mi>I</mi><mi>N</mi><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>S</mi><mo>,</mo><mi>C</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">L \in MINL(S, C)</annotation></semantics></math> とは、 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics></math>を内包する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>′</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">L&#39; \in C</annotation></semantics></math> のなかで極小なものの一つが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>であること</p>
<p>言語クラスが何かを情報として使っていいことに注意</p>
<h2 id="有限の厚さを持つ-rightarrow-minlは非空有限集合">有限の厚さを持つ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> MINLは非空有限集合</h2>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> が有限の厚さを持つとは、
<center>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>w</mi><mi>.</mi><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">{</mo><mi>L</mi><mo>:</mo><mi>w</mi><mo>∈</mo><mi>L</mi><mo>∈</mo><mi>C</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\forall w .~ \{L:w\in L\in C\}</annotation></semantics></math> が有限集合
</center>
<p>例えば今まで見てきたパターン言語やKMP言語といったクラスは有限の厚さを持つ</p>
<h2 id="有限の厚さを持たない例">有限の厚さを持たない例</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>w</mi><mo stretchy="false" form="prefix">|</mo><mo>≤</mo><mi>i</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L_i = \{ w : |w| \leq i \}</annotation></semantics></math> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>k</mi><mo accent="false">⇔</mo><msub><mi>L</mi><mi>i</mi></msub><mo>⊂</mo><msub><mi>L</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">i &lt; k \iff L_i \subset L_k</annotation></semantics></math>)</p>
<p>これは <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>w</mi><annotation encoding="application/x-tex">w</annotation></semantics></math> に対して <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w \in L_i</annotation></semantics></math> となる <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> は可算無限個あって厚さは有限ではない.</p>
<p>しかしながら極小言語は簡単に考えられる:<br />
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>I</mi><mi>N</mi><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>w</mi><mn>1</mn></msub><mi>.</mi><mi>.</mi><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mi>C</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>L</mi><mi>k</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">MINL(\{w_1 .. w_n\}, C) = \{ L_k \}</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mo>max</mo><mo stretchy="false" form="prefix">{</mo><mo stretchy="false" form="prefix">|</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="false" form="prefix">|</mo><mi>.</mi><mi>.</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false" form="prefix">|</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">k = \max \{ |w_1| .. |w_n|\}</annotation></semantics></math></p>
<h2 id="minlが無限集合-rightarrow-有限の厚さを持たない">MINLが無限集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> 有限の厚さを持たない</h2>
<p>これは自明.<br />
MINLが無限とはつまり有限証拠の任意の一つが属する言語が無限であることだから.</p>
<h3 id="minlが無限集合となるような例">MINLが無限集合となるような例</h3>
<ol class="incremental" type="1">
<li>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>i</mi></msub><annotation encoding="application/x-tex">L_i</annotation></semantics></math> を <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>i</mi></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{a^i\}</annotation></semantics></math> の補集合として、この言語クラスを考える.</li>
<li>どの <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>i</mi></msub><annotation encoding="application/x-tex">L_i</annotation></semantics></math> と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>j</mi></msub><annotation encoding="application/x-tex">L_j</annotation></semantics></math> も包含関係にそもそもないから任意の言語を持ってきて極小だと言える</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>I</mi><mi>N</mi><mi>L</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>a</mi><mi>j</mi></msup><mo>,</mo><mi>C</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>L</mi><mi>k</mi></msub><mo>:</mo><mi>k</mi><mo>≠</mo><mi>j</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">MINL(a^j, C) = \{ L_k : k \ne j \}</annotation></semantics></math></li>
</ol>
<h2 id="minlが空の例">MINLが空の例</h2>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>i</mi></msub><annotation encoding="application/x-tex">L_i</annotation></semantics></math> は空文字列と長さが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>より大きい語全体 <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>λ</mi><mo stretchy="false" form="postfix">}</mo><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>w</mi><mo stretchy="false" form="prefix">|</mo><mo>&gt;</mo><mi>i</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L_i = \{\lambda\} \cup \{w:|w|&gt;i\}</annotation></semantics></math> このとき <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub><mo>⊃</mo><msub><mi>L</mi><mn>1</mn></msub><mo>⊃</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>⊃</mo><msub><mi>L</mi><mi>n</mi></msub><mo>⊃</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>⊃</mo><mo stretchy="false" form="prefix">{</mo><mi>λ</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L_0 \supset L_1 \supset ... \supset L_n \supset ... \supset \{\lambda\}</annotation></semantics></math> という包含関係になる <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>I</mi><mi>N</mi><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">{</mo><mi>λ</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo><mi>C</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">MINL(\{\lambda\}, C)</annotation></semantics></math> を考えるとこれは空になる (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>∞</mi></msub><annotation encoding="application/x-tex">L_\infty</annotation></semantics></math> というこの言語クラスにおけるボトムだ)</p>
<h2 id="ここまでのまとめ">ここまでのまとめ</h2>
<ul class="incremental">
<li>有限の厚さ ならば MINLは非空有限
<ul class="incremental">
<li>有限の厚さでなくても MINLが無限でないこともある</li>
</ul></li>
<li>MINLが無限 ならば 有限の厚さではない</li>
</ul>
<p>この二つは別に同値ではない<br />
有限の厚さはMINLを使うための十分条件でしかない</p>
<h2 id="特徴例集合">特徴例集合</h2>
<p>言語クラス <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> に関する言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mo>∈</mo><mi>C</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">L (\in C)</annotation></semantics></math> の特徴例集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math> とは</p>
<ol class="incremental" type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math> は有限集合</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊆</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">F \subseteq L</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>L</mi><mi>′</mi><mo>∈</mo><mi>C</mi><mi>.</mi><mspace width="0.222em"></mspace><mi>F</mi><mo>⊆</mo><mi>L</mi><mi>′</mi><mo accent="false">⇒</mo><mi>L</mi><mo>⊆</mo><mi>L</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">\forall L&#39; \in C .~ F \subseteq L&#39; \Rightarrow L \subseteq L&#39;</annotation></semantics></math></li>
</ol>
<p><em>N.B.</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>が有限集合なら <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">F=L</annotation></semantics></math> とすれば上は自明に満たされて、これは言語自身が特徴例集合だ</p>
<p>任意の <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> が特徴例集合を持つとき、 「言語クラス <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> は特徴例集合を持つ」という</p>
<h2 id="例.-特徴例集合を持つが有限の厚さを持たない">例. 特徴例集合を持つが有限の厚さを持たない</h2>
<p>先ほどの <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo>:</mo><mo stretchy="false" form="prefix">|</mo><mi>w</mi><mo stretchy="false" form="prefix">|</mo><mo>≤</mo><mi>i</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L_i = \{w:|w|\leq i\}</annotation></semantics></math> を考える<br />
これは有限の厚さを持たなかった</p>
<p>さて <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>i</mi></msub><annotation encoding="application/x-tex">L_i</annotation></semantics></math> は有限集合なので (アルファベットは有限集合) それ自身が特徴例集合だ</p>
<h2 id="thm.-有限の厚さを持つならば特徴例集合を持つ">Thm. 有限の厚さを持つならば、特徴例集合を持つ</h2>
<p>厳密な証明ではないが...<br />
実際に特徴例集合を構成してみせればよい</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>の特徴例集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math> を構成することを考える</p>
<ol class="incremental" type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>w</mi><mn>0</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">F_0 = \{w_0\}</annotation></semantics></math> s.t. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mn>0</mn></msub><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w_0 \in L</annotation></semantics></math></li>
<li>for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
<ol class="incremental" type="1">
<li>assert <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub><mo>⊆</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">F_i \subseteq L</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub><mo>⊆</mo><mi>L</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">F_i \subseteq L&#39;</annotation></semantics></math> かつ not(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><mi>L</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">L \subseteq L&#39;</annotation></semantics></math>) となるような <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">L&#39;</annotation></semantics></math> は言語クラスの厚さゆえ有限である</li>
<li>そのような <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">L&#39;</annotation></semantics></math> がないなら終了して <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><msub><mi>F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">F = F_i</annotation></semantics></math> とする</li>
<li>not(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><mi>L</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">L \subseteq L&#39;</annotation></semantics></math>) と <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∩</mo><mi>L</mi><mi>′</mi><mo>≠</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">L \cap L&#39; \ne \emptyset</annotation></semantics></math> から <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>′</mi><mo>\</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L&#39; \setminus L</annotation></semantics></math> は非空</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><mi>L</mi><mi>′</mi><mo>\</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">w \in L&#39; \setminus L</annotation></semantics></math> とする</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>F</mi><mi>i</mi></msub><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>w</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">F_{i+1} = F_i \cup \{w\}</annotation></semantics></math></li>
</ol></li>
</ol>
<p>ループのたび 2-2 における <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">L&#39;</annotation></semantics></math> の数は必ず減っていくので有限ステップで終了する</p>
<h2 id="thm.-特徴例集合をもつならばminlを使える">Thm. 特徴例集合をもつならば、MINLを使える</h2>
<ul class="incremental">
<li>有限の厚さ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> MINL</li>
<li>有限の厚さ <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> 特徴例集合</li>
<li>特徴例集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math> MINL (<code>&lt;- new!</code>)</li>
</ul>
<p>証明は大体自明だと思う</p>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の正提示断片 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo stretchy="false" form="prefix">[</mo><mi>i</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\sigma[i]</annotation></semantics></math> からの推測 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>g</mi><mi>i</mi></msub><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mo>⊇</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">L(g_i) (\supseteq L)</annotation></semantics></math> は特徴例集合を持ってて、 その定義式ってまさしく極小を表してる</p>
<h2 id="有限証拠の定義">有限証拠の定義</h2>
<p>言語 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math> の有限部分集合 (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> とする) であって <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>L</mi><mi>′</mi><mi>.</mi><mspace width="0.222em"></mspace><mi>T</mi><mo>⊆</mo><mi>L</mi><mi>′</mi><mo accent="false">⇒</mo><mi>L</mi><mi>′</mi><mo>⊄</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\forall L&#39; .~ T \subseteq L&#39; \Rightarrow L&#39; \not\subset L</annotation></semantics></math> とある <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math> を有限証拠という.</p>
<p>右辺は特徴例集合に似てるけど &quot;特徴例集合ならば有限証拠&quot; である.</p>
<h3 id="例.-有限証拠であって特徴例集合ではないもの">例. 有限証拠であって特徴例集合ではないもの</h3>
<p>言語クラス <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>L</mi><mn>1</mn></msub><mo>,</mo><msub><mi>L</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">C = \{L_1, L_2\}</annotation></semantics></math>;</p>
<ul class="incremental">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo stretchy="false" form="postfix">}</mo><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>b</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L_1 = \{ a^n:n \} \cup \{b^n:n\}</annotation></semantics></math></li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo stretchy="false" form="postfix">}</mo><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>c</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">L_2 = \{ a^n:n \} \cup \{c^n:n\}</annotation></semantics></math></li>
</ul>
<p>一方は他方と異なる部分を持っている</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">T = \{a^n:n\}</annotation></semantics></math> は特徴例集合ではないが有限証拠としては問題ない</p>
<p>このような場合、提示として <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msup><mi>a</mi><mi>n</mi></msup><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{a^n\}</annotation></semantics></math> からなる列が来ても正しくMINLできない</p>
<p><span class="date">0703</span></p>
<ol class="incremental" type="1">
<li>正提示から学習可能</li>
<li>(EC1) 有限証拠が<em>一様に帰納的列挙可能</em></li>
<li>(C2) 特徴例集合を持つ</li>
<li>(C3) 有限の弾力性を持つ</li>
<li>(C4) 有限の厚さを持つ</li>
</ol>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo accent="false">⇒</mo><mn>4</mn><mo accent="false">⇒</mo><mn>3</mn><mo accent="false">⇒</mo><mn>2</mn><mo accent="false">⇔</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">5 \Rightarrow 4 \Rightarrow 3 \Rightarrow 2 \iff 1</annotation></semantics></math></p>
<p>これを見ていく</p>
<h2 id="ec1-有限証拠の一様帰納的列挙">EC1: 有限証拠の一様帰納的列挙</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> を入力として、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>i</mi></msub><annotation encoding="application/x-tex">L_i</annotation></semantics></math> の有限証拠 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>T</mi><mi>i</mi></msub><annotation encoding="application/x-tex">T_i</annotation></semantics></math> を列挙するような帰納的手続き. 即ち、マシーン <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> は</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>,</mo><msub><mi>τ</mi><mn>2</mn></msub><mi>.</mi><mi>.</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">M(i) = \tau_1, \tau_2 ...</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mi>k</mi></msub><mo>⊂</mo><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\tau_k \subset L_i</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>⋃</mo><mi>k</mi></msub><msub><mi>τ</mi><mi>k</mi></msub><mo>=</mo><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\bigcup_k \tau_k = T_i</annotation></semantics></math></p>
<p>というもの.</p>
<h2 id="特徴例集合-f-が存在するならばec1-は満たされる.">特徴例集合 <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math> が存在するならば、EC1 は満たされる.</h2>
<h2 id="有限の弾力性-finite-elasticity">有限の弾力性 (finite elasticity)</h2>
<p>定義は以下通り: <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∀</mo><mi>w</mi><mo>,</mo><mo stretchy="false" form="prefix">|</mo><mo stretchy="false" form="prefix">{</mo><mi>L</mi><mo>:</mo><mi>w</mi><mo>∈</mo><mi>L</mi><mo stretchy="false" form="postfix">}</mo><mo stretchy="false" form="prefix">|</mo><mo>&lt;</mo><mi>∞</mi></mrow><annotation encoding="application/x-tex">\forall w, |\{ L : w \in L \}| &lt; \infty</annotation></semantics></math></p>
<p>対義語は「無限の弾力性」.</p>
<p><span class="date">0710</span></p>
<h2 id="ec1-iff-極限同定可能">EC1 iff 極限同定可能</h2>
</body>
</html>
